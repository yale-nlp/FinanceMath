[
    {
        "question_id": "validation-0",
        "question": "A business chose to swap a truck that it had bought three years ago for a parcel of land owned by a different enterprise. The subsequent table outlines information pertinent to both assets: The profit and loss statement for the enterprise that relinquishes the truck is most likely going to reflect a loss of:",
        "tables": [
            "|               |      Truck*     |     Land**    |\n|---------------|:---------------:|:-------------:|\n| Original cost |     $ 57,000    |    $ 18,000   |\n| Estimated life|     8 years     |               |\n|  Estimated salvage value at purchase |     $ 15,000    |               |\n| Depreciation method | Declining balance, 20% per year |               |\n| Current fair value of item |     $ 27,000    |    $ 21,000   |  \n\n\\* The last sale of a similar truck by the company occurred more than six months ago.  \n\\** The land is one of four identical parcels of land recently sold by the company."
        ],
        "python_solution": "def solution():\n    truck_value = 57000\n    depreciation_rate = 0.20\n    years = 3\n    land_value = 21000\n    \n    truck_carrying_value = truck_value * ((1 - depreciation_rate)**years)\n    loss = land_value - truck_carrying_value\n    \n    return loss",
        "ground_truth": -8184.0,
        "topic": "Accounting",
        "output": [
            "Before coding the solution, one key piece of information is missing: the estimated life of the land (it is provided for the truck but not for the land). The depreciation of the land, however, is typically not calculated as land does not usually depreciate in value.\n\nAssuming the information given is all that's needed and that we should not account for the depreciation of the land, here's the Python program to calculate the loss on the exchange of the truck for the land:\n\n```python\ndef solution():\n    # Define variables name and value for the truck\n    original_cost_truck = 57000\n    estimated_salvage_value_truck = 15000\n    depreciation_rate_truck = 20 / 100  # 20% per year as declining balance\n    years_owned = 3\n    current_fair_value_of_truck = 27000\n\n    # Calculate accumulated depreciation for the truck\n    # Using the declining balance method\n    accumulated_depreciation_truck = original_cost_truck\n    for year in range(years_owned):\n        depreciation_expense_for_year = accumulated_depreciation_truck * depreciation_rate_truck\n        accumulated_depreciation_truck -= depreciation_expense_for_year\n\n    book_value_of_truck = original_cost_truck - accumulated_depreciation_truck\n    \n    # Define variables name and value for the land\n    current_fair_value_of_land = 21000\n\n    # Calculate loss on sale of truck\n    # Loss or gain is the difference between the book value and the fair value of the land\n    # As the truck is exchanged for land, consider the fair value of the land as the sale price of the truck\n    loss = book_value_of_truck - current_fair_value_of_land\n    \n    # return answer\n    return loss\n\n# Call the solution function to print the result\nprint(solution())\n```\nKeep in mind that, in typical accounting practices, land is not depreciated, and thus its cost is not amortized over time. The original cost and the fair value would be used to determine gain or loss on the exchange. For the truck, depreciation is needed to determine its book value. The program above assumes that the original cost minus the accumulated depreciation gives us the book value to determine the loss on the exchange."
        ]
    },
    {
        "question_id": "validation-1",
        "question": "Given that the spot exchange rate from the \"Kiwi\" (NZD) to sterling (GBP) is 2.0979, the Libor interest rate for the sterling is 1.6025%, and for the \"Kiwi\" it's 3.2875%, all being quoted on a 360-day year basis, what are the 180-day forward points (with a precision of four decimal places) in NZD/GBP?",
        "tables": [],
        "python_solution": "def solution():\n    spot_rate = 2.0979\n    gbp_interest_rate = 1.6025/100\n    nzd_interest_rate = 3.2875/100\n    time_in_years = 180/360\n\n    gbp_investment = 1 * (1 + gbp_interest_rate * time_in_years)\n    nzd_investment = spot_rate * (1 + nzd_interest_rate * time_in_years)\n    \n    forward_rate = nzd_investment / gbp_investment\n    \n    forward_points = (forward_rate - spot_rate) * 10000\n\n    return int(forward_points)",
        "ground_truth": 175.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "Here's a Python program to answer the given question:\n\n```python\ndef solution():\n    # Define variables name and value\n    spot_rate_NZD_GBP = 2.0979\n    sterling_libor = 1.6025 / 100  # converting percentage to decimal\n    kiwi_libor = 3.2875 / 100      # converting percentage to decimal\n    days = 180\n    year_basis = 360\n\n    # Calculate the forward rate adjustment\n    forward_adjustment = spot_rate_NZD_GBP * ((1 + kiwi_libor * days / year_basis) / (1 + sterling_libor * days / year_basis) - 1)\n\n    # Calculate the forward points\n    forward_points = forward_adjustment / (days / year_basis)\n\n    # Return answer with a precision of four decimal places\n    return round(forward_points, 4)\n\n# Example usage:\n# forward_points = solution()\n# print(forward_points)\n```\n\nWhen executed, `solution()` will return the 180-day forward points with a precision of four decimal places."
        ]
    },
    {
        "question_id": "validation-2",
        "question": "The CME Foundation, which is based in the United States, has requested their Chief Investment Officer, Pauline Cortez, to conduct an analysis on the advantages of incorporating U.S real estate equities as a fixed asset class. As part of this process, Cortez must establish the relevant risk factor to use in the international capital asset pricing model (ICAPM) in order to appropriately determine the risk premium and expected return for this potential asset class. She will be using selected data provided by GloboStats as shown in Exhibit 1. Given the information in Exhibit 1 and under the assumption of perfect markets, what would be the calculated beta for U.S. real estate equities?",
        "tables": [
            "| Asset Class | Standard Deviation | Covariance with GIM | Integration with GIM | Sharpe Ratio |\n| ------------ | ------------------ | --------------------- | ------------------ | ------------- |\n| U.S. real estate | 14.0% | 0.0075 | 0.60 | n/a |\n| Global investable market | - | - | - | 0.36 |\n\nAdditional Information:  \n- Risk-free rate: 3.1%\n- Expected return for the GIM:  7.2%"
        ],
        "python_solution": "def solution():\n    cov = 0.0075\n    RPM = (7.2/100) - (3.1/100)\n    sigmaM = RPM / 0.36\n    varM = sigmaM ** 2\n    beta = cov / varM\n    return beta",
        "ground_truth": 0.578,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Given variables\n    covariance_with_GIM = 0.0075\n    standard_deviation_GIM = 0.36\n    integration_with_GIM = 0.6\n    \n    # Calculate beta using the formula beta = covariance(asset, market) / variance(market)\n    # Since standard deviation is the square root of variance, we square the standard deviation to get variance\n    variance_GIM = standard_deviation_GIM ** 2\n    beta_US_real_estate = covariance_with_GIM / variance_GIM\n    \n    # Return the calculated beta for U.S. real estate equities\n    return beta_US_real_estate\n\n# Call the function and print the result\nprint(f\"The calculated beta for U.S. real estate equities is: {solution()}\")\n```\n\nThis program defines a function `solution()` which calculates the beta for U.S. real estate equities using the covariance with the Global Investable Market (GIM) and the variance of the GIM derived from its standard deviation. It returns the calculated beta which is then printed outside the function."
        ]
    },
    {
        "question_id": "validation-3",
        "question": "Martinez took over a Spanish packaging firm. The Spanish venture involved Martinez purchasing 200,000 shares of a packaging firm at EUR90 per share. He resolved to fully secure the position with a six-month USD/EUR forward agreement. Given Exhibit 1, if the Spanish shares were sold after three months, what would have been the cash expenditure (in US dollars) necessary to terminate the forward agreement? (2019 mock PM)",
        "tables": [
            "| Maturity          | At Initiation    | Three Months  Later | At Maturity   |\n|-----------------  |----------------- |---------------------|---------------|\n| Spot (USD/EUR)    | 1.3935/1.3983    | 1.4106/1.4210       | 1.4189/1.4289 |\n| 3-month forward   | -8.1/-7.6        | -21.6/-21.0         |               |\n| 6-month forward   | -19.0/-18.3      |                     | -27.0/-26.2   |\n| USD Libor         | 1.266%           | 1.266%              | 1.266%        |\n| EUR Libor         | 1.814%           | 1.814%              | 1.814%        |"
        ],
        "python_solution": "def solution():\n    initial_position_eur = 200000 * 90\n    six_month_forward_rate = 1.3935 - 19 / 10000\n    three_month_forward_rate = 1.4210 - 21 / 10000\n    cash_outflow_at_settlement = initial_position_eur * (three_month_forward_rate - six_month_forward_rate)\n    dollar_libor_rate = 0.01266\n    cash_expenditure = cash_outflow_at_settlement / (1 + dollar_libor_rate * 90 / 360)\n    return int(cash_expenditure)",
        "ground_truth": 489849.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_spot_bid = 1.3935  # Bid rate at initiation\n    initial_spot_ask = 1.3983  # Ask rate at initiation\n    three_month_spot_ask = 1.4210  # Ask rate three months later\n    initial_six_month_forward_ask = -0.0183  # 6-month forward ask rate at initiation (expressed in decimals)\n    shares_purchased = 200000\n    share_price_eur = 90\n\n    # Calculate total cost of shares in EUR\n    total_cost_eur = shares_purchased * share_price_eur\n\n    # Initial forward price calculation (Ask price)\n    # Since ask price is used when buying a foreign currency, we use ask rates.\n    initial_forward_price = initial_spot_ask + initial_six_month_forward_ask\n\n    # Spot price after three months\n    spot_price_three_months = three_month_spot_ask\n\n    # Calculate the cost to close the forward contract after three months\n    # The forward contract position will have a market value based on the difference between\n    # the forward contract rate and the current spot rate after three months.\n    forward_value_change = spot_price_three_months - initial_forward_price\n\n    # Total amount in USD to close the position\n    # This will be determined by how much the EUR has appreciated or depreciated against the USD\n    # since according to a forward contract, Martinez would have agreed to exchange Euros for Dollars\n    # at the forward rate determined at transaction initiation.\n    # Since the position involves a purchase of Euros (receipt of Euros from the sale of shares),\n    # and the Euros have appreciated against the dollar (spot rate has increased),\n    # Martinez's forward contract is in a loss position and will cost him this loss to terminate.\n    cash_expenditure_usd = total_cost_eur * forward_value_change\n\n    # return answer\n    return cash_expenditure_usd\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThe function `solution` calculates the cash expenditure in US dollars necessary to terminate the forward agreement after three months, based on changes in the spot and forward rates. The output will be the amount required to settle the position given the appreciation of the Euro against the Dollar."
        ]
    },
    {
        "question_id": "validation-4",
        "question": "A financial risk assessor at a local financial institution is working out the yearly VaR of a collection of investment securities. The collection presently has a market worth of USD 3,700,000 with a daily fluctuation of 0.0004. Provided that there are 250 days of trading in a year and the daily returns on the collection are autonomous and adhere to the same usual distribution with a zero mean, what is the estimated 1-year VaR at the 95% assurance level?",
        "tables": [],
        "python_solution": "def solution():\n    worth = 3700000\n    volatility = 0.0004\n    days = 250\n    Z = 1.645\n    daily_std_dev = (volatility)**0.5\n    annual_VaR = worth * (days**0.5) * daily_std_dev * Z\n    return annual_VaR",
        "ground_truth": 1924720.298,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    market_value = 3700000\n    daily_volatility = 0.0004\n    trading_days = 250\n    confidence_level = 0.95\n    \n    # Calculate the annualized volatility\n    annual_volatility = daily_volatility * (trading_days**0.5)\n    \n    # Calculate the VaR at the 95% confidence level\n    # We use the .ppf (percent point function) of the normal distribution to find the z-score corresponding to our confidence level\n    z_score = norm.ppf(1 - confidence_level)\n    \n    # The VaR is then the market value times the z-score times the volatility\n    VaR = market_value * z_score * annual_volatility\n    \n    # Return the absolute value of the VaR as VaR is typically represented as a positive number\n    return abs(VaR)\n```"
        ]
    },
    {
        "question_id": "validation-5",
        "question": "For the organizations evaluated, it is projected that 40% will face bankruptcy within one year: P(failure) = 0.40. Meanwhile, 55% of these organizations are expected to succeed: P(success) = 0.55. There's an 85% likelihood that an organization will succeed if it stays afloat for a year: P(success | survival) = 0.85. Using the total probability rule, we can calculate the probability of an organization succeeding even if it eventually goes bankrupt. Thus, P(success | failure) is approximately: An examiner establishes a set of standards for analyzing troubled credits. Organizations that fail to achieve a passing score are categorized as probable to face bankruptcy within the upcoming year. The examiner arrives at the following conclusions:",
        "tables": [],
        "python_solution": "def solution():\n    non_survivor = 0.40\n    survivor = 1 - non_survivor\n    pass_test_for_survivor = 0.85\n    total_pass_test = 0.55\n\n    pass_test_for_non_survivor = (total_pass_test - pass_test_for_survivor * survivor) / non_survivor\n    return pass_test_for_non_survivor",
        "ground_truth": 0.1,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    P_failure = 0.40 # Probability of failure within one year\n    P_success = 0.55 # Probability of success overall\n    P_success_given_survival = 0.85 # Probability of success given survival for a year\n    \n    # By the total probability rule:\n    # P(success) = P(success | survival) * P(survival) + P(success | failure) * P(failure)\n    # We need to solve for P(success | failure)\n    \n    # First, find the probability of survival\n    P_survival = 1 - P_failure\n    \n    # Rearrange the total probability formula to solve for P(success | failure):\n    # P(success | failure) = (P(success) - P(success | survival) * P(survival)) / P(failure)\n    P_success_given_failure = (P_success - P_success_given_survival * P_survival) / P_failure\n    \n    # return answer\n    return P_success_given_failure\n\n# Call the function and print the result\nprint(f\"Probability of success given failure: {solution():.2f}\")\n```"
        ]
    },
    {
        "question_id": "validation-6",
        "question": "What is the three-firm Herfindahl-Hirschmann Index for the sector, given that a researcher collected the following market share data for a sector made up of five firms?",
        "tables": [
            "| Company | Market Share(%) |\n|---------|-----------------|\n| Zeta    | 35              |\n| Yusef   | 25              |\n| Xenon   | 20              |\n| Waters  | 10              |\n| Vlastos | 10              |"
        ],
        "python_solution": "def solution():\n    # three firms' market shares\n    firm1_share = 0.35\n    firm2_share = 0.25\n    firm3_share = 0.2\n    \n    # Herfindahl-Hirschmann Index\n    hhi = firm1_share**2 + firm2_share**2 + firm3_share**2\n    \n    return hhi",
        "ground_truth": 0.225,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    market_shares = [35, 25, 20]  # We only consider the top three firms for the three-firm HHI\n    \n    # Do math calculation to get the answer\n    # The Herfindahl-Hirschmann Index (HHI) is calculated by summing the squares of the market shares\n    # of the largest firms up to a specified number, which, in this case, is three.\n    hhi = sum([share ** 2 for share in market_shares])\n    \n    # return answer\n    return hhi\n    \n# You can call the function to get the result\nprint(solution())  # This print statement is just for testing purposes; you can remove it in the final implementation\n```"
        ]
    },
    {
        "question_id": "validation-7",
        "question": "A two-year fixed-for-floating Libor swap stands at 1.00% and the two-year US Treasury bond yield is currently 0.63%. What is the difference in rates, also known as the swap spread?",
        "tables": [],
        "python_solution": "def solution():\n    libor_swap = 1.00\n    us_treasury_bond_yield = 0.63\n    swap_spread = libor_swap - us_treasury_bond_yield\n    return swap_spread * 100  # Result in basis points",
        "ground_truth": 37.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is the Python program that calculates the swap spread based on the provided rates:\n\n```python\ndef solution():\n    # Define variables name and value\n    libor_swap_rate = 1.00  # in percent\n    treasury_bond_yield = 0.63  # in percent\n    \n    # Do math calculation to get the swap spread\n    swap_spread = libor_swap_rate - treasury_bond_yield\n    \n    # return answer\n    return swap_spread\n\n# Call the function and print the result if you want to output the result\n# print(f\"The swap spread is: {solution()}%\")\n```\n\nThe function `solution()` calculates the difference between the Libor swap rate and the US Treasury bond yield, which represents the swap spread, and then returns this value. You can uncomment the print statement at the bottom of the script if you wish to display the result of the calculation."
        ]
    },
    {
        "question_id": "validation-8",
        "question": "Using the straight-line method, what is the accumulated amortization cost at the end of 2016 for the relevant information about an intangible asset?",
        "tables": [
            "| Acquisition cost $ 600,000 | |\n|---|---|\n| Acquisition date 1 January 2013 | |\n| Expected residual value at time of acquisition $ 100,000 | |\n| The intangible asset is supposed to bring in profits for 5 years after acquisition. | |"
        ],
        "python_solution": "def solution():\n    original_cost = 600000\n    residual_value = 100000\n    useful_life = 5\n    years_passed = 4\n    accumulated_amortization = ((original_cost - residual_value) / useful_life) * years_passed\n    return accumulated_amortization",
        "ground_truth": 400000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    acquisition_cost = 600000\n    residual_value = 100000\n    useful_life = 5  # years\n    \n    # Do math calculation to get the answer\n    annual_amortization = (acquisition_cost - residual_value) / useful_life\n    accumulated_amortization = annual_amortization * 4  # at the end of 2016\n    \n    # return answer\n    return accumulated_amortization\n\n# Call the function and print the result if you want to check\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-9",
        "question": "Based on the regression function from 1972 to 2012, the average mean reversion was 77.5%. The correlation data over a prolonged period averages at 35%. In the case of the 30 by 30 NASDAQ correlation matrices, the correlation averaged at 27% in January 2014. Utilizing the basic s(t) - s(t-1) = alpha × [μ - s(t -1)] model, what is the correlated expectation for February 2014?",
        "tables": [],
        "python_solution": "def solution():\n    return 27.0 + 77.5 * (35.0 - 27.0) / 100",
        "ground_truth": 33.2,
        "topic": "Risk Management",
        "output": [
            "To calculate the correlated expectation for February 2014, we will use the given mean reversion model where `s(t)` represents the expected correlation for February 2014, `s(t-1)` is the correlation from January 2014, `alpha` is the mean reversion coefficient, and `μ` is the long-term average correlation.\n\nThe mean-reversion equation can be written as: \n```\ns(t) = alpha * (μ - s(t-1)) + s(t-1)\n```\n\nLet's define `alpha` as 0.775 (or 77.5% mean reversion), `μ` as 0.35 (or 35%), and `s(t-1)` as 0.27 (27% from January 2014) and solve for `s(t)` to get the expected correlation for February 2014.\n\n```python\ndef solution():\n    # Define variables name and value\n    alpha = 0.775  # mean reversion\n    mu = 0.35  # long-term average correlation\n    s_t_minus_1 = 0.27  # correlation for January 2014\n    \n    # Do math calculation to get the answer\n    s_t = alpha * (mu - s_t_minus_1) + s_t_minus_1\n    \n    # return answer\n    return s_t\n    \n# Call the function and print the result\nprint(solution())\n```\n\nNow, we will remove the print statement as the expected answer should only return the result.\n\n```python\ndef solution():\n    # Define variables name and value\n    alpha = 0.775  # mean reversion\n    mu = 0.35  # long-term average correlation\n    s_t_minus_1 = 0.27  # correlation for January 2014\n    \n    # Do math calculation to get the answer\n    s_t = alpha * (mu - s_t_minus_1) + s_t_minus_1\n    \n    # return answer\n    return s_t\n```\nThis function should return the correlated expectation for February 2014 when executed."
        ]
    },
    {
        "question_id": "validation-10",
        "question": "Superior Inc. anticipates paying dividends of $0.5 per share for the upcoming two years. Dividends are predicted to increase at a 6% growth rate after that. Given a 10% rate of return, what is the worth of Superior's common equity?",
        "tables": [],
        "python_solution": "def solution():\n    D01=D02=0.5 \n    P02=0.5*(1.06)/(0.1-0.06)\n    V= (0.5)/1.1+(0.5+P02)/(1.1**2)\n    return V",
        "ground_truth": 11.818,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly, here is a Python program that calculates the worth of Superior's common equity based on the given information using the dividend discount model (DDM) for a multi-stage dividend growth.\n\n```python\ndef solution():\n    # Define variables name and value\n    dividend_0 = 0.5  # Dividend for the first two years\n    growth_rate_1 = 0.06  # Growth rate after two years\n    required_rate_of_return = 0.10  # Rate of return\n\n    # Calculate the present value of dividends for the first two years\n    dividend_year_1 = dividend_0\n    dividend_year_2 = dividend_0\n\n    pv_dividend_year_1 = dividend_year_1 / (1 + required_rate_of_return)**1\n    pv_dividend_year_2 = dividend_year_2 / (1 + required_rate_of_return)**2\n\n    # Calculate the terminal value at the end of year 2 using the Gordon growth model\n    # since the dividends are expected to grow at 6% after year 2\n    terminal_dividend = dividend_year_2 * (1 + growth_rate_1)\n    terminal_value = terminal_dividend / (required_rate_of_return - growth_rate_1)\n    \n    # Calculate the present value of the terminal value\n    pv_terminal_value = terminal_value / (1 + required_rate_of_return)**2\n\n    # The worth of Superior's common equity is the sum of the present values\n    equity_worth = pv_dividend_year_1 + pv_dividend_year_2 + pv_terminal_value\n    \n    return equity_worth\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program will return the value of Superior's common equity based on the dividend discount model for a growing dividend."
        ]
    },
    {
        "question_id": "validation-11",
        "question": "As a dominant entity in the industry, Yahoo Corp. recently conducted a market analysis and discovered that the price elasticity of demand is 1.8. If the marginal cost is $30 and the average cost is $50, what is the most probable price?",
        "tables": [],
        "python_solution": "def solution():\n    E = 1.8\n    MC = 30\n    price = MC / (1 - (1 / E))\n    return price",
        "ground_truth": 67.5,
        "topic": "Market Analysis & Economics",
        "output": [
            "Certainly! Based on the concept of price elasticity of demand and the relationship with marginal cost for profit maximization in a monopolistic situation (which is likely given the phrase \"dominant entity in the industry\"), the most probable price can be determined. \n\nIn general economics, a monopolist will maximize profits by producing at a level where marginal cost equals marginal revenue, and the price elasticity of demand (PED) relates the marginal revenue (MR) to the price (P) and the marginal cost (MC) by the formula:\n\nMR = P * (1 - (1 / PED))\n\nTo find the price (P), we rearrange the equation to solve for P given MR = MC:\n\nP = MC / (1 - (1 / PED))\n\nThe program to calculate the price is as follows:\n\n```python\ndef solution():\n    # Define variables name and value\n    price_elasticity_of_demand = 1.8  # PED\n    marginal_cost = 30  # MC\n    \n    # Do math calculation to get the answer\n    # Calculating the most probable price based on Marginal Cost and Price Elasticity of Demand\n    price = marginal_cost / (1 - (1 / price_elasticity_of_demand))\n    \n    # return answer\n    return price\n```\n\nNow, let's write the full function with the calculation and return the most probable price."
        ]
    },
    {
        "question_id": "validation-12",
        "question": "What is the annual economic profit for Chace's House Industry based on the collected data?",
        "tables": [
            "| Total revenue | $460,000 |\n|---------------|----------|\n| Value of buildings and machinery |  |\n| - At the beginning of the year | $320,000 |\n| - At the end of the year | $270,000 |\n| Cost of raw materials | $80,000 |\n| Wages paid during the year | $30,000 |\n| Normal profit for the year | $50,000 |"
        ],
        "python_solution": "def solution():\n    opportunity_costs = 80000 + 30000 + 50000\n    economic_depreciation = 320000 - 270000\n    total_revenue = 460000\n    economic_profit = total_revenue - opportunity_costs - economic_depreciation\n    return economic_profit",
        "ground_truth": 250000.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    total_revenue = 460000\n    beginning_value_buildings_machinery = 320000\n    end_value_buildings_machinery = 270000\n    cost_of_raw_materials = 80000\n    wages_paid = 30000\n    normal_profit = 50000\n\n    # Calculate the average value of buildings and machinery\n    avg_value_buildings_machinery = (beginning_value_buildings_machinery + end_value_buildings_machinery) / 2\n\n    # Calculate the implicit costs which is the reduction in value of buildings and machinery\n    implicit_costs = beginning_value_buildings_machinery - end_value_buildings_machinery\n\n    # Calculate explicit costs which is the sum of raw materials and wages\n    explicit_costs = cost_of_raw_materials + wages_paid\n\n    # Calculate total costs (explicit costs + implicit costs + normal profit)\n    total_costs = explicit_costs + implicit_costs + normal_profit\n\n    # Calculate the annual economic profit (total revenue - total costs)\n    annual_economic_profit = total_revenue - total_costs\n    \n    # return answer\n    return annual_economic_profit\n```"
        ]
    },
    {
        "question_id": "validation-13",
        "question": "According to Exhibits 1 and 2, what is the FCFF ($ millions) of the Johnson Company for the fiscal year ending on December 31, 2012?",
        "tables": [
            "| For Year Ending 31 December | 2012 |\n| --------------------------- | ---- |\n| Revenues                   | $6,456 |\n| Earnings before interest,taxes, depreciation, and amortization (EBITDA) | 1,349 |\n| Depreciation expense | 243 |\n| Operating income     | 1,106 |\n| Interest expense     | 186 |\n| Pretax income        | 920 |\n| Income tax (32%)     | 294 |\n| Net income           | $626 |\n|                           |      |\n| Number of outstanding shares (millions) | 411 |\n| 2012 earnings per share     | $1.52 |\n| 2012 dividends paid (millions) | 148 |\n| 2012 dividends per share    | 0.36 |\n| 2012 fixed capital investment (millions) | 535 |\n|                           |      |\n| Cost of equity           | 12.0% |\n| Weighted average cost of capital (WACC) | 9.0% |",
            "| Assets                      | 2012  | 2011  |\n|-----------------------------|-------|-------|\n| Cash and cash equivalents   | $32   | $21   |\n| Accounts receivable         | 413   | 417   |\n| Inventories                 | 709   | 638   |\n| Other current assets        | 136   | 123   |\n| **Total current assets**    | $1,290| $1,199|\n|                             |       |       |\n| Current liabilities         | $2,783| $2,678|\n| Long-term debt              | 2,249 | 2,449 |\n| Common stockholders' equity | 1,072 | 594   |\n| **Total liabilities and stockholders' equity**| $6,104| $5,721|"
        ],
        "python_solution": "def solution():\n    NI = 626\n    NCC = 243\n    Int = 186\n    Tax_rate = 294/920 \n    FCInv = 535\n    WCInvNet = -25\n    FCFF = NI + NCC + Int*(1 - Tax_rate) - FCInv - WCInvNet\n    return FCFF",
        "ground_truth": 485.561,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the Free Cash Flow to the Firm (FCFF) for Johnson Company for the fiscal year ending on December 31, 2012, we will use the following formula:\n\nFCFF = EBIT(1-Tax Rate) + Depreciation Expense - Fixed Capital Investment - Change in Working Capital\n\nFrom the given table, we can deduce the following values:\n- Earnings before interest and taxes (EBIT) is given as Operating Income: $1,106 million\n- Tax Rate is 32%, which means that (1 - Tax Rate) = (1 - 0.32) = 0.68\n- Depreciation Expense is $243 million\n- Fixed Capital Investment for 2012 is $535 million\n- Change in Working Capital is the difference between the Total Current Assets of 2012 and 2011 and Total Current Liabilities of 2012 and 2011\n\nChange in Working Capital = (Total Current Assets 2012 - Total Current Assets 2011) - (Total Current Liabilities 2012 - Total Current Liabilities 2011)\n\nNow, let's proceed with creating the Python program to calculate FCFF:\n\n```python\ndef solution():\n    # Define variables name and value\n    operating_income = 1106  # $ millions\n    tax_rate = 0.32\n    depreciation_expense = 243  # $ millions\n    fixed_capital_investment = 535  # $ millions\n    total_current_assets_2012 = 1290  # $ millions\n    total_current_assets_2011 = 1199  # $ millions\n    total_current_liabilities_2012 = 2783  # $ millions\n    total_current_liabilities_2011 = 2678  # $ millions\n    \n    # Calculate change in working capital\n    change_in_working_capital = (total_current_assets_2012 - total_current_assets_2011) - (total_current_liabilities_2012 - total_current_liabilities_2011)\n    \n    # Calculate FCFF\n    fcff = (operating_income * (1 - tax_rate)) + depreciation_expense - fixed_capital_investment - change_in_working_capital\n    \n    # return answer\n    return fcff\n\n# Call the function and print the answer\nprint(solution())\n```\n\nThis program will calculate the FCFF for Johnson Company for 2012."
        ]
    },
    {
        "question_id": "validation-14",
        "question": "What is the impairment loss (in C$) for the printing equipment of a Canadian corporation that prepares its financial statements according to IFRS and has seen a decrease in product demand, as of 31 December 2010?",
        "tables": [
            "| | C$ |\n| --- | --- |\n| Carrying value of equipment (net book value) | 500,000 |\n| Undiscounted expected future cash flows | 550,000 |\n| Present value of expected future cash flows | 450,000 |\n| Fair Value | 480,000 |\n| Costs to sell | 50,000 |\n| Value in use | 440,000 |"
        ],
        "python_solution": "def solution():\n    fair_value = 480000\n    cost_to_sell = 50000\n    value_in_use = 440000\n    carrying_value = 500000\n\n    recoverable_amount = max(fair_value - cost_to_sell, value_in_use)\n    impairment_loss = carrying_value - recoverable_amount\n    return impairment_loss",
        "ground_truth": 60000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    carrying_value = 500000\n    recoverable_amount = min(450000, 480000 - 50000)  # The higher of fair value less costs to sell and value in use\n\n    # Calculate impairment loss\n    impairment_loss = carrying_value - recoverable_amount\n\n    # return answer\n    return impairment_loss\n\n# Example of running the function and printing the result\n# print(solution())  # Uncomment this line to print the result\n```"
        ]
    },
    {
        "question_id": "validation-15",
        "question": "The following information pertains to a bond, what will be the bond's price?",
        "tables": [
            "| Coupon rate            | 3%                   |\n|------------------------|---------------------|\n| Interest paid          | Semiannually        |\n| Mature time            | 3 years             |\n| Required rate of return| 5%                  |\n| Par value of the bond  | 100                 |"
        ],
        "python_solution": "def solution():\n\n    N = 2 * 3\n    I_Y = 5 / 2\n    PMT = 3 / 2\n    FV = 100\n\n    PV = 0\n\n    for i in range(1, N + 1):\n        PV += PMT / ((1 + I_Y/100) ** i)\n    PV += FV / ((1 + I_Y/100) ** N)\n\n    return PV",
        "ground_truth": 94.492,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! Since the coupon is paid semiannually, we need to calculate the Present Value of the Annuity (PVA) for the coupon payments and the Present Value (PV) of the lump-sum payment at maturity. The bond's price will be the sum of these two present values.\n\n```python\ndef solution():\n    # Given values\n    coupon_rate = 0.03\n    interest_payment = coupon_rate * 100 / 2  # Because interest is paid semiannually\n    maturity_time = 3\n    required_rate_of_return = 0.05\n    par_value = 100\n    semi_annual_periods = maturity_time * 2  # Convert years to semi-annual periods\n    semi_annual_yield = required_rate_of_return / 2  # Semi-annual required rate of return\n\n    # Present Value of the Annuity (PVA) for coupon payments\n    # Formula: PVA = C[(1 - (1 + r)^-n) / r]\n    # C = cash flow per period (interest payment)\n    # r = discount rate per period (semi_annual_yield)\n    # n = number of periods (semi_annual_periods)\n    pva = interest_payment * ((1 - (1 + semi_annual_yield)**(-semi_annual_periods)) / semi_annual_yield)\n\n    # Present Value (PV) of the lump-sum at maturity\n    # Formula: PV = F / (1 + r)^n\n    # F = future value (par_value)\n    pv = par_value / ((1 + semi_annual_yield)**semi_annual_periods)\n\n    # Bond's price is the sum of the PVA and PV\n    bond_price = pva + pv\n\n    # Return bond's price\n    return round(bond_price, 2)  # Assuming bond price should be rounded to two decimal places\n\n# Example usage:\n# print(solution())\n```\n\nBy calling the `solution()` function, it will perform the calculations and return the bond's price rounded to two decimal places."
        ]
    },
    {
        "question_id": "validation-16",
        "question": "In 2009, Shine Kids Ltd., which started its operations in October of that year, bought 10,000 units of a toy at a cost of ₤10 per unit in October. The toy was a hit in October. Expecting a surge in December sales, Shine purchased an additional 5,000 units in November at a cost of ₤11 per unit. During 2009, Shine sold 12,000 units at a rate of ₤15 per unit. What is Shine's cost of goods sold for 2009 using the first in, first out (FIFO) method?",
        "tables": [],
        "python_solution": "def solution():\n    October_units = 10000\n    November_units = 2000\n    October_unit_cost = 10\n    November_unit_cost = 11\n    cost_of_goods_sold = (October_units * October_unit_cost) + (November_units * November_unit_cost)\n    return cost_of_goods_sold",
        "ground_truth": 122000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_purchase_units = 10000\n    initial_purchase_cost_per_unit = 10\n    additional_purchase_units = 5000\n    additional_purchase_cost_per_unit = 11\n    sold_units = 12000\n\n    # Do math calculation to get the answer\n\n    # Calculate cost for units from the initial purchase\n    if sold_units <= initial_purchase_units:\n        # All sold units come from the initial purchase and the cost is simply units sold * cost per unit of initial purchase.\n        cost_of_goods_sold = sold_units * initial_purchase_cost_per_unit\n    else:\n        # Calculate cost for the sold units that come from the initial purchase.\n        cost_of_goods_sold_initial = initial_purchase_units * initial_purchase_cost_per_unit\n        # Remaining sold units must come from the additional purchase made in November.\n        remaining_units_sold = sold_units - initial_purchase_units\n        # Calculate cost for the sold units from the additional purchase.\n        cost_of_goods_sold_additional = remaining_units_sold * additional_purchase_cost_per_unit\n        # Total cost of goods sold is the sum of costs from the initial and additional purchases.\n        cost_of_goods_sold = cost_of_goods_sold_initial + cost_of_goods_sold_additional\n\n    # return answer\n    return cost_of_goods_sold\n\n# Call the function and print the result for verification.\nprint(solution())\n```\nThe above program when executed will return the cost of goods sold for Shine Kids Ltd. for the year 2009 using the FIFO method."
        ]
    },
    {
        "question_id": "validation-17",
        "question": "What is the anticipated portfolio return made by an investment company analyst named Maud, under two scenarios of portfolio returns in various economic conditions?",
        "tables": [
            "| Scenario              | Probability of scenario (%) | Portfolio return | Probability of return (%) |\n|-----------------------|-----------------------------|------------------|---------------------------|\n| good economic situation | 70                          | 20%             | 50                        |\n| good economic situation | 70                          | 10%             | 50                        |\n| bad economic situation  | 30                          | 5%              | 60                        |\n| bad economic situation  | 30                          | -10%            | 40                        |"
        ],
        "python_solution": "def solution():\n    good_economic_situation_return = 0.2*0.5 + 0.1*0.5\n    bad_economic_situation_return = 0.05*0.6 + -0.1*0.4\n    general_expected_return = 0.7*good_economic_situation_return + 0.3*bad_economic_situation_return\n    return general_expected_return",
        "ground_truth": 0.102,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # For good economic situation\n    probability_good_econ = 0.70\n    return_good_econ_high = 0.20\n    probability_good_econ_high = 0.50\n    return_good_econ_low = 0.10\n    probability_good_econ_low = 0.50\n    \n    # For bad economic situation\n    probability_bad_econ = 0.30\n    return_bad_econ_high = 0.05\n    probability_bad_econ_high = 0.60\n    return_bad_econ_low = -0.10\n    probability_bad_econ_low = 0.40\n    \n    # Do math calculation to get the answer\n    expected_return_good_econ = (return_good_econ_high * probability_good_econ_high + \n                                 return_good_econ_low * probability_good_econ_low) * probability_good_econ\n    \n    expected_return_bad_econ = (return_bad_econ_high * probability_bad_econ_high + \n                                return_bad_econ_low * probability_bad_econ_low) * probability_bad_econ\n    \n    total_expected_return = expected_return_good_econ + expected_return_bad_econ\n    \n    # Convert to percentage by multiplying by 100\n    total_expected_return_percent = total_expected_return * 100\n    \n    # return answer\n    return total_expected_return_percent\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-18",
        "question": "Suppose a US enterprise employs LIFO for its stock accounting. At the start of 2017, the balance sheet shows inventory at $200,000, with a LIFO reserve of $30,000. By the close of 2017, the inventory stands at $250,000, with a LIFO reserve of $40,000. With a tax rate of 30%, what would the inventory be at the end of 2017 after converting from LIFO to FIFO?",
        "tables": [],
        "python_solution": "def solution():\n    LIFO_inventory = 250000\n    LIFO_reserve = 40000\n    FIFO_inventory = LIFO_inventory + LIFO_reserve\n    return FIFO_inventory",
        "ground_truth": 290000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    end_inventory_lifo = 250000\n    end_lifo_reserve = 40000\n    tax_rate = 0.30\n    \n    # Calculate the FIFO inventory\n    fifo_inventory_before_tax = end_inventory_lifo + end_lifo_reserve\n    \n    # Adjust FIFO inventory for tax impact (LIFO reserve increase * tax rate)\n    tax_impact = (end_lifo_reserve - 30000) * tax_rate\n    fifo_inventory_after_tax = fifo_inventory_before_tax - tax_impact\n    \n    # return answer\n    return fifo_inventory_after_tax\n\n# Call the solution function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-19",
        "question": "What is the cost per 100 of par value for a zero-coupon bond with a maturity of 15 years, given a yearly market discount rate of 4.5% and assuming yearly compound interest?",
        "tables": [],
        "python_solution": "def solution():\n    r = 0.045\n    n = 15\n    fv = 100\n    pv = fv / ((1 + r) ** n)\n    return pv",
        "ground_truth": 51.672,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    par_value = 100\n    years_to_maturity = 15\n    market_discount_rate = 0.045\n    \n    # Do math calculation to get the answer\n    # The price of a zero-coupon bond is calculated using the formula: Price = Par Value / (1 + r)^n\n    price_per_100_of_par_value = par_value / ((1 + market_discount_rate) ** years_to_maturity)\n    \n    # return answer\n    return price_per_100_of_par_value\n    \n# You can call the function to see the result\n# print(solution())\n```\nThis Python function `solution()` calculates the cost per 100 of par value for a zero-coupon bond using the given market discount rate and compounding it yearly."
        ]
    },
    {
        "question_id": "validation-20",
        "question": "A company noted a gain on redemption of $100,000 with a carrying value of $950,000, and a face value of $1 million. Kindly compute the call price:",
        "tables": [],
        "python_solution": "def solution():\n    carrying_value = 950000\n    gain_on_redemption = 100000\n    call_price = carrying_value - gain_on_redemption\n    return call_price/10000.0",
        "ground_truth": 85.0,
        "topic": "Accounting",
        "output": [
            "Certainly! To compute the call price, we need to add the gain on redemption to the carrying value of the bonds.\n\nHere's a Python program to calculate the call price:\n\n```python\ndef solution():\n    # Define variables name and value\n    gain_on_redemption = 100000\n    carrying_value = 950000\n    \n    # Do math calculation to get the answer\n    call_price = gain_on_redemption + carrying_value\n    \n    # return answer\n    return call_price\n\n# You can call the function to get the result\nprint(solution())\n```\n\nExecuting this function will give you the call price of the bond."
        ]
    },
    {
        "question_id": "validation-21",
        "question": "Based on the provided document, we have three spot rate ratios between USD and other currencies. Which option is most precise for the spot EUR/GBP cross-rate?",
        "tables": [
            "| Ratio   | Spot rate |\n|---------|-----------|\n| USD/EUR | 1.3860    |\n| EUR/CAD | 0.6125    |\n| USD/GBP | 1.4208    |"
        ],
        "python_solution": "def solution():\n    USD_EUR = 1.3860\n    USD_GBP = 1.4208\n    EUR_GBP = (1 / USD_EUR) * USD_GBP\n    return EUR_GBP",
        "ground_truth": 1.025,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    usd_eur_rate = 1.3860\n    usd_gbp_rate = 1.4208\n    \n    # Do math calculation to get the answer\n    # To find EUR/GBP, we can divide the USD/GBP rate by the USD/EUR rate.\n    eur_gbp_rate = usd_gbp_rate / usd_eur_rate\n    \n    # return answer\n    return round(eur_gbp_rate, 4)  # rounding to match the precision of the given spot rates\n\n# You can now call the function to get the EUR/GBP cross-rate\neur_gbp_cross_rate = solution()\nprint(eur_gbp_cross_rate)\n```\n\nThis program will give you the most precise spot EUR/GBP cross-rate based on the given USD to EUR and USD to GBP spot rates. The rounding to four decimal places is consistent with the precision of the provided spot rates."
        ]
    },
    {
        "question_id": "validation-22",
        "question": "Based on Exhibit 1, what is the five-year spot rate for Steve, a bond trader at a financial institution? Keep in mind that par and spot rates are derived from annual-coupon sovereign bonds.",
        "tables": [
            "|Maturity   | Par Rate | Spot rate |\n|---|---|---|\n| One-Year  | 2.50%  | 2.50%  |\n| Two-Year  | 2.99%  | 3.00%  |\n| Three-Year  | 3.48%  | 3.50%  |\n| Four-Year  | 3.95%  | 4.00%  |\n| Five-Year  | 4.37%  |   |"
        ],
        "python_solution": "def solution():\n    # given spot rates and swap rate\n    spot_rates = [0.025, 0.03, 0.035, 0.04]\n    swap_rate = 0.0437\n\n    # calculate the sum of discounted swap rate payments \n    sum_discounted_payments = sum([swap_rate / ((1 + rate) ** i) for i, rate in enumerate(spot_rates, start=1)])\n\n    # calculate the 5-year spot rate solving the formula above for S5\n    S5 = ((1 + swap_rate) / (1 - sum_discounted_payments))**(1/5) - 1\n\n    # return S5 in percentage\n    return S5 * 100",
        "ground_truth": 4.453,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To find the five-year spot rate given the par rates and spot rates of the other maturities, you can use the bootstrapping method. The spot rates for the 1-year, 2-year, 3-year, and 4-year maturities are given, and they are equal to the par rates for those periods.\n\nHere is the formula for the bootstrapping method to calculate the spot rate for year \\( n \\):\n\n\\[\n(1+\\text{par rate}_n)^n = (1+\\text{spot rate}_1) \\times (1+\\text{spot rate}_2) \\times \\cdots \\times (1+\\text{spot rate}_{n-1}) \\times (1+\\text{spot rate}_n)\n\\]\n\nWe can rearrange the equation to solve for the 5-year spot rate:\n\n\\[\n(1+\\text{spot rate}_5)^5 = \\frac{(1+\\text{par rate}_5)^5}{(1+\\text{spot rate}_1) \\times (1+\\text{spot rate}_2) \\times (1+\\text{spot rate}_3) \\times (1+\\text{spot rate}_4)}\n\\]\n\nTherefore, the program to calculate the five-year spot rate would be:\n\n```python\ndef solution():\n    # Given par rates for each year, they are equivalent to spot rates for the first four years\n    spot_rates = {\n        1: 0.0250,  # 2.50%\n        2: 0.0300,  # 3.00%\n        3: 0.0350,  # 3.50%\n        4: 0.0400   # 4.00%\n    }\n    par_rate_5 = 0.0437  # 4.37%\n    \n    # Calculate the product of 1+spot_rates for the first four years\n    product_of_spots = 1\n    for year in range(1, 5):\n        product_of_spots *= (1 + spot_rates[year])\n    \n    # Calculate the five-year spot rate\n    # Rearrange the bootstrapping equation to solve for the five-year spot rate\n    spot_rate_5 = ((1 + par_rate_5)**5 / product_of_spots)**(1/5) - 1\n    \n    # return answer\n    return spot_rate_5\n\n# Example usage:\n# print(f\"The five-year spot rate is: {solution() * 100:.2f}%\")\n```\n\nRunning the `solution()` function will give you the five-year spot rate that Steve, the bond trader, is looking to find. The `print` statement is commented out, but it shows how you would call the function and format the output as a percentage to two decimal places."
        ]
    },
    {
        "question_id": "validation-23",
        "question": "A risk manager specializing in market risk is looking to determine the cost of a 2-year zero-coupon bond. The current 1-year interest rate is 8.0%. There's a chance of 50% that the 1-year interest rate will reach 10.0% after one year and an equal probability of its falling to 6.0% in the same period. Suppose the yearly risk premium for duration risk is 40 bps, and the bond faces a value of EUR 1,000. What should be the zero-coupon bond's valuation?",
        "tables": [],
        "python_solution": "def solution():\n    bond_face_value = 1000\n    risk_free_rate = 0.08\n    risk_premium = 0.004\n    up_interest_rate = 0.10\n    down_interest_rate = 0.06\n    probability_up = 0.5\n    probability_down = 0.5\n\n    up_price_date1 = bond_face_value / (1 + up_interest_rate + risk_premium)\n    down_price_date1 = bond_face_value / (1 + down_interest_rate + risk_premium)\n\n    expected_price_date1 = probability_up * up_price_date1 + probability_down * down_price_date1\n    zero_coupon_bond_price = expected_price_date1 / (1 + risk_free_rate + risk_premium)\n    \n    return zero_coupon_bond_price",
        "ground_truth": 851.313,
        "topic": "Risk Management",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    face_value = 1000  # The value of the bond at maturity\n    current_rate = 0.08  # Current 1-year interest rate\n    rate_up = 0.10  # 1-year interest rate after one year if it goes up\n    rate_down = 0.06  # 1-year interest rate after one year if it goes down\n    duration_risk_premium = 0.004  # Yearly risk premium for duration risk\n    probability_up = 0.5  # Probability that the rate goes up\n    probability_down = 0.5  # Probability that the rate goes down\n    \n    # Do math calculation to get the answer\n    # Calculate the present value of the bond in both scenarios after 1 year\n    pv_if_rate_up = face_value / (1 + rate_up)\n    pv_if_rate_down = face_value / (1 + rate_down)\n    \n    # Calculate expected present value after 1 year\n    expected_pv = (probability_up * pv_if_rate_up) + (probability_down * pv_if_rate_down)\n    \n    # Account for the risk premium\n    adjusted_rate = current_rate + duration_risk_premium\n\n    # Calculate the present value today\n    bond_value_today = expected_pv / (1 + adjusted_rate)\n    \n    # return answer\n    return bond_value_today\n\n# Call the function and print the result\nprint(f\"The zero-coupon bond's valuation is: EUR {solution():.2f}\")\n```\n\nThe program will return the zero-coupon bond's valuation using given probabilities for the interest rate, the current interest rate, and the additional duration risk premium. The result is rounded to two decimal places when printed."
        ]
    },
    {
        "question_id": "validation-24",
        "question": "Assuming that the variances of the underlying populations are equal, independent samples taken from normally distributed groups display the following features: The combined estimation of the common variance is 2,678.05. What is the suitable t-test statistic to verify the assumption that the average of the two populations are the same?",
        "tables": [
            "| Sample Size | Sample Mean | Sample Standard Deviation |\n|-------------|-------------|--------------------------|\n| A 25        | 200         | 45                       |\n| B 18        | 185         | 60                       |"
        ],
        "python_solution": "def solution():\n    return (200 - 185) / (2678.05 / 25 + 2678.05 / 18)**0.5",
        "ground_truth": 0.938,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom scipy.stats import t\n\ndef solution():\n    # Define variables based on given values\n    n1 = 25  # Sample size for group A\n    x_bar1 = 200  # Sample mean for group A\n    s1 = 45  # Sample standard deviation for group A\n    \n    n2 = 18  # Sample size for group B\n    x_bar2 = 185  # Sample mean for group B\n    s2 = 60  # Sample standard deviation for group B\n    \n    # Using the combined estimation of the common variance\n    sp_square = 2678.05  # The combined estimation of the common variance\n    \n    # Calculate the standard error of the difference between two sample means\n    standard_error = ((sp_square / n1) + (sp_square / n2)) ** 0.5\n    \n    # Compute the t-statistic for the independent samples t-test\n    t_statistic = (x_bar1 - x_bar2) / standard_error\n    \n    # Degrees of freedom using the formula for two samples with equal variances\n    df = n1 + n2 - 2\n    \n    # Calculate the critical value (optional, just for reference)\n    critical_value = t.ppf(1 - 0.025, df)  # two-tailed test with alpha = 0.05\n    \n    # Return the t_statistic\n    return t_statistic\n\n# You can call the function to test\n# print(solution())\n```\n\nThis program defines the sample sizes, means, and standard deviations based on the data given; calculates the standard error given the combined estimate of common variance; computes the t-statistic for an independent two-sample t-test assuming equal variances; and returns the computed t-statistic. The degrees of freedom (df) is also calculated based on the sample sizes. \nThe example also includes a commented out line to calculate the critical value for reference, but it is not necessary to answer the question."
        ]
    },
    {
        "question_id": "validation-25",
        "question": "The following data is gleaned from the financial statements of Sugarfall Corporation. How much cash did Sugarfall Corp. pay to its suppliers?",
        "tables": [
            "| Income Statement          | Balance Sheet Changes                         |     |\n|---------------------------|-----------------------------------------------|-----|\n| Revenue                   | $56,800  Decrease in accounts receivable $1,324 |     |\n| Cost of goods sold        | $27,264  Decrease in inventory               | 501 |\n| Other operating expense   | $562 Increase in prepaid expense             | 6   |\n| Depreciation expense      | $2,500 Increase in accounts payable          | 1,063 |"
        ],
        "python_solution": "def solution():\n    cost_of_goods_sold = 27264\n    decrease_in_inventory = 501\n    increase_in_accounts_payable = 1063\n    cash_paid_to_suppliers = cost_of_goods_sold - decrease_in_inventory - increase_in_accounts_payable\n    return cash_paid_to_suppliers",
        "ground_truth": 25700.0,
        "topic": "Accounting",
        "output": [
            "To calculate how much cash Sugarfall Corporation paid to suppliers, we need to analyze the changes in inventory, accounts payable, and the cost of goods sold. This can be estimated using the following formula:\n\nCash Paid to Suppliers = Cost of Goods Sold (COGS) + Decrease in Inventory - Increase in Accounts Payable.\n\nLet's put this into a Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    cost_of_goods_sold = 27264\n    decrease_in_inventory = 501\n    increase_in_accounts_payable = 1063\n    \n    # Do math calculation to get the answer\n    cash_paid_to_suppliers = cost_of_goods_sold + decrease_in_inventory - increase_in_accounts_payable\n    \n    # return answer\n    return cash_paid_to_suppliers\n\n# Output the result\nprint(solution())\n```\n\nThis program will calculate the amount of cash Sugarfall Corporation paid to its suppliers based on the provided income statement and balance sheet changes."
        ]
    },
    {
        "question_id": "validation-26",
        "question": "What is the compensation expense for 2011 resulting from the executive stock options provided by the firm in 2011? The firm gave its senior managers 20,000 options on its common stocks on January 1, 2011. The options have a lock-in period of 4 years and lapse after 5 years of being given. The option price on the day they were granted was $2.5 per option. The average option price for the whole year was $2.8 per option. The fair value of the company's stocks on the grant day, January 1, 2011, was $15 per share.",
        "tables": [],
        "python_solution": "def solution():\n    options = 20000\n    option_price = 2.5\n    vesting_period = 4\n\n    compensation_expense_2011 = options * option_price / vesting_period\n\n    return compensation_expense_2011",
        "ground_truth": 12500.0,
        "topic": "Accounting",
        "output": [
            "To calculate the compensation expense resulting from the executive stock options provided by the firm in 2011, we can apply an accounting method known as the fair value method. This method records compensation expense using the fair value of the option on the grant date which in this case is $15 per share. However, the expense is recognized over the service period, which is the lock-in period of 4 years.\n\nHere is the Python program:\n\n```python\ndef solution():\n    # Define variables\n    num_options = 20000\n    option_price = 2.5\n    fair_value_per_share = 15\n    lock_in_period = 4\n    \n    # Total fair value for all options granted\n    total_fair_value = num_options * fair_value_per_share\n    \n    # Total intrinsic value for all options granted (which might be used in some accounting standards, but we are focusing on fair value)\n    # total_intrinsic_value = num_options * (fair_value_per_share - option_price)\n    \n    # Since the compensation cost is recognized over the vesting period of 4 years, we divide the total fair value by 4\n    compensation_expense = total_fair_value / lock_in_period\n    \n    # return the compensation expense for 2011\n    return compensation_expense\n\n# Calling the function and printing the result\nprint(solution())\n```\n\nWhen you run this program, it will return the compensation expense for the year 2011 from the provided executive stock options."
        ]
    },
    {
        "question_id": "validation-27",
        "question": "If a security has a yearly adjusted period of 7.020 and an annual convexity of 65.180 and its return to maturity falls by 25 basis points, what is the anticipated percentage change in price?",
        "tables": [],
        "python_solution": "def solution():\n    ann_mod_dur = 7.020\n    ann_converxity = 65.180\n    delta_yield = -0.0025\n\n    price_change = (-ann_mod_dur * delta_yield) + (0.5 * ann_converxity * (delta_yield ** 2))\n    return price_change * 100  # convert to percentage",
        "ground_truth": 1.775,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    duration = 7.020\n    convexity = 65.180\n    change_in_yield = 0.25 / 100  # converting basis points to decimal\n    \n    # Duration and convexity formula to estimate the percentage change in bond price\n    # Percentage change in price ≈ -Duration * Change in Yield + 0.5 * Convexity * (Change in Yield)^2\n    price_change = (-duration * change_in_yield) + (0.5 * convexity * (change_in_yield ** 2))\n    \n    # Convert the price change to percentage\n    percent_price_change = price_change * 100\n    \n    # return answer\n    return percent_price_change\n\n# Call the function and print the result for testing\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-28",
        "question": "What is the intrinsic value of preferred stock when the non-exchangeable and non-refundable preferred shares launched by the U.S. life assurance group are 5.80 percent at a par value of $30? The identical issue has a return rate of 5 percent.",
        "tables": [],
        "python_solution": "def solution(): \n    # Expected annual dividend equals to 5.8% × $30\n    dividend = (5.8 / 100) * 30 \n\n    # Value of preferred stock is dividend / 0.05 \n    stock_value = dividend / 0.05 \n\n    return stock_value",
        "ground_truth": 34.8,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! The intrinsic value of preferred stock can be calculated by dividing the annual dividend payment by the required rate of return. The annual dividend payment is calculated by multiplying the dividend rate by the stock's par value. Here is a Python program to calculate the intrinsic value:\n\n```python\ndef solution():\n    # Define variables name and value\n    dividend_rate = 0.0580  # 5.80 percent\n    par_value = 30  # $30\n    required_return_rate = 0.05  # 5 percent\n    \n    # Calculate the annual dividend payment\n    annual_dividend = dividend_rate * par_value\n    \n    # Calculate intrinsic value by dividing the annual dividend by the required rate of return\n    intrinsic_value = annual_dividend / required_return_rate\n    \n    # return intrinsic value\n    return intrinsic_value\n\n# You can call the function and print the result if you want to test the program\n# print(solution())\n```\n\nThis function `solution` will compute and return the intrinsic value of the preferred stock based on the given parameters."
        ]
    },
    {
        "question_id": "validation-29",
        "question": "Assume that the initial value is 400 and the risk-free rate stands at 5%. The asset offers a continuous dividend of 3%. Determine the forward price for a forward contract of 6 months:",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    F0 = 400 * math.exp((0.05 - 0.03) * 0.5)\n    return F0",
        "ground_truth": 404.02,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    S0 = 400  # Initial value of the asset\n    r = 0.05  # Risk-free rate (5% expressed as a decimal)\n    q = 0.03  # Continuous dividend rate\n    T = 0.5   # Time to maturity in years (6 months)\n\n    # Calculate the forward price using the formula:\n    # F0 = S0 * e^((r - q) * T)\n    F0 = S0 * math.exp((r - q) * T)\n    \n    # return forward price\n    return F0\n\n# Call to the solution function and print the result to check\nforward_price = solution()\nprint(f\"The forward price for the forward contract of 6 months is: {forward_price:.2f}\")\n```"
        ]
    },
    {
        "question_id": "validation-30",
        "question": "In the last 36 months, the standard deviation for the monthly returns of an investment portfolio has been 4.9%. To evaluate an assertion that the investment strategy for this portfolio yields a standard deviation of monthly returns below 5.0%, what is the test statistic's value?",
        "tables": [],
        "python_solution": "def solution():\n    n = 36\n    s = 0.049\n    sigma = 0.05\n    chi_square_statistic = ((n - 1) * s**2) / sigma**2\n    return chi_square_statistic",
        "ground_truth": 33.614,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To solve for the test statistic, we can use the formula for the test statistic (Z) under the assumption that the sample standard deviation approximates the population standard deviation, which is common in hypothesis testing:\n\nZ = (sample standard deviation - hypothesized population standard deviation) / (population standard deviation / sqrt(n))\n\nGiven:\n- sample standard deviation = 4.9%\n- hypothesized population standard deviation = 5.0%\n- n (number of months) = 36\n\nWe will convert the standard deviation from percentage to decimal form for calculation purposes.\n\nHere is the Python program to calculate the test statistic:\n\n```python\nfrom math import sqrt\n\ndef solution():\n    # Define variables name and value\n    sample_std_dev = 4.9 / 100  # Converting percentage to decimal\n    hypothesized_std_dev = 5.0 / 100  # Converting percentage to decimal\n    n = 36  # Number of months\n\n    # Do math calculation to get the test statistic's value\n    test_statistic = (sample_std_dev - hypothesized_std_dev) / (hypothesized_std_dev / sqrt(n))\n    \n    # return test statistic\n    return test_statistic\n\n# Run the solution function and print the result\nprint(solution())\n```\n\nWhen this code is run, it will output the value of the test statistic, which can then be used to evaluate the investment strategy assertion based on a Z-distribution table or p-value comparison with a significance level."
        ]
    },
    {
        "question_id": "validation-31",
        "question": "Using the 2007 and 2008 financial reports for Holt Corporation, which are presented in Exhibits 1 and 2 and in line with US GAAP, what is Holt's 2008 FCFE (in millions) as Jake Thompson is preparing a presentation to analyze the valuation of this company and Emerald Corp's common stock using a FCFE model? Thompson also plans to do a value estimate for Emerald through a dividend discount model for potential recommendations to his firm.",
        "tables": [
            "|                                           |                    |  2008   |                   |  2007   |\n|-------------------------------------------|--------------------|---------|-------------------|---------|\n| **As of 31 December**                     |                    |         |                   |         |\n| **Assets**                                |                    |         |                   |         |\n| Current assets                            |                    |         |                   |         |\n| Cash and cash equivalents                 |                    |   $372  |                   |  $315   |\n| Accounts receivable                       |                    |   $770  |                   |  $711   |\n| Inventories                               |                    |   $846  |                   |  $780   |\n| Total current assets                      |                    |  $1,988 |                   |  $1,806 |\n| Gross fixed assets                        |   $4,275           |         |   $3,752          |         |\n| Less: Accumulated depreciation            |   $1,176           |  $3,099 |   $906            |  $2,846 |\n| **Total assets**                          |                    |  $5,087 |                   |  $4,652 |\n| **Liabilities and shareholders' equity**  |                    |         |                   |         |\n| Current liabilities                       |                    |         |                   |         |\n| Accounts payable                          |                    |  $476   |                   |  $443   |\n| Accrued taxes and expenses                |                    |  $149   |                   |  $114   |\n| Notes payable                             |                    |  $465   |                   |  $450   |\n| Total current liabilities                 |                    |  $1,090 |                   |  $1,007 |\n| Long-term debt                            |                    |  $1,575 |                   |  $1,515 |\n| Common stock                              |                    |  $525   |                   |  $525   |\n| Retained earnings                         |                    |  $1,897 |                   |  $1,605 |\n| **Total liabilities and shareholders' equity** |              |  $5,087 |                   |  $4,652 |",
            "|   |   |\n|---|---|\n| Total revenues | $3,323 |\n| Cost  of goods  sold | 1,287 |\n| Selling, general, and administrative expenses | 858 |\n| Earnings before interest, taxes, depreciation, and amortization (EBITDA) | 1,178 |\n| Depreciation expense | 270 |\n| Operating income | 908 |\n| Interest expense | 195 |\n| Pretax income | 713 |\n| Income tax (at 32 percent) | 228 |\n| Net income | $485 |"
        ],
        "python_solution": "def solution():\n    NI = 485\n    NCC = 270\n    FCInv = 4275 - 3752\n    WCInv = (770-711) + (846-780) - (476-443) - (149-114)\n    Net_borrowing = (465-450) + (1575-1515)\n    FCFE = NI + NCC - FCInv - WCInv + Net_borrowing\n    return FCFE",
        "ground_truth": 250.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate Holt's 2008 Free Cash Flow to Equity (FCFE), we need to use the following formula:\n\nFCFE = [ Net Income ] + [ Depreciation Expense ] - [ Capital Expenditure ] - [ ΔWorking Capital ] + [ Net Borrowing ]\n\nCapital Expenditure (CapEx) for 2008 can be estimated by the change in gross fixed assets:\n\nCapEx = Gross Fixed Assets (End of 2008) - Gross Fixed Assets (End of 2007)\n\nChange in Working Capital (ΔWorking Capital) is computed by:\n\nΔWorking Capital = Total Current Assets (End of 2008) - Total Current Liabilities (End of 2008) - [ Total Current Assets (End of 2007) - Total Current Liabilities (End of 2007) ]\n\nNet Borrowing can be estimated by the change in long-term debt:\n\nNet Borrowing = Long-term Debt (End of 2008) - Long-term Debt (End of 2007)\n\nLet's compute these values in our Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_income_2008 = 485\n    depreciation_expense_2008 = 270\n    \n    gross_fixed_assets_2007 = 3752\n    gross_fixed_assets_2008 = 4275\n    capital_expenditure_2008 = gross_fixed_assets_2008 - gross_fixed_assets_2007\n    \n    total_current_assets_2007 = 1806\n    total_current_liabilities_2007 = 1007\n    total_current_assets_2008 = 1988\n    total_current_liabilities_2008 = 1090\n    change_in_working_capital_2008 = (total_current_assets_2008 - total_current_liabilities_2008) - (total_current_assets_2007 - total_current_liabilities_2007)\n    \n    long_term_debt_2007 = 1515\n    long_term_debt_2008 = 1575\n    net_borrowing_2008 = long_term_debt_2008 - long_term_debt_2007\n    \n    # Do math calculation to get the answer\n    fcfe_2008 = (net_income_2008 + depreciation_expense_2008 - capital_expenditure_2008 - change_in_working_capital_2008 + net_borrowing_2008)\n    \n    # return answer\n    return fcfe_2008\n\n# Call and print the solution\nprint(solution())\n```\n\nLet's now calculate the FCFE with the given financial data."
        ]
    },
    {
        "question_id": "validation-32",
        "question": "Can you determine the sustainable growth rate, please?",
        "tables": [
            "| Items                        | Times |\n| ------------------------     | ----- |\n| net profit margin            | 20%   |\n| retention rate               | 60%   |\n| asset turnover               | 0.8   |\n| financial leverage multiplier| 1.5   |"
        ],
        "python_solution": "def solution():\n    ROE = 0.2 * 0.8 * 1.5\n    sustainable_growth_rate = 0.6 * ROE\n    return sustainable_growth_rate",
        "ground_truth": 0.144,
        "topic": "Accounting",
        "output": [
            "Certainly! The sustainable growth rate (SGR) can be calculated using the formula:\n\nSGR = Retention Rate * Return on Equity (ROE)\n\nWhere ROE is calculated by multiplying the Net Profit Margin, Asset Turnover, and Financial Leverage Multiplier:\n\nROE = Net Profit Margin * Asset Turnover * Financial Leverage Multiplier\n\nHere is the Python program to calculate SGR:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_profit_margin = 0.20  # 20%\n    retention_rate = 0.60  # 60%\n    asset_turnover = 0.8  # 0.8 times\n    financial_leverage_multiplier = 1.5  # 1.5 times\n\n    # Calculate Return on Equity (ROE)\n    ROE = net_profit_margin * asset_turnover * financial_leverage_multiplier\n\n    # Calculate Sustainable Growth Rate (SGR)\n    SGR = retention_rate * ROE\n\n    # Return answer\n    return SGR\n\n# call the solution function and print the result\nprint(solution())\n```\n\nWhen you run this program, it will print the answer for the sustainable growth rate given the provided data."
        ]
    },
    {
        "question_id": "validation-33",
        "question": "What is the immediate ZAR/HKD exchange rate given by a broker?",
        "tables": [
            "| Ratio | Spot rate |\n|-------|-----------|\n| CNY/HKD | 0.8422 |\n| CNY/ZAR | 0.9149 |\n| CNY/SEK | 1.0218 |"
        ],
        "python_solution": "def solution():\n    CNY_ZAR = 0.9149\n    CNY_HKD = 0.8422\n    ZAR_HKD = (1/CNY_ZAR) * CNY_HKD\n    return ZAR_HKD",
        "ground_truth": 0.921,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    CNY_HKD = 0.8422  # Spot rate for CNY/HKD\n    CNY_ZAR = 0.9149  # Spot rate for CNY/ZAR\n    \n    # Do math calculation to get the ZAR/HKD cross rate\n    ZAR_HKD = CNY_HKD / CNY_ZAR  # Divide one rate by the other to get the cross rate\n    \n    # return answer\n    return ZAR_HKD\n\n# Exemplary function call\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-34",
        "question": "What weight will be applied to a four-day-old return when forecasting the conditional variance using a RiskMetrics EWMA model with a decay factor λ = 0.95 on a daily basis?",
        "tables": [],
        "python_solution": "def solution():\n    decay_factor = 0.95\n    weight_of_last_day = (1 - decay_factor)\n    weight_four_days_ago = weight_of_last_day * pow(decay_factor, 3)\n    return weight_four_days_ago",
        "ground_truth": 0.043,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    lambda_factor = 0.95\n    day_age = 4\n    \n    # Do math calculation to get the answer\n    weight = lambda_factor ** day_age\n    \n    # return answer\n    return weight\n    \n# You can call the function to get the result\nprint(solution())\n```\n\nThis program calculates the weight that will be applied to a four-day-old return in an Exponentially Weighted Moving Average (EWMA) model used in financial risk management, specifically using the RiskMetrics approach with a decay factor λ = 0.95. The weight decreases geometrically with the age of the return."
        ]
    },
    {
        "question_id": "validation-35",
        "question": "After putting $180,000 in an investment today with an interest rate of 10% that compounds on a daily basis, what will the worth of the investment be after 2 years for a shareholder?",
        "tables": [],
        "python_solution": "def solution():\n    principal = 180000\n    rate = 10 / 100\n    time = 2\n    n = 365\n\n    amount = principal * (1 + rate / n) ** (n * time)\n    \n    return int(amount)",
        "ground_truth": 219846.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Importing the math package for exponentiation\nimport math\n\ndef solution():\n    # Define variables name and value\n    principal_amount = 180000\n    annual_interest_rate = 0.10  # 10% interest rate\n    compounded_daily = 365\n    total_years = 2\n    \n    # The formula for compound interest is A = P (1 + r/n)^(nt)\n    # Where:\n    # P is the principal amount\n    # r is the annual interest rate (decimal)\n    # n is the number of times that interest is compounded per year\n    # t is the number of years the money is invested for\n    # A is the amount of money accumulated after n years, including interest.\n    \n    # Do math calculation to get the answer\n    accumulated_value = principal_amount * (1 + annual_interest_rate/compounded_daily) ** (compounded_daily * total_years)\n    \n    # return answer\n    return accumulated_value\n    \n# Call the function and print output to verify the correct implementation\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-36",
        "question": "The inventory account of a company experienced the following transactions in June: Under the periodic FIFO inventory costing, what was the gross profit for June?",
        "tables": [
            "|   Date   |  Transaction |           Units           |    Unit cost    |\n|:--------:|:------------:|:-------------------------:|:---------------:|\n| June 1   |   Inventory  |          20 units @      |    $5.00/unit   |\n| June 12  |   Purchased  |          70 units @      |    $5.20/unit   |\n| June 16  |     Sold     |   50 units @ $6.00/unit  |                 |\n| June 26  |   Purchased  |   35 units @ $5.5/unit   |                 |\n| June 29  |     Sold     |   40 units @ $6.50/unit  |                 |"
        ],
        "python_solution": "def solution():\n    sales = (50 * 6) + (40 * 6.5)\n    COGS = (20 * 5) + (70 * 5.2)\n    gross_profit = sales - COGS\n    return gross_profit",
        "ground_truth": 96.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_inventory_units = 20\n    initial_inventory_cost = 5.00\n    purchased_inventory_1_units = 70\n    purchased_inventory_1_cost = 5.20\n    purchased_inventory_2_units = 35\n    purchased_inventory_2_cost = 5.50\n    sold_units_1 = 50\n    sold_units_1_price = 6.00\n    sold_units_2 = 40\n    sold_units_2_price = 6.50\n    \n    # Calculating Cost of Goods Sold (COGS) under FIFO\n    # First, sell units from initial inventory\n    if sold_units_1 <= initial_inventory_units:\n        cogs_1 = sold_units_1 * initial_inventory_cost\n        remaining_units = initial_inventory_units - sold_units_1\n    else:\n        cogs_1 = initial_inventory_units * initial_inventory_cost\n        remaining_units = sold_units_1 - initial_inventory_units\n    \n    # Then, sell remaining units from first purchase\n    if remaining_units > 0:\n        if remaining_units <= purchased_inventory_1_units:\n            cogs_1 += remaining_units * purchased_inventory_1_cost\n            remaining_units = 0\n        else:\n            cogs_1 += purchased_inventory_1_units * purchased_inventory_1_cost\n            remaining_units -= purchased_inventory_1_units\n    \n    # Sell the second batch of sold units from the remaining inventory\n    if remaining_units > 0:\n        cogs_2 = remaining_units * purchased_inventory_1_cost\n        remaining_units_2 = purchased_inventory_1_units - remaining_units\n    else:\n        cogs_2 = sold_units_2 * purchased_inventory_2_cost\n        remaining_units_2 = purchased_inventory_2_units - sold_units_2\n    \n    if remaining_units_2 < sold_units_2:\n        cogs_2 += (sold_units_2 - remaining_units_2) * purchased_inventory_2_cost\n    \n    # Calculate revenues\n    revenue_1 = sold_units_1 * sold_units_1_price\n    revenue_2 = sold_units_2 * sold_units_2_price\n    \n    # Calculate gross profit\n    gross_profit = (revenue_1 + revenue_2) - (cogs_1 + cogs_2)\n    \n    # return answer\n    return gross_profit\n\n# Call the solution function and print the result\nprint(f\"The gross profit for June is: ${solution():.2f}\")\n```"
        ]
    },
    {
        "question_id": "validation-37",
        "question": "A medium-sized American utilities firm requires a return rate of 10%. Johnson and his colleagues predict that, due to a recent reorganization, the firm probably won't distribute dividends for the following three years. However, they anticipate that ABC will start paying an annual dividend of US$1.72 for each share starting from the fourth year onwards. After this, the dividend is predicted to experience a perpetual growth of 4%, though the present price suggests a growth rate of 6% for the identical timeframe. If Johnson's team employs the dividend discount model, what would be the current inherent value of Company ABC stock?",
        "tables": [],
        "python_solution": "def solution():\n    D4 = 1.72\n    r = 0.10\n    g = 0.04\n    P3 = D4/(r-g)\n    V0 = P3 / ((1+r)**3)\n    return V0",
        "ground_truth": 21.538,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    required_return = 0.10  # Required rate of return, or discount rate\n    first_dividend = 1.72   # The starting dividend after three years\n    growth_rate = 0.04      # Growth rate of dividends\n    \n    # Calculating the Present Value of Dividends starting from year 4 onwards\n    # Dividend at year 4 / (required return rate - growth rate)\n    terminal_value = first_dividend / (required_return - growth_rate)\n    \n    # Discounting the terminal value back to present value (after 3 years)\n    # We divide by (1 + required_return) raised to the power of the number of years we are discounting\n    intrinsic_value = terminal_value / ((1 + required_return)**3)\n    \n    # return answer\n    return intrinsic_value\n\n# Calling the function and printing the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-38",
        "question": "Assuming a payout ratio of 50% and a growth rate of 10%, and a return rate of 15%, what is the leading price-to-earnings (P/E) ratio for Tiger Corporation?",
        "tables": [],
        "python_solution": "def solution():\n    divident_payout_ratio = 0.5\n    k = 0.15\n    g = 0.1\n    P_E = divident_payout_ratio / (k - g)\n    return P_E",
        "ground_truth": 10.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    payout_ratio = 0.50        # Payout Ratio\n    growth_rate = 0.10         # Growth Rate\n    required_rate_of_return = 0.15  # Required Rate of Return\n    \n    # Do math calculation to get the answer\n    # Gordon Growth Model: P/E = (D0 * (1 + g)) / (r - g)\n    # where D0 is the current dividends, g is the growth rate, and r is the required rate of return.\n    # Because payout ratio = Dividends / Earnings, we can substitute D0/E0 with the payout ratio,\n    # where E0 represents current earnings.\n    # Thus, for the leading P/E we consider the growth rate in dividends:\n    # P/E = (Payout Ratio * (1 + Growth Rate)) / (Required Rate of Return - Growth Rate)\n    \n    leading_pe_ratio = (payout_ratio * (1 + growth_rate)) / (required_rate_of_return - growth_rate)\n    \n    # return answer\n    return leading_pe_ratio\n```"
        ]
    },
    {
        "question_id": "validation-39",
        "question": "What is the present value (PV) of an investment that provides €300 yearly for five years, starting from this very moment, when discounted at an annual rate of 4%?",
        "tables": [],
        "python_solution": "def solution():\n    A = 300\n    r = 0.04\n    N = 5\n    PV = A*((1-(1/((1+r)**N)))/r)*(1+r)\n    return int(PV)",
        "ground_truth": 1388.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Import package if needed\nfrom math import pow\n\ndef solution():\n    # Define variables names and values\n    cash_flow_per_year = 300  # Yearly cash flow\n    rate = 0.04  # annual discount rate\n    years = 5  # number of years\n    present_value = 0  # initialize the present value\n    \n    # Calculate the present value for each yearly cash flow immediately (since it starts at the present moment)\n    for n in range(years):\n        present_value += cash_flow_per_year / pow(1 + rate, n)\n    \n    # return answer\n    return round(present_value, 2)  # round the PV to two decimal places\n\n# For checking the function, you can uncomment the following line:\n# print(solution())\n``` \n\nThis program will compute the present value of the given investment, taking into account that the first cash flow occurs immediately (at present, n = 0). \n\nPlease notice that this answer assumes that when it's mentioned that yearly cash flows starting \"from this very moment,\" it implies that the first cash flow is also to be discounted as per the given rate. If it's meant to be received immediately without discounting, then the calculation for the first payment won't include the `(1 + rate)^n` term."
        ]
    },
    {
        "question_id": "validation-40",
        "question": "A company recently noted a $15,000 loss from selling equipment used in its production process. If the initial price of the equipment was $100,000 and the accumulated depreciation at the time of sale was $60,000, what sum did the company gain from the sale?",
        "tables": [],
        "python_solution": "def solution():\n    loss = 15000\n    initial_price = 100000\n    accumulated_depreciation = 60000\n    carrying_value = initial_price - accumulated_depreciation\n    proceeds = carrying_value - loss\n    return proceeds",
        "ground_truth": 25000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_price = 100000\n    accumulated_depreciation = 60000\n    loss = 15000\n    \n    # Do math calculation to get the answer\n    sale_price = initial_price - accumulated_depreciation - loss\n    \n    # return answer\n    return sale_price\n\n# Uncomment the line below to print the solution\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-41",
        "question": "A business has total liabilities amounting to £35 million and total shareholders' equity of £55 million. What percentage do total liabilities constitute on a vertical common-size balance sheet?",
        "tables": [],
        "python_solution": "def solution():\n    total_liabilities = 35\n    total_equity = 55\n    total_assets = total_liabilities + total_equity\n\n    return (total_liabilities / total_assets) * 100",
        "ground_truth": 38.889,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    total_liabilities = 35e6\n    total_shareholders_equity = 55e6\n    \n    # Calculating the total assets (which in this case is the sum of liabilities and shareholders' equity)\n    total_assets = total_liabilities + total_shareholders_equity\n    \n    # Do math calculation to get the percentage of liabilities vs total assets\n    liabilities_percentage = (total_liabilities / total_assets) * 100\n    \n    # return answer\n    return liabilities_percentage\n\n# You can call the function to test its output\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-42",
        "question": "If the Smith company recently paid a dividend of $2, with a required rate of return of 14% per annum and an expected constant growth rate of 8% per year for the dividend, what would the inherent value be for Smith's shares?",
        "tables": [],
        "python_solution": "def solution():\n    D0 = 2\n    g = 0.08\n    r = 0.14\n    D1 = D0 * (1 + g)\n    P0 = D1 / (r - g)\n    return P0",
        "ground_truth": 36.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    dividend = 2\n    required_return = 0.14\n    growth_rate = 0.08\n    \n    # Do math calculation to get the answer\n    intrinsic_value = dividend / (required_return - growth_rate)\n    \n    # return answer\n    return intrinsic_value\n\n# Example usage:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-43",
        "question": "Taking into account the details for a conventional fixed-rate bond with no options where PV0 signifies the original bond price, PV+ denotes the bond's price when the yield to maturity is raised, PV_ indicates the new price of the bond when yield to maturity is reduced, ∆Curve shows the modification in the benchmark yield curve, and ∆Yield explains the alteration in the yield to maturity, what can you estimate as the bond's approximate convexity?",
        "tables": [
            "| PV0      | PV+      | PV_      | △Curve | △Yield |\n|----------|----------|----------|--------|--------|\n| 99.41172 | 99.32213 | 99.50132 | 3 bps  | 1bp    |"
        ],
        "python_solution": "def solution():\n    PV_minus = 99.50132\n    PV_plus = 99.32213\n    PV0 = 99.41172\n    delta_yield = 0.0001\n\n    ApproxConvexity = ((PV_minus + PV_plus) - 2 * PV0) / ((delta_yield) ** 2 * PV0)\n    \n    return ApproxConvexity",
        "ground_truth": 10.059,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! Below you can find the Python program that estimates the approximate convexity of the bond based on the given information.\n\n```python\ndef solution():\n    # Define variables name and values\n    PV0 = 99.41172    # Original bond price\n    PV_plus = 99.32213  # Bond price when yield is increased\n    PV_minus = 99.50132  # Bond price when yield is decreased\n    delta_curve = 0.03   # Change in the benchmark yield curve in percentage points (3 bps)\n    delta_yield = 0.01   # Change in yield to maturity in percentage points (1 bp)\n\n    # Calculate approximate convexity using the formula:\n    # Convexity ≈ [(PV- + PV+ - 2PV0) / (2 * PV0 * (ΔYield)²)]\n    \n    convexity = ((PV_minus + PV_plus - 2 * PV0) / \n                 (2 * PV0 * (delta_yield / 100) ** 2)) / (delta_curve / 100) ** 2\n\n    # return answer\n    return convexity\n\n# Call the solution function and print the result\nconvexity = solution()\nprint(convexity)\n```\n\nThe `solution()` function calculates the convexity by using the bond prices at different yields and the change in yield values. In financial mathematics, convexity measures the sensitivity of the duration of a bond to changes in interest rates, and it's a second derivative of the price of the bond with respect to interest rates, or a first derivative of the bond's duration. The formula used in the `solution()` function is an approximation of this measure.\n\nAfter defining the input values, the function uses the convexity approximation formula to calculate the convexity of the bond. The deltas given in basis points are converted to percentage points by dividing by 100. Finally, the convexity value is returned."
        ]
    },
    {
        "question_id": "validation-44",
        "question": "According to the given table, can you compute the value added from the choice of security?",
        "tables": [
            "|                | Portfolio return | Benchmark return | Portfolio weight | Benchmark weight |\n|----------------|------------------|------------------|------------------|------------------|\n| Domestic       | 25%              | 15%              | 50               | 35               |\n| Bond           | 9%               | 5%               | 30               | 35               |\n| International  | 15%              | 18%              | 20               | 30               |"
        ],
        "python_solution": "def solution():\n    Wp = 1 # Weight of the portfolio\n    Rp = 6.6 # Return of the portfolio\n    RB = 1 # Return of the benchmark\n\n    # Value added from the choice of security\n    security_selection = Wp*(Rp-RB)\n    \n    return security_selection",
        "ground_truth": 5.6,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "To find the value added from the choice of security, we can calculate the security selection return for each category and then sum them up. The security selection return is calculated by subtracting the benchmark return from the portfolio return for each asset category, and then multiplying by the benchmark weight.\n\nThe formula is: \\( \\text{Security Selection Return} = (\\text{Portfolio Return} - \\text{Benchmark Return}) \\times \\text{Benchmark Weight} \\)\n\nIn our case, we do not need to convert the portfolio weights from percentage to decimal since the benchmark weights are also given in percentage form. This means they will cancel out during the calculation of the value added across the portfolio.\n\nLet me implement this in the Python program:\n\n```python\ndef solution():\n    # Define variables in decimals\n    # The returns are in percentage but for calculation, they are considered in decimals.\n    # Weights are given in percentage, so they're divided by 100 to convert them into decimals.\n    returns = {\n        'Domestic': {'Portfolio_return': 0.25, 'Benchmark_return': 0.15, 'Benchmark_weight': 0.35},\n        'Bond': {'Portfolio_return': 0.09, 'Benchmark_return': 0.05, 'Benchmark_weight': 0.35},\n        'International': {'Portfolio_return': 0.15, 'Benchmark_return': 0.18, 'Benchmark_weight': 0.30},\n    }\n    \n    # Initialize the value added from the choice of security\n    value_added = 0\n    \n    # Calculate the value added from the choice of security\n    for category, values in returns.items():\n        security_selection_return = (values['Portfolio_return'] - values['Benchmark_return']) * values['Benchmark_weight']\n        value_added += security_selection_return\n\n    # Convert value added to percentage form\n    value_added_percent = value_added * 100\n    \n    # return answer\n    return value_added_percent\n\n# Call the function and print the result\nprint(solution())\n```\n\nJust run the above function, and the result it returns will be the value added from the choice of security in percentage terms."
        ]
    },
    {
        "question_id": "validation-45",
        "question": "A dealer has listed a three-month forward exchange rate in CAD/USD at 1.0123. This same dealer also provides a 6.8% quote for 3-month forward points as a percentage. What is the spot rate for CAD/USD?",
        "tables": [],
        "python_solution": "def solution():\n    forward_rate = 1.0123\n    forward_points_as_percentage = 0.068\n\n    spot_rate = forward_rate / (1 + forward_points_as_percentage)\n\n    return spot_rate",
        "ground_truth": 0.948,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define forward exchange rate and forward points percentage\n    forward_exchange_rate = 1.0123\n    forward_points_percentage = 6.8 / 100\n    \n    # The spot rate is calculated by dividing the forward rate by (1 + forward points percentage)\n    spot_rate = forward_exchange_rate / (1 + forward_points_percentage)\n    \n    # return the calculated spot rate\n    return spot_rate\n\n# Call the function and print the result for testing\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-46",
        "question": "According to Exhibit 1, what was the share price of Baldwin at the end of 2011?",
        "tables": [
            "|                                         | Year Ending | December 31 |\n|-----------------------------------------|-------------|-------------|\n|                                         | 2011        | 2010        |\n| Rental income                           | 339,009     | 296,777     |\n| Other property income                   | 6,112       | 4,033       |\n| Total income                            | 345,121     | 300,810     |\n| Property operating expenses             | 19,195      | 14,273      |\n| Property taxes                          | 3,610       | 3,327       |\n| Total property expenses                 | 22,805      | 17,600      |\n| Net operating income                    | 322,316     | 283,210     |\n| Other income (gains on sale of properties) | 2,162     | 1,003       |\n| General and administrative expenses     | 21,865      | 19,899      |\n| Depreciation and amortization           | 90,409      | 78,583      |\n| Net interest expenses                   | 70,017      | 56,404      |\n| Net income                              | 142,187     | 129,327     |\n| Weighted average shares outstanding     | 121,944     | 121,863     |\n| Earnings per share                      | 1.17        | 1.06        |\n| Dividend per share                      | 0.93        | 0.85        |\n| Price/FFO, based upon year-end stock price | 11.5x    | 12.7x       |"
        ],
        "python_solution": "def solution():\n    accounting_net_income = 142187\n    depreciation_charges = 90409\n    gains_on_sale = 2162\n    shares_outstanding = 121944\n    price_FFO = 11.5\n    FFO_per_share = (accounting_net_income + depreciation_charges - gains_on_sale) / shares_outstanding\n    share_price = FFO_per_share * price_FFO\n    return share_price",
        "ground_truth": 21.731,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    net_income_2011 = 142187\n    depreciation_amortization_2011 = 90409\n    gains_on_sale_of_properties_2011 = 2162\n    weighted_avg_shares_outstanding_2011 = 121944\n    price_ffo_multiple_2011 = 11.5\n\n    # Calculate Funds From Operations (FFO)\n    ffo_2011 = net_income_2011 + depreciation_amortization_2011 - gains_on_sale_of_properties_2011\n\n    # Calculate Funds From Operations (FFO) Per Share\n    ffo_per_share_2011 = ffo_2011 / weighted_avg_shares_outstanding_2011\n\n    # Calculate Share Price based on Price/FFO Multiple\n    share_price_2011 = ffo_per_share_2011 * price_ffo_multiple_2011\n\n    # return answer\n    return share_price_2011\n\n# Call the function and print the answer\nprint(\"The share price of Baldwin at the end of 2011 is: ${:.2f}\".format(solution()))\n```"
        ]
    },
    {
        "question_id": "validation-47",
        "question": "A researcher is studying a collection composed of 1,000 secondary quality loans and 600 top quality loans. From the secondary quality loans, 200 are delayed in their payments. From the top quality loans, 48 are delayed in their payments. If the researcher arbitrarily picks a loan from the collection and it is presently delayed in its payments, what are the odds that it is a secondary quality loan?",
        "tables": [],
        "python_solution": "def solution():\n    total_loans = 1000 + 600\n    total_late = 200 + 48\n    late_subprime = 200\n\n    probability_late = total_late / total_loans\n    probability_late_and_subprime = late_subprime / total_loans\n    probability_subprime_given_late = probability_late_and_subprime / probability_late\n\n    return probability_subprime_given_late",
        "ground_truth": 0.806,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Certainly! To solve this problem, we will use Bayes' theorem. The theorem describes the probability of an event, based on prior knowledge of conditions that might be related to the event. We will calculate the probability that the loan is of secondary quality given that it is presently delayed in its payments.\n\nHere's the Python program to calculate the odds:\n\n```python\ndef solution():\n    # Define variables name and value\n    secondary_loans = 1000\n    top_quality_loans = 600\n    total_loans = secondary_loans + top_quality_loans\n    \n    delayed_secondary = 200\n    delayed_top_quality = 48\n    total_delayed = delayed_secondary + delayed_top_quality\n    \n    # Calculate probability of picking a secondary quality loan given it's delayed\n    prob_secondary_given_delayed = (delayed_secondary / total_delayed) * (total_delayed / total_loans) / (secondary_loans / total_loans)\n    \n    # return answer\n    return prob_secondary_given_delayed\n\n# Uncomment to test the function\n# print(solution())\n```\n\nThe calculation within the function assumes that each loan has an equal chance of being picked. It calculates the probability that a loan is secondary quality given that it has been delayed using conditional probabilities."
        ]
    },
    {
        "question_id": "validation-48",
        "question": "A researcher is tasked with determining the VaR of a long position in a put option on the shares of Large Pharmaceuticals Corp. The shares are currently priced at USD 26.00, with a daily volatility rate of 1.5%, and the option is at-the-money with a delta of -0.5. What would be the 1-day 95% VaR of the option position, if calculated via the delta-normal method?",
        "tables": [],
        "python_solution": "def solution():\n    delta = -0.5\n    rate = 0.015\n    price = 26\n    U = 1.645\n    sd = abs(delta) * (rate * price)\n    VaR = sd * U\n    return VaR",
        "ground_truth": 0.321,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Below is the Python program using the delta-normal method to calculate the 1-day 95% VaR of the put option position:\n\n```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Given variables\n    stock_price = 26.00  # Current stock price in USD\n    daily_volatility = 0.015  # Daily volatility rate\n    option_delta = -0.5  # Delta of the at-the-money put option\n    \n    # To calculate the 1-day 95% VaR, we use the Z-score for 95% confidence level\n    z_score = norm.ppf(0.95)\n    \n    # Calculate the daily standard deviation (risk) of the stock\n    daily_std_dev = stock_price * daily_volatility\n\n    # Calculate the daily change of the option value using delta\n    daily_option_value_change = option_delta * daily_std_dev\n    \n    # Calculate the 1-day 95% VaR using the Z-score\n    var_95 = z_score * -daily_option_value_change  # The negative sign as delta for put options is negative \n\n    # round the result to 2 decimal places\n    return round(var_95, 2)\n\n# Calling the function and printing the result\nprint(solution())\n```\n\nThis program defines the variables with given values, then calculates the VaR using the delta-normal method, and finally, returns the rounded result. Note that we are assuming a normal distribution of returns for the calculation of VaR, which is a common assumption in the delta-normal method."
        ]
    },
    {
        "question_id": "validation-49",
        "question": "Assuming the cash flow from financing activities according to U.S. GAAP is:",
        "tables": [
            "| Net income                                      | $55,000 |\n|-------------------------------------------------|---------|\n| Depreciation                                    | $60,000 |\n| Taxes paid                                      | $25,000 |\n| Interest paid                                   | $5,000  |\n| Dividends paid                                  | $10,000 |\n| Cash received from sale of company building     | $40,000 |\n| Issuance of preferred stock                     | $45,000 |\n| Repurchase of common stock                      | $20,000 |\n| Purchase of machinery                           | $20,000 |\n| Issuance of bonds                               | $40,000 |\n| Debt retired through issuance of common stock   | $45,000 |\n| Paid off long-term bank borrowings              | $10,000 |\n| Profit on sale of building                      | $15,000 |"
        ],
        "python_solution": "def solution():\n    issuance_of_preferred_stock = 45000\n    issuance_of_bonds = 40000\n    principal_payments_on_bank_borrowings = 10000\n    repurchase_of_common_stock = 20000\n    dividends_paid = 10000\n\n    CFF = issuance_of_preferred_stock + issuance_of_bonds - principal_payments_on_bank_borrowings - repurchase_of_common_stock - dividends_paid\n\n    return CFF",
        "ground_truth": 45000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # For Financing Activities:\n    issuance_of_preferred_stock = 45000\n    repurchase_of_common_stock = -20000\n    issuance_of_bonds = 40000\n    debt_retired_with_common_stock = 0  # No impact on cash since it's a non-cash transaction\n    paid_off_long_term_borrowings = -10000\n    dividends_paid = -10000\n    \n    # Calculate cash flow from financing activities\n    cash_flow_from_financing_activities = (issuance_of_preferred_stock +\n                                           repurchase_of_common_stock +\n                                           issuance_of_bonds +\n                                           debt_retired_with_common_stock +\n                                           paid_off_long_term_borrowings +\n                                           dividends_paid)\n    \n    # return answer\n    return cash_flow_from_financing_activities\n    \n# Call the function and print the result\nprint(solution())\n```\n\nIn the provided code snippet, the solution function calculates the cash flow from financing activities, considering various transactions according to US GAAP. The transactions that impact cash flow are issuance of preferred stock, repurchase of common stock, issuance of bonds, and payment of long-term borrowings and dividends. The transaction of retiring debt with common stock does not impact cash flow as it is a non-cash transaction, and hence its effect is set to zero. The resulting cash flow from financing activities is returned and then printed."
        ]
    },
    {
        "question_id": "validation-50",
        "question": "What's the price of a bond with a face value of $1000, a coupon rate of 5%, and an annual-pay period of 3 years, assuming the spot rates are 3.6% for the first year, 3.7% for the second year, and 3.8% for the third year?",
        "tables": [],
        "python_solution": "def solution():\n    bond_value = 50 / 1.036 + 50 / (1.037 ** 2) + 1050 / (1.038 ** 3)\n    return bond_value",
        "ground_truth": 1033.61,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is a Python program that calculates the price of the given bond using the present value formula for bonds with different annual spot rates:\n\n```python\ndef solution():\n    # Given variables\n    face_value = 1000\n    coupon_rate = 0.05\n    years = 3\n    spot_rates = [0.036, 0.037, 0.038]\n    \n    # Initialize the bond price to zero\n    bond_price = 0\n    \n    # Calculate the present value of the coupon payments\n    for year in range(1, years + 1):\n        bond_price += (face_value * coupon_rate) / ((1 + spot_rates[year - 1]) ** year)\n    \n    # Add the present value of the face value\n    bond_price += face_value / ((1 + spot_rates[-1]) ** years)\n    \n    return bond_price\n\n# You can call the function and print the result or just call the function\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-51",
        "question": "XYZ NY, a home decor shopping enterprise, provides its employees with a defined benefit pension plan. The related data is as follows: The payment given out during the year is:",
        "tables": [
            "|                                      |        |\n|--------------------------------------|--------|\n| ABC LA retirement plan information 2018 |        |\n| Current service costs                | 470    |\n| Past service costs                   | 0      |\n| Employer contributions               | 1,200  |\n| Benefit obligation at beginning of year | 45,000 |\n| Benefit obligation at end of year      | 48,395 |\n| Plan assets at beginning of year       | 40,800 |\n| Plan assets at end of year             | 44,300 |\n| Actuarial loss                         | 350    |\n| Actual return on plan assets           | 3,100  |\n| Discount rate on plan liabilities      | 7.5%   |\n| Expected rate of return on plan assets | 8.2%   |"
        ],
        "python_solution": "def solution():\n    plan_assets_end = 44300\n    plan_assets_begin = 40800\n    employer_contributions = 1200\n    actual_return_assets = 3100\n    benefit_paid = plan_assets_end - (plan_assets_begin + employer_contributions + actual_return_assets)\n    return benefit_paid",
        "ground_truth": -800.0,
        "topic": "Accounting",
        "output": [
            "To solve for the pension payments given out during the year by XYZ NY, we have to use the provided information for ABC LA as a reference. It seems, however, that there is some information missing from the original question—specifically, the related data for XYZ NY. \n\nSince we don't have the actual data for XYZ NY, I will provide a program structure using the data for ABC LA, leaving placeholders for the actual XYZ NY data. Normally, the payments made during the year can be calculated as follows:\n\nPayments during the year = Benefit obligation at the end of the year - Benefit obligation at the beginning of the year + Actual return on plan assets - Employer contributions + Actuarial loss/(gain) - (Plan assets at the end of the year - Plan assets at the beginning of the year)\n\nI will provide a Python program template to calculate these payments using the formula above:\n\n```python\ndef solution():\n    # Define variables name and value for ABC LA, placeholders for XYZ NY\n    # Note: Replace these placeholders with XYZ NY's actual data\n    current_service_costs = 470\n    employer_contributions = 1_200 # Replace with XYZ NY data\n    benefit_obligation_beginning = 45_000 # Replace with XYZ NY data\n    benefit_obligation_end = 48_395 # Replace with XYZ NY data\n    plan_assets_beginning = 40_800 # Replace with XYZ NY data\n    plan_assets_end = 44_300 # Replace with XYZ NY data\n    actuarial_loss = 350 # Replace with XYZ NY data\n    actual_return_on_plan_assets = 3_100 # Replace with XYZ NY data\n    \n    # Calculate payments during the year for XYZ NY\n    payments_during_year = (benefit_obligation_end - benefit_obligation_beginning +\n                            actual_return_on_plan_assets - employer_contributions +\n                            actuarial_loss - (plan_assets_end - plan_assets_beginning))\n    \n    # return answer\n    return payments_during_year\n\n# Once the actual data for XYZ NY is inserted in place of the placeholders,\n# you can call the function like this:\n# payments = solution()\n# print(payments)\n```\n\nPlease replace the placeholders with the actual data for XYZ NY to get the payments given out during the year by the home decor shopping enterprise."
        ]
    },
    {
        "question_id": "validation-52",
        "question": "What is the percentage of return that is below $100,000 if an investment analyst detects that the market's fund returns are normally distributed with an average of $160,000 and a standard deviation of $30,000?",
        "tables": [],
        "python_solution": "def solution():\n    from scipy.stats import norm\n    mean = 160000\n    standard_deviation = 30000\n    z = (100000 - mean) / standard_deviation\n    # Return probability in percentage\n    return (1 - norm.cdf(-z))*100",
        "ground_truth": 2.275,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    average_return = 160000\n    std_dev = 30000\n    target_return = 100000\n\n    # Calculate the z-score for the target return\n    z_score = (target_return - average_return) / std_dev\n\n    # Calculate the percentage below the target return using the cumulative distribution function (CDF)\n    percentage_below_target = norm.cdf(z_score) * 100\n\n    # Return answer\n    return percentage_below_target\n\n# This line is just for the script to automatically output the result when run\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-53",
        "question": "What is the maximum leverage ratio linked with a position financed by a 65% minimum margin requirement, if the brokerage firm XYZ has set it?",
        "tables": [],
        "python_solution": "def solution():\n    equity = 65\n    position = 100\n    leverage_ratio = position/equity\n    return leverage_ratio",
        "ground_truth": 1.538,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    minimum_margin_requirement = 0.65  # 65% minimum margin requirement\n    \n    # Do math calculation to get the answer\n    # Leverage ratio is equal to 1 / minimum margin requirement\n    leverage_ratio = 1 / minimum_margin_requirement\n    \n    # return answer\n    return leverage_ratio\n\n# Output the maximum leverage ratio\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-54",
        "question": "During a high season for tourism, the need for bottled water can be depicted as: Qbw=30-2Pb (Qbw is the amount of bottled water; Pb is the price of bottled water). If bottled water costs 5, what will the price elasticity of demand be?",
        "tables": [],
        "python_solution": "def solution():\n    Q = 30 - 2*5\n    P = 5\n    elasticity = -2 * (P/Q)\n    return elasticity",
        "ground_truth": -0.5,
        "topic": "Market Analysis & Economics",
        "output": [
            "To calculate the price elasticity of demand, we will use the formula:\n\nPrice elasticity of demand (PED) = (% change in quantity demanded) / (% change in price)\n\nGiven the demand function Qbw = 30 - 2Pb, we need the derivative of Qbw with respect to Pb to calculate the rate of change of quantity with respect to price.\n\nThe derivative dQbw/dPb is -2.\n\nWe calculate the elasticity at Pb = 5.\n\nPED at a point is given by the formula:\n\nPED = (dQbw/dPb) * (Pb/Qbw)\n\nWe also need to calculate Qbw when Pb = 5 to get the actual quantity demanded.\n\nLet's write a Python program to calculate this:\n\n```python\ndef solution():\n    # Define variables name and value\n    Pb = 5  # Price of bottled water\n    dQbw_dPb = -2  # Derivative of Qbw with respect to Pb\n    \n    # Substitute Pb in the demand equation to find Qbw\n    Qbw = 30 - 2 * Pb\n    \n    # Calculate the price elasticity of demand using the formula:\n    PED = (dQbw_dPb) * (Pb / Qbw)\n    \n    # return the absolute value of PED, since elasticity is typically expressed as a positive number\n    return abs(PED)\n```\n\nThis Python function will return the absolute value of the price elasticity of demand for bottled water at the price of 5. The PED will be negative due to the inverse relationship between price and quantity demanded, but it is standard to discuss its magnitude."
        ]
    },
    {
        "question_id": "validation-55",
        "question": "A business plans to issue new ordinary shares with flotation costs of 5.0% per share. They anticipate a dividend of $0.32 the following year and foresee a dividend growth rate of 10% indefinitely. Assuming the shares are released at a price of $14.69, what is the firm's cost (%) of external equity?",
        "tables": [],
        "python_solution": "def solution():\n    D1 = 0.32\n    P0 = 14.69\n    f = 0.05\n    g = 0.1\n    cost_of_external_equity = ((D1/(P0*(1-f)))+g)*100\n    return cost_of_external_equity",
        "ground_truth": 12.293,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "Below is the Python program to calculate the firm's cost of external equity, considering the dividend payment, growth rate, and flotation costs per share:\n\n```python\ndef solution():\n    # Define variables name and value\n    flotation_cost_per_share = 0.05  # 5%\n    dividend_next_year = 0.32  # next year's dividend\n    dividend_growth_rate = 0.10  # growth rate\n    issue_price = 14.69  # price at which shares are issued\n    \n    # Calculate the price after flotation costs\n    net_issue_price = issue_price * (1 - flotation_cost_per_share)\n    \n    # Calculate the cost of external equity using the Gordon Growth Model\n    cost_of_external_equity = (dividend_next_year / net_issue_price) + dividend_growth_rate\n    \n    # Convert to percentage\n    cost_of_external_equity_percent = cost_of_external_equity * 100\n    \n    # Return answer\n    return cost_of_external_equity_percent\n\n# Call to the function and print the result\nprint(f\"The firm's cost of external equity is: {solution():.2f}%\")\n```\n\nWhen the `solution()` function is called, it will return the cost of external equity in percentage, formatted to two decimal places."
        ]
    },
    {
        "question_id": "validation-56",
        "question": "Robinson is considering adding a new ETF investment to the portfolio. He intends to hold the ETF for nine months. Excluding the effect of compounding, what is the anticipated overall holding period cost of the nine-month investment in the ETF, given that the ETF has these trading expenses and management charges: Annual management fee of 0.32%, Round-trip trading fees of 0.20%, and a Bid–offer spread of 0.10% on buy and sell, as Robinson requests Jones to calculate?",
        "tables": [],
        "python_solution": "def solution():\n    annual_management_fee = 0.32\n    round_trip_trading_fees = 0.20\n    bid_offer_spread = 0.10\n    holding_period = 9 / 12\n\n    total_expected_holding_period_cost = (holding_period * annual_management_fee) + round_trip_trading_fees + bid_offer_spread\n    return total_expected_holding_period_cost",
        "ground_truth": 0.54,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Management fee for nine months (9/12 of the annual fee)\n    annual_management_fee = 0.32 / 100\n    nine_month_management_fee = annual_management_fee * (9 / 12)\n    \n    # Round-trip trading fees (apply once, since it's for both buy and sell)\n    round_trip_trading_fees = 0.20 / 100\n    \n    # Bid-offer spread on buy and sell (twice, once for buy and once for sell)\n    bid_offer_spread = 0.10 / 100\n    total_bid_offer_spread = 2 * bid_offer_spread\n    \n    # Total costs\n    total_costs = nine_month_management_fee + round_trip_trading_fees + total_bid_offer_spread\n    \n    # return the total anticipated cost\n    return total_costs\n\n# We could call the function and print the result to verify the correctness\n# print(solution())\n```\n\nThe `solution` function calculates the anticipated overall holding period cost of a nine-month investment in an ETF, factoring in the management fee pro-rated for nine months, the round-trip trading fees, and the bid-offer spread on both buy and sell transactions. The resulting value represents the percentage cost of holding the ETF for that period."
        ]
    },
    {
        "question_id": "validation-57",
        "question": "An investment firm implements a \"2 and 20\" fee arrangement, the current value of assets is $515, the management fee is determined by the value of assets at end of the year, a 5% hurdle rate is established prior to the collection of the incentive fee, and the present high-water mark is $540. After a period of one year, the value of the investment firm is $602.5. What is the investor's net return?",
        "tables": [],
        "python_solution": "def solution():\n    AUM_end_of_year = 602.5\n    high_water_mark = 540\n    management_fee_rate = 0.02\n    previous_assets_value = 515\n    incentive_fee_rate = 0.2\n    hurdle_rate = 0.05\n    \n    management_fee = AUM_end_of_year * management_fee_rate\n    incentive_fee = (AUM_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n    total_fee = management_fee + incentive_fee\n    net_return = (AUM_end_of_year - total_fee) / previous_assets_value - 1\n    return net_return * 100  # it's usually more intuitive to express return rate in percentage.",
        "ground_truth": 13.272,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_value_assets = 540\n    end_value_assets = 602.5\n    management_fee_rate = 0.02  # 2% for management fee\n    incentive_fee_rate = 0.20   # 20% for incentive fee\n    hurdle_rate = 0.05          # 5% hurdle rate\n\n    # Calculate the management fee\n    management_fee = end_value_assets * management_fee_rate\n\n    # Calculate incentive fee only if returns exceed the hurdle rate and the high-water mark\n    if end_value_assets > initial_value_assets*(1+hurdle_rate):\n        excess_return = end_value_assets - initial_value_assets*(1+hurdle_rate)\n        incentive_fee = excess_return * incentive_fee_rate\n    else:\n        incentive_fee = 0\n    \n    # Calculate investor's net return\n    net_return = end_value_assets - initial_value_assets - management_fee - incentive_fee\n\n    # Return the investor's net return\n    return net_return\n\n# Call the solution function\nprint(solution())\n```\n\nThis Python program calculates the investor's net return after considering management fees, incentive fees, the high-water mark, and the hurdle rate."
        ]
    },
    {
        "question_id": "validation-58",
        "question": "Assuming the application of U.S. GAAP unless specified differently, an analyst collected data from a corporation as follows: The bonds were released at par value and are convertible into 300,000 ordinary shares. All securities have been in circulation for the complete year. What is the diluted earnings per share for this corporation?",
        "tables": [
            "| Shares of common stock | 1,000,000 |\n|:----------------------:|:---------:|\n| Net income for the year | $1,500,000 |\n| Par value of convertible bonds with a 4% coupon rate | $10,000,000 |\n| Par value of cumulative preferred stock with a 7% dividend rate | $2,000,000 |\n| Tax rate | 30% |"
        ],
        "python_solution": "def solution():\n    # given data\n    net_income = 1500000\n    preferred_stock_dividends = 140000\n    outstanding_shares = 1000000\n    bond_interest = 400000\n    bond_conversion_shares = 300000\n\n    # calculate amount available for common shareholders\n    amount_for_common_shareholders = net_income - preferred_stock_dividends\n\n    # calculate the interest add back to net income\n    add_back_to_income = bond_interest * 0.7  # tax rate is 30%, hence considering 70%\n\n    # calculate diluted earnings\n    diluted_earnings = amount_for_common_shareholders + add_back_to_income\n\n    # calculate diluted EPS\n    diluted_eps = diluted_earnings / (outstanding_shares + bond_conversion_shares)\n\n    return diluted_eps",
        "ground_truth": 1.262,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    net_income = 1500000\n    common_shares_outstanding = 1000000\n    par_value_bonds = 10000000\n    coupon_rate = 0.04\n    convertible_to_shares = 300000\n    par_value_preferred_stock = 2000000\n    dividend_rate_preferred = 0.07\n    tax_rate = 0.30\n\n    # Calculate the interest on convertible bonds (net of tax)\n    interest_expense_bonds = par_value_bonds * coupon_rate\n    tax_savings = interest_expense_bonds * tax_rate\n    net_interest_expense = interest_expense_bonds - tax_savings\n    \n    # Calculate diluted income available to common stockholders\n    income_available_to_common = net_income - (par_value_preferred_stock * dividend_rate_preferred)\n    diluted_income = income_available_to_common + net_interest_expense\n    \n    # Calculate diluted EPS\n    diluted_shares = common_shares_outstanding + convertible_to_shares\n    diluted_eps = diluted_income / diluted_shares\n    \n    # return answer\n    return round(diluted_eps, 2)  # rounding to 2 decimal places for currency format\n\n# Call the solution function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-59",
        "question": "A year-long investment of 10,000 ordinary stocks from a corporation yielded a return of 15.5%. Just before selling the stocks at $24 each, the investor obtained a dividend of $2,500. What was the cost per stock that the investor initially paid a year ago?",
        "tables": [],
        "python_solution": "def solution():\n    initial_investment = 10000\n    return_rate = 15.5/100\n    stock_price_per_share = 24\n    dividend = 2500\n    \n    total_investment = initial_investment * (1 + return_rate)\n\n    total_earnings = (stock_price_per_share * initial_investment) + dividend\n\n    initial_price_per_share = total_earnings / total_investment\n    \n    return initial_price_per_share",
        "ground_truth": 20.996,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "To calculate the initial cost per stock that the investor paid a year ago, we need to consider the total initial investment, the dividend received, and the final selling price of the stocks along with the total return.\n\nHere's the Python program that carries out this calculation:\n\n```python\ndef solution():\n    # Given variables\n    total_return = 0.155  # 15.5% total return\n    dividend = 2500  # Dividend received\n    final_stock_price = 24  # Selling price per stock\n    number_of_stocks = 10000  # Number of stocks\n    total_return_in_dollars = total_return * final_stock_price * number_of_stocks\n    \n    # Calculation of the initial investment\n    initial_investment = (final_stock_price * number_of_stocks) + dividend - total_return_in_dollars\n    \n    # Calculating the cost per stock\n    cost_per_stock = initial_investment / number_of_stocks\n    \n    # Return the cost per stock\n    return cost_per_stock\n\n# The function can be called using solution()\n```\n\nThe `solution()` function can then be used to calculate the cost per stock that the investor initially paid."
        ]
    },
    {
        "question_id": "validation-60",
        "question": "Smith demonstrates to Harmonica the total return of a recent transaction performed by the Zenith Fund. Smith explains that the Zenith Fund entered a fully collateralized long position in nearby soybean futures contracts at the quoted futures price of 865.0 (US cents/bushel). Three months afterward, the whole futures position was rolled when the short-term futures price was 877.0 and the long-term futures price was 883.0. What is the Zenith Fund’s three-month total return on the soybean futures transaction, factoring in that the collateral earned an annualized rate of 0.60% during the three-month period between when the initial long position was established and the rolling of the contract?",
        "tables": [],
        "python_solution": "def solution():\n    previous_price = 865.0\n    current_price_short_term = 877.0\n    current_price_long_term = 883.0\n    collateral_rate = 0.60\n    months = 3\n    \n    # Calculating each return\n    price_return = (current_price_short_term - previous_price) / previous_price\n    roll_return = (current_price_short_term - current_price_long_term) / current_price_short_term\n    collateral_return = (months/12) * (collateral_rate/100)\n    \n    # Calculating total return\n    total_return = price_return + roll_return + collateral_return\n    \n    return total_return * 100",
        "ground_truth": 0.853,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_price = 865.0\n    short_term_price = 877.0\n    collateral_yield_annualized = 0.60 / 100  # converting percentage to decimal\n    number_of_months = 3\n    days_in_year = 365\n    \n    # Calculate the price return\n    price_return = (short_term_price - initial_price) / initial_price\n    \n    # Calculate the collateral return for the 3-month period\n    collateral_return = ((1 + collateral_yield_annualized) ** (number_of_months / (days_in_year / 12))) - 1\n    \n    # Calculate total return by adding price return and collateral return\n    total_return = price_return + collateral_return\n    \n    # return answer in percentage\n    return total_return * 100\n    \n# Call the function and print the result\nprint(f\"Total return: {solution():.2f}%\")\n```\n\nThe `solution` function calculates the price return of the soybean futures by taking the difference between the short-term futures price and the initial price, then dividing by the initial price. It calculates the collateral return for the three-month period by raising the sum of 1 and the annualized collateral yield to the power of the fraction representing the number of months out of a year. After obtaining both price return and collateral return, the function sums these to get the total return, and returns the value converted to a percentage by multiplying by 100."
        ]
    },
    {
        "question_id": "validation-61",
        "question": "If an evaluator gathers the following DCF specifications to estimate the worth of a real estate with constant rate of increase in income and value through DCF technique: The initial capitalization rate is 5.5%, the ending capitalization rate is 6%, and the discount rate is 7.25%. What is the growth rate of the property in question?",
        "tables": [],
        "python_solution": "def solution():\n    discount_rate = 7.25\n    capitalization_rate = 5.5\n    \n    growth_rate = discount_rate - capitalization_rate\n    return growth_rate",
        "ground_truth": 1.75,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To answer this question, we must understand the relationship between the initial capitalization rate (cap rate), ending cap rate, discount rate, and growth rate in a discounted cash flow (DCF) analysis. The growth rate can be found when the present value of the expected future cash flows (income) are equal to the present value of the expected future sales price, adjusted for the initial and ending cap rates as well as the discount rate. This is a form of the Gordon Growth Model, where the expected future sales price is capitalized by the ending cap rate.\n\nWhile this is a simplified explanation and the actual calculations can be much more complex, we will proceed with the following assumptions for the purposes of this program:\n\n- Initial value (V0) can be assumed to be 1 (or any arbitrary consistent number) as we are interested in the growth rate, which is a relative measure and does not change with the initial value.\n- Income growth continues at a constant rate indefinitely.\n- The property will be sold at the end of the period, capitalized by the ending cap rate.\n\nThe formula to estimate the value (V) of the real estate based on the given cap rates and discount rate is as follows:\n\nV0 = income / initial_cap_rate\nV = future_income / ending_cap_rate\n\nWhere growth_rate (g) is the rate at which the income grows and future_income is the income at the end of the period, assuming indefinite growth:\n\nfuture_income = income * (1 + g) ** n\n\nWe want the present value of future income (DCF) to equal the value today (V0), so the following equation should hold:\n\nV0 = (future_income / ending_cap_rate) / ((1 + discount_rate) ** n)\n\nHowever, as the income grows indefinitely, we can ignore n (as it approaches infinity) and simplify the model to the constant growth DCF model, where:\n\nV0 = (income * (1 + g)) / (discount_rate - g)\n\nNow, we need to solve for g:\n\ninitial_cap_rate = income / V0\ng = discount_rate - (income / (V0 * ending_cap_rate))\n\nBut since V0 is based on the initial_cap_rate and we've assumed V0 to be 1 for simplicity, the final formula for g simplifies to:\n\ng = discount_rate - (initial_cap_rate / ending_cap_rate)\n\nThe Python program that implements the above calculations could look as follows:\n\n```python\ndef solution():\n    # Given values\n    initial_cap_rate = 5.5 / 100\n    ending_cap_rate = 6 / 100\n    discount_rate = 7.25 / 100\n    \n    # We use the simplified formula to obtain the growth rate\n    # As growth_rate = discount_rate - (initial_cap_rate / ending_cap_rate)\n    growth_rate = discount_rate - (initial_cap_rate / ending_cap_rate)\n    \n    return growth_rate\n\n# Example usage\ngrowth_rate = solution()\nprint(f\"The growth rate of the property is: {growth_rate:.2%}\")\n```\n\nLet's implement this without the example usage print statement:\n\n```python\ndef solution():\n    # Given values\n    initial_cap_rate = 5.5 / 100\n    ending_cap_rate = 6 / 100\n    discount_rate = 7.25 / 100\n    \n    # Calculate the growth rate using the rearranged formula\n    growth_rate = discount_rate - (initial_cap_rate / ending_cap_rate)\n    \n    # Return the growth rate\n    return growth_rate\n\n# Call the function and store the result if you want to use it further\ngrowth_rate = solution()\n```\n\nThis function calculates and returns the growth rate as a decimal. If you are looking for the percentage output, you would multiply `growth_rate` by 100."
        ]
    },
    {
        "question_id": "validation-62",
        "question": "Utilizing the units-of-production approach, what would be the depreciation expense in the initial year for a machine purchased in Jan. 2015, as per the corresponding data provided?",
        "tables": [
            "|                           |                  |\n|---------------------------|------------------|\n|Cost of the equipment      |$5,000,000        |\n|Estimated residual value   |$500,000          |\n|Expected useful life       |9 years           |\n|Total productive capacity  |950,000 units     |\n|Production in FY2015       |150,000 units     |\n|Expected production for the next 8 years |100,000 units each year|"
        ],
        "python_solution": "def solution():\n    purchase_price = 5000000\n    salvage_value = 500000\n    total_units = 950000\n    units_produced = 150000\n\n    depreciation_expense = (purchase_price - salvage_value) * (units_produced / total_units)\n    return depreciation_expense",
        "ground_truth": 710526.316,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cost_of_equipment = 5000000\n    residual_value = 500000\n    total_productive_capacity = 950000\n    production_fy2015 = 150000\n    \n    # The units-of-production depreciation rate per unit\n    depreciation_rate_per_unit = (cost_of_equipment - residual_value) / total_productive_capacity\n    \n    # The depreciation expense for FY2015\n    depreciation_expense_fy2015 = depreciation_rate_per_unit * production_fy2015\n    \n    # return answer\n    return depreciation_expense_fy2015\n\n# Example usage:\n# print(solution())\n```\nThe function `solution` when called will calculate and return the depreciation expense for the initial year (FY2015) using the units-of-production depreciation method. It does not need to print the result but would return it directly. The example usage commented out shows how one might print the result."
        ]
    },
    {
        "question_id": "validation-63",
        "question": "A specialist compiled the financial information for a Real Estate Investment Trust. Using the income statement, what was the Real Estate Investment Trust's share price at the end of 2017 according to the Price / FFO multiple?",
        "tables": [
            "| Income Statement (in US$ million, except per share data) | 2017 Year End |\n|-----------------------------------------------------|-------------|\n| Total rental income                                 | 450         |\n| Total property expenses                             | 228         |\n| Net operating income                                | 222         |\n| Other expenses (losses on sale of properties)       | 22          |\n| General and administrative expenses                 | 28          |\n| Depreciation and amortization                       | 45          |\n| Net interest expenses                               | 35          |\n| Net income                                          | 92          |\n| Weighted average shares outstanding (million)       | 118         |\n| Earnings per share                                  | 0.78        |\n| Price/FFO, based upon year-end stock price          | 13x         |"
        ],
        "python_solution": "def solution():\n    multiple = 13\n    net_income = 92\n    depreciation_and_amortization = 45\n    loss_from_property_disposal = 22\n    shares_outstanding = 118\n    FFO = net_income + depreciation_and_amortization + loss_from_property_disposal\n    FFO_per_share = FFO / shares_outstanding\n    stock_price = multiple * FFO_per_share\n    return stock_price",
        "ground_truth": 17.517,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To determine the share price at the end of 2017 using the Price/FFO multiple, we first need to calculate the Funds from Operations (FFO). FFO is a measure often used by real estate investment trusts (REITs) to define the cash generated by their operations. It is calculated by adjusting net income by adding back depreciation and amortization and excluding gains (or losses) on sales of properties, as these are not indicative of the ongoing performance of a REIT.\n\nThe formula for FFO is:\n```\nFFO = Net Income + Depreciation and Amortization + (Losses on sale of properties)\n```\n\nSince we don't have losses from sales of properties, we'll ignore the last part of the addition. Then we multiply the FFO by the given Price/FFO multiple to get the share price.\n\nHere's how to compute the share price:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_income = 92\n    depreciation_and_amortization = 45\n    price_ffo_multiple = 13\n    \n    # Calculate FFO (since losses on sale of properties is part of other expenses we won't add it again)\n    ffo = net_income + depreciation_and_amortization\n    \n    # Calculate share price using the Price/FFO multiple\n    share_price = ffo * price_ffo_multiple\n    \n    # return answer\n    return share_price\n\n# Call the solution function and print the result\nprint(solution())\n```\nSimply run this function to get the Real Estate Investment Trust's share price at the end of 2017."
        ]
    },
    {
        "question_id": "validation-64",
        "question": "Omega Petroleum Corp. is a monopolistic entity experiencing extremely high entry barriers. Its marginal cost is $40 and its average cost is $70. After recent market research, the price elasticity of demand was discovered to be 1.5. What price is the corporation likely to set?",
        "tables": [],
        "python_solution": "def solution():\n    MC = 40\n    ED = 1.5\n    P = MC / (1 - 1/ED)\n    return P",
        "ground_truth": 120.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "Certainly! To determine the price that Omega Petroleum Corp. is likely to set, we can use the markup rule, which connects the price (P), marginal cost (MC), and price elasticity of demand (Ed) in the following way:\n\n\\[ P = MC \\times \\left( \\frac{Ed}{Ed - 1} \\right) \\]\n\nGiven that the marginal cost (MC) is $40 and the price elasticity of demand (Ed) is 1.5, we can plug in the values to find the price Omega Petroleum Corp. is likely to set.\n\nHere's the Python program to calculate the price:\n\n```python\ndef solution():\n    # Define variables name and value\n    marginal_cost = 40  # Marginal Cost ($)\n    price_elasticity_of_demand = 1.5  # Price elasticity of demand\n    \n    # Calculate price using the formula: P = MC * (Ed / (Ed - 1))\n    price = marginal_cost * (price_elasticity_of_demand / (price_elasticity_of_demand - 1))\n    \n    # return answer\n    return price\n\n# Uncomment the line below to test the function\n# print(solution())\n```\n\nWhen you run this program, it will calculate and return the price Omega Petroleum Corp. is likely to set based on the price elasticity of demand."
        ]
    },
    {
        "question_id": "validation-65",
        "question": "A two-year floating-rate bond pays 6-month LPR plus 80 basis points. The bond is valued at 97 for every 100 of face value. The present 6-month LPR is 1.00%. Presume a 30/360 day count standard and equally divided periods. What is the discount margin for the bond in basis points (bps)?",
        "tables": [],
        "python_solution": "def solution():\n    PV = 97\n    Index = 0.01\n    QM = 0.0080\n    FV = 100\n    m = 2\n    r = 0.0168\n    DM = (r * 2 - Index)\n    return DM * 10000",
        "ground_truth": 236.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To solve this question, we need to calculate the discount margin, which is the additional yield that an investor receives from a floating-rate security over the reference rate (in this case, the 6-month LPR). Because the bond pays a floating rate, its current coupon rate is equal to the 6-month LPR plus the spread of 80 basis points. Since the present value of the bond is given as 97 per 100 face value, the discount margin reflects the additional yield required to bring the bond's price up to par.\n\nThe discount margin will be the difference between the yield of the bond and the current LPR rate. However, calculating the exact discount margin can be complex and often requires iteration, as it affects both the discounting factor and the floating payments. For the sake of simplicity in this solution, we'll use a simplified approximation and ignore the time value of adjustments for the floating rate reset.\n\nLet's define the variables and calculate the discount margin approximately:\n\n```python\ndef solution():\n    # Define variables name and value\n    face_value = 100\n    purchase_price = 97\n    lpr = 1.00  # 6-month LPR\n    spread = 80  # spread in basis points\n    \n    # Current coupon rate as a percentage\n    coupon_rate = lpr + spread / 100.0  # 6-month LPR + 80 bps\n    \n    # Approximate discount margin calculation. It should be the difference in yield\n    # In theory, we would need to calculate the NPV of future cash flows at different rates\n    # and find the rate that makes the NPV equal to the current price. However, for simplicity,\n    # we will just calculate the discount margin as the coupon rate minus the price difference\n    # because the bond pays twice a year, we'll annualize the discount (multiplied by 2)\n    \n    # Calculate the annual discount margin\n    discount_per_period = (face_value - purchase_price) / face_value * 100\n    annual_discount_margin = ((coupon_rate + discount_per_period) - lpr) * 2\n    \n    # Convert to basis points\n    discount_margin_bps = annual_discount_margin * 100\n    \n    # return answer\n    return round(discount_margin_bps)\n\n# Call the function and print the result for verification\nprint(solution())\n```\n\nPlease note, this simplification does not truly reflect market practice for calculating discount margins on floating-rate notes, especially for a bond with a maturity of 2 years, where time value of money and reset mechanisms would significantly impact the exact calculation. Normally, a financial calculator or advanced financial modeling would be necessary to accurately determine the discount margin."
        ]
    },
    {
        "question_id": "validation-66",
        "question": "According to previous studies, Smith has chosen the following independent variables to forecast the initial returns of an IPO: Underwriter rank = 1–10, with 10 being the highest rank; Pre-offer price adjustment (Represented as a decimal) = (Offer price – Initial filing price)/Initial filing price; Offer size ($ millions) = Shares sold x Offer price; Fraction retained (Represented as a decimal) = Portion of total company shares kept by insiders Smith's Regression Results Dependent Variable: IPO Initial Return (Represented in Decimal Form, i.e., 1% = 0.01) The forthcoming IPO has these characteristics: underwriter rank = 6; pre-offer price adjustment = 0.04; offer size = $40 million; fraction retained = 0.70. Based on Smith’s regression analysis, what is the anticipated initial return for the forthcoming IPO?",
        "tables": [
            "| Variable           | Coefficient (bj) | Standard Error | t-Statistic |\n|--------------------|------------------|----------------|-------------|\n| Intercept          | 0.0477           | 0.0019         | 25.11       |\n| Underwriter rank   | 0.0150           | 0.0049         | 3.06        |\n| Pre-offer          | 0.4350           | 0.0202         | 21.53       |\n| price adjustment   |                  |                |             |\n| Offer size         | -0.0009          | 0.0011         | -0.82       |\n| Fraction retained  | 0.0500           | 0.0260         | 1.92        |"
        ],
        "python_solution": "def solution():\n    underwriter_rank = 6\n    pre_offer_price_adjustment = 0.04\n    offer_size = 40 \n    fraction_retained = 0.70\n\n    IR = 0.0477 + (0.0150 * underwriter_rank) + (0.435 * pre_offer_price_adjustment) - (0.0009 * offer_size) + (0.05 * fraction_retained)\n    return IR",
        "ground_truth": 0.154,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here is the Python program to calculate the anticipated initial return for the forthcoming IPO based on Smith's regression results.\n\n```python\ndef solution():\n    # Define variables name and value\n    intercept = 0.0477\n    coeff_underwriter_rank = 0.0150\n    underwriter_rank = 6\n    \n    coeff_pre_offer = 0.4350\n    pre_offer_price_adjustment = 0.04\n    \n    coeff_offer_size = -0.0009\n    offer_size = 40  # $40 million\n    \n    coeff_fraction_retained = 0.0500\n    fraction_retained = 0.70\n    \n    # Do math calculation to get the answer\n    anticipated_initial_return = (intercept +\n                                  coeff_underwriter_rank * underwriter_rank +\n                                  coeff_pre_offer * pre_offer_price_adjustment +\n                                  coeff_offer_size * offer_size +\n                                  coeff_fraction_retained * fraction_retained)\n    \n    # return answer\n    return anticipated_initial_return\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThis program takes the provided coefficients for each variable from Smith's regression results and uses them to calculate the anticipated initial return for the IPO with the given characteristics."
        ]
    },
    {
        "question_id": "validation-67",
        "question": "Without accounting for the compound effects, what is the projected total cost for the holding period when investing in the ETF for nine months, given that the ETF has these trading costs and management fees: an annual management fee of 0.40%, round-trip trading commissions of 0.55%, and a bid-offer spread of 0.20% on buying and selling?",
        "tables": [],
        "python_solution": "def solution():\n    annual_management_fee = 0.40\n    round_trip_commission = 0.55\n    bid_offer_spread = 0.20\n    holding_period = 9 / 12\n    total_cost_percentage = (holding_period * annual_management_fee) + round_trip_commission + bid_offer_spread\n    return total_cost_percentage",
        "ground_truth": 1.05,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Certainly! Below is a Python program that calculates the total projected cost for the holding period of nine months for an investment in the ETF with the given costs and fees:\n\n```python\ndef solution():\n    # Define the annual management fee, round-trip trading commissions and bid-offer spread\n    annual_management_fee_percentage = 0.0040\n    round_trip_trading_commissions_percentage = 0.0055\n    bid_offer_spread_percentage = 0.0020\n\n    # Define the holding period in months\n    holding_period_months = 9\n\n    # Calculate the management fee for the holding period (without compounding)\n    # Since the management fee is annual, we prorate it for the 9-month holding period\n    management_fee_for_period = annual_management_fee_percentage * (holding_period_months / 12.0)\n\n    # Calculate the total cost from trading commissions and the bid-offer spread\n    # These costs are incurred on each round-trip trade, so we assume they occur once for the holding period\n    trading_costs = round_trip_trading_commissions_percentage + bid_offer_spread_percentage\n\n    # Sum all costs to get the total cost for the holding period\n    total_cost = management_fee_for_period + trading_costs\n\n    # Return the total cost\n    return total_cost\n\n# Example usage:\n# print(solution())\n```\n\nThe `solution` function will return the total cost for the nine-month holding period including the prorated management fee and the costs associated with trading commissions and bid-offer spread."
        ]
    },
    {
        "question_id": "validation-68",
        "question": "What is the holding period return for the three-year timeframe, given the following annual rates of return for a mutual fund as reported by a researcher?",
        "tables": [
            "| Year | Return(%) |\n|------|-----------|\n| 2008 | 14        |\n| 2009 | -10       |\n| 2010 | -2        |"
        ],
        "python_solution": "def solution():\n    return (1+0.14)*(1-0.10)*(1-0.02)-1",
        "ground_truth": 0.005,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    returns = [14, -10, -2]  # Given annual rates of return\n\n    # Calculate the cumulative product of the returns adjusted for percentage\n    cumulative_return = 1\n    for r in returns:\n        cumulative_return *= (1 + r / 100.0)\n    \n    # Calculate holding period return (HPR)\n    hpr = (cumulative_return - 1) * 100  # Convert back to percentage\n    \n    # return answer\n    return hpr\n\n# Here you can call the solution function and print the result if you want to see the answer\n# print(solution())\n```\n\nThe `solution` function calculates the holding period return for the three-year timeframe with the given annual rates of return. It processes the rates as percentages, compounds them, and finally converts the result back to percentage form for the holding period return."
        ]
    },
    {
        "question_id": "validation-69",
        "question": "What is the gross domestic product for country B in 2015, according to the provided data?",
        "tables": [
            "| Account Item | Amount($ trillions) |\n|---------------|---------------------|\n| Consumption | 20.0 |\n| Capital consumption allowance | 1.9 |\n| Government spending | 4.2 |\n| Imports | 2.2 |\n| Gross private domestic investment | 6.0 |\n| Exports | 1.8 |"
        ],
        "python_solution": "def solution():\n    Consumption = 20\n    Gross_private_domestic_investment = 6\n    Government_Spending = 4.2\n    Exports = 1.8\n    Imports = 2.2\n    GDP = Consumption + Gross_private_domestic_investment + Government_Spending + Exports - Imports\n    return GDP",
        "ground_truth": 29.8,
        "topic": "Market Analysis & Economics",
        "output": [
            "Here's a Python program that calculates the gross domestic product (GDP) using the provided data.\n\n```python\ndef solution():\n    # Define variables name and value\n    consumption = 20.0\n    capital_consumption_allowance = 1.9\n    government_spending = 4.2\n    imports = 2.2\n    gross_private_domestic_investment = 6.0\n    exports = 1.8\n    \n    # Do math calculation to get the answer\n    # GDP = Consumption + Gross Investment + Government Spending + (Exports − Imports)\n    gdp = consumption + gross_private_domestic_investment + government_spending + (exports - imports)\n    \n    # return answer\n    return gdp\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe `solution` function calculates the gross domestic product (GDP) by summing up the amounts for consumption, capital consumption allowance (which is part of gross investment), government spending, and net exports (exports minus imports). The return value is the calculated GDP."
        ]
    },
    {
        "question_id": "validation-70",
        "question": "A portfolio consisting of two shares has the following properties: What is the standard deviation of the returns from this portfolio?",
        "tables": [
            "|                   | Stock 1 | Stock 2 |\n|-------------------|---------|---------|\n| Expected return   | 7%      | 10%     |\n| Standard deviation| 12%     | 25%     |\n| Portfolio weights | 0.30    | 0.70    |\n| Correlation       | 0.20    | 0.20    |"
        ],
        "python_solution": "def solution():\n    # weights \n    w1 = 0.3\n    w2 = 0.7\n\n    # standard deviations \n    sigma1 = 12\n    sigma2 = 25\n\n    # correlation coefficient \n    rho = 0.2\n\n    # covariance \n    Cov = rho * sigma1 * sigma2\n    \n    # portfolio variance \n    variance = (w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2*w1*w2*Cov)\n    \n    # portfolio standard deviation \n    std_dev = variance**0.5\n\n    # converting back to percentage \n    std_dev_percent = std_dev / 100.0\n    \n    return std_dev_percent",
        "ground_truth": 0.186,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight1 = 0.30\n    weight2 = 0.70\n    return1 = 0.07\n    return2 = 0.10\n    std_dev1 = 0.12\n    std_dev2 = 0.25\n    correlation = 0.20\n    \n    # Calculate portfolio variance\n    port_variance = (weight1 * std_dev1)**2 + (weight2 * std_dev2)**2 + 2 * weight1 * weight2 * correlation * std_dev1 * std_dev2\n    \n    # Calculate portfolio standard deviation\n    port_std_dev = math.sqrt(port_variance)\n    \n    # return answer\n    return port_std_dev\n\n# You can test the function with the line below:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-71",
        "question": "The Senior VP of RN fund requests Samuel to estimate the value of intangibles for XYZ Corp. Samuel observes that XYZ Corp's intangibles primarily comprise patents and other intangible assets. Consequently, Samuel forecasts the following data for the next year. Applying the excess earnings method, what is the value of the intangibles?",
        "tables": [
            "| TMT Intangibles Valuation Data | |\n| --- | --- |\n| Working capital balance | $ 22,000,000 |\n| Fair value of fixed assets | $ 57,000,000 |\n| Normalized income to the company | $89,000,000 |\n| Required return on working capital | 6% |\n| Required return on fixed assets | 9% |\n| Required return on intangible assets | 25% |\n| Future growth rate | 7% |"
        ],
        "python_solution": "def solution():\n    working_capital_return = 0.06*22000000\n    fixed_assets_return = 0.09*57000000\n    intangible_assets_return = 89000000 - working_capital_return - fixed_assets_return\n    intangible_assets_value = intangible_assets_return / (0.25 - 0.07)\n    return intangible_assets_value/1000000",
        "ground_truth": 458.611,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    working_capital_balance = 22000000\n    fair_value_fixed_assets = 57000000\n    normalized_income = 89000000\n    required_return_working_capital = 0.06\n    required_return_fixed_assets = 0.09\n    required_return_intangibles = 0.25\n    future_growth_rate = 0.07\n\n    # Calculate charge for the use of working capital\n    working_capital_charge = working_capital_balance * required_return_working_capital\n\n    # Calculate charge for the use of fixed assets\n    fixed_assets_charge = fair_value_fixed_assets * required_return_fixed_assets\n\n    # Calculate excess earnings (subtracting charges from normalized income)\n    excess_earnings = normalized_income - working_capital_charge - fixed_assets_charge\n\n    # Calculate the value of intangibles\n    # Formula: Value of Intangibles = Excess Earnings / (Required Return on Intangibles - Future Growth Rate)\n    value_of_intangibles = excess_earnings / (required_return_intangibles - future_growth_rate)\n\n    # return answer\n    return value_of_intangibles\n\n# Note: The following line should be used if you want to run the function and see the output.\n# print(solution())\n```\nNote: This solution assumes that the future growth rate is sustainable and that it can be subtracted from the required return on intangibles to arrive at the value of intangibles using the excess earnings method. The answer might vary depending on additional context or specific directions given for the calculation."
        ]
    },
    {
        "question_id": "validation-72",
        "question": "Considering the provided financial statement information, can you determine the cash conversion cycle (net operating cycle) for this particular business? What is the cash conversion cycle (net operating cycle) of this specific business?",
        "tables": [
            "|                                            | In Millions ($) |\n|--------------------------------------------|----------------:|\n| Credit sales                               |          40,000 |\n| Cost of goods sold                         |          30,000 |\n| Accounts receivable                        |           3,000 |\n| Inventory-Beginning balance                |           1,500 |\n| Inventory- Ending balance                  |           2,000 |\n| Accounts payable                           |           4,000 |"
        ],
        "python_solution": "def solution():\n    inventory_days = ((2000 + 1500)/2)/(30000/365)\n    receivables_days = 3000/(40000/365)\n    operating_cycle = inventory_days + receivables_days\n    purchases = 30000 + 2000 - 1500\n    payables_days = 4000/(purchases/365)\n    net_operating_cycle = operating_cycle - payables_days\n    return net_operating_cycle",
        "ground_truth": 0.798,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    credit_sales = 40000\n    cost_of_goods_sold = 30000\n    avg_accounts_receivable = 3000\n    beginning_inventory = 1500\n    ending_inventory = 2000\n    avg_inventory = (beginning_inventory + ending_inventory) / 2\n    accounts_payable = 4000\n\n    # Calculate Receivables Turnover Ratio\n    receivables_turnover_ratio = credit_sales / avg_accounts_receivable\n    \n    # Calculate Inventory Turnover Ratio\n    inventory_turnover_ratio = cost_of_goods_sold / avg_inventory\n    \n    # Calculate Payables Turnover Ratio\n    payables_turnover_ratio = cost_of_goods_sold / accounts_payable\n\n    # Calculate the average collection period (Days Receivables Outstanding)\n    avg_collection_period = 365 / receivables_turnover_ratio\n    \n    # Calculate the average days inventory is held (Days Inventory Outstanding)\n    avg_days_inventory_outstanding = 365 / inventory_turnover_ratio\n\n    # Calculate Days Payables Outstanding\n    days_payables_outstanding = 365 / payables_turnover_ratio\n\n    # Calculate the Cash Conversion Cycle\n    cash_conversion_cycle = avg_collection_period + avg_days_inventory_outstanding - days_payables_outstanding\n\n    # return cash_conversion_cycle\n    return cash_conversion_cycle\n    \n# Call the function and print the result\nprint(solution())\n```\nRunning this code will calculate and output the Cash Conversion Cycle (also known as the Net Operating Cycle) for the business based on the financial information provided."
        ]
    },
    {
        "question_id": "validation-73",
        "question": "In 2013, the U.S.-based tech firm Johnson Enterprises, adhering to U.S. GAAP, invested $5 million in research and $3 million in the creation of a financial software. The company aimed to possess the software copyright for 20 years, with a salvage value of $10,000. What would be the book value of the software copyright at the close of 2014?",
        "tables": [],
        "python_solution": "def solution():\n    research_cost = 5e6\n    development_cost = 3e6\n    total_cost = research_cost + development_cost\n    book_value = total_cost - total_cost\n    return book_value",
        "ground_truth": 0.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    research_costs = 5000000\n    development_costs = 3000000\n    useful_life = 20\n    salvage_value = 10000\n    \n    # Calculation of the initial value of the software copyright\n    initial_value = development_costs  # Research costs are expensed and not capitalized\n    \n    # Calculation of the annual depreciation\n    annual_depreciation = (initial_value - salvage_value) / useful_life\n    \n    # The book value at the end of 2014, after one year of depreciation\n    book_value_end_of_2014 = initial_value - annual_depreciation\n    \n    # return answer\n    return book_value_end_of_2014\n\n# Execute the function and print the result\nprint(solution())  # This line is just to check the result and should not be in the function definition.\n```\n\nThis program follows the U.S. GAAP guidelines, where research costs are expensed in the period they are incurred and are not capitalized, whereas development costs (after technological feasibility has been established) are capitalized. In this case, the company has capitalized the costs of creating the software ($3 million), and this amount will be amortized over its useful life (20 years) less any salvage value. The research costs are not included in the capitalized amount."
        ]
    },
    {
        "question_id": "validation-74",
        "question": "For a discrete uniform distribution with outcomes for M as: [7, 8, 9, 10], what is the variance of this distribution?",
        "tables": [],
        "python_solution": "def solution():\n    M = [7, 8, 9, 10]\n    expected_value = sum(M) / len(M)\n    variance = sum((x - expected_value) ** 2 for x in M) / len(M)\n    return variance",
        "ground_truth": 1.25,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define the outcomes of the discrete uniform distribution\n    outcomes = [7, 8, 9, 10]\n    n = len(outcomes)\n    \n    # Calculate the mean of the distribution\n    mean = sum(outcomes) / n\n    \n    # Compute the variance using the formula for variance of a discrete uniform distribution\n    variance = ((max(outcomes) - min(outcomes) + 1) ** 2 - 1) / 12\n    \n    # Return the answer\n    return variance\n\n# Uncomment the line below to test the function\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-75",
        "question": "In 2017, ABC Corporation had sales of $600,000 and an average accounts receivables of $50,000. What was the 2017 receivables collection period for this company?",
        "tables": [],
        "python_solution": "def solution():\n    revenue = 600000\n    avg_account_receivable = 50000\n    receivables_turnover = revenue / avg_account_receivable\n    receivables_collection_period = 365 / receivables_turnover\n    return receivables_collection_period",
        "ground_truth": 30.417,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    revenue = 600000\n    avg_account_receivable = 50000\n    \n    # Do math calculation to get the answer\n    receivables_turnover = revenue / avg_account_receivable\n    collection_period = 365 / receivables_turnover\n    \n    # return answer\n    return collection_period\n\n# This call to the solution function is just for illustration.\n# In practice, you might not need to call the function here if this script is being used as a module.\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-76",
        "question": "When a trader buys an annual coupon bond with a 6% coupon rate and exactly 20 years left until it reaches maturity at a price that's equivalent to par value. The trader's investment duration is eight years. The approximate modified duration of the bond is 11.470 years. What is the duration gap at the moment of procurement?",
        "tables": [],
        "python_solution": "def solution():\n    modified_duration = 11.470\n    yield_to_maturity = 0.06\n    investment_horizon = 8\n    macaulay_duration = modified_duration * (1 + yield_to_maturity)\n    duration_gap = macaulay_duration - investment_horizon\n    return duration_gap",
        "ground_truth": 4.158,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    investment_duration = 8\n    modified_duration = 11.470\n    \n    # Calculate the duration gap\n    duration_gap = modified_duration - investment_duration\n    \n    # Return answer\n    return duration_gap\n    \n# Perform the function\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-77",
        "question": "What is the overall return for the hedge position of Platte River Foods?",
        "tables": [
            "| | | Initial | | Risk- | Contract Price | | |\n|---|---|---|---|---|---|---|---|\n| Price Return | | Roll Return | Collateral Required | Free Rate | Position Size | Current | Longer Term |\n| 4% | | 1.50% | 20% | 1% | $1,500,000 | $750 | $500 |"
        ],
        "python_solution": "def solution():\n    price_return = 4.0\n    roll_return = 1.5\n    collateral_return = 0.2\n    total_return = price_return + roll_return + collateral_return\n    return total_return",
        "ground_truth": 5.7,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    price_return = 0.04  # Price Return\n    roll_return = 0.015  # Roll Return\n    risk_free_rate = 0.01  # Risk-Free Rate\n    collateral_required = 0.20  # Collateral Required\n    contract_price_initial = 750  # Initial Price\n    contract_price_long_term = 500  # Longer Term Price\n    position_size = 1500000  # Position Size\n\n    # Calculate the contract returns\n    contract_return = ((contract_price_long_term - contract_price_initial) / contract_price_initial) * position_size\n\n    # Adjust for collateral\n    collateral_return = risk_free_rate * (collateral_required * position_size)\n\n    # Calculate the overall return\n    overall_return = price_return * position_size + roll_return * position_size + contract_return + collateral_return\n    \n    # return answer\n    return overall_return\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program defines the required variables based on the given table, calculates the contract returns, adjusts for collateral, calculates the overall return for the hedge position of Platte River Foods, and returns that value."
        ]
    },
    {
        "question_id": "validation-78",
        "question": "XYZ NY, a home decor purchasing firm, provides a defined benefit pension scheme for its workers. With reference to the details provided in the subsequent table, presuming that there are no write-offs of past service expenses or actuarial losses and if the actuarial loss is disregarded, can you figure out the recurrent pension expenses which would be presented in I/S as per US GAAP?",
        "tables": [
            "|                    |      |\n|--------------------|------|\n| ABC LA retirement plan information 2018  |      |\n| Current service costs    |  320 |\n| Past service costs   |  150 |\n| Employer contributions  |  1,200 |\n| Benefit obligation at beginning of year |  45,000 |\n| Benefit obligation at end of year   |  48,395 |\n| Plan assets at beginning of year   |  40,800 |\n| Plan assets at end of year |  44,300 |\n| Actuarial loss   |  350 |\n| Actual return on plan assets   |  3,100 |\n| Discount rate on plan liabilities   |  7.5% |\n| Expected rate of return on plan assets   |  8.2% |"
        ],
        "python_solution": "def solution():\n    current_service_cost = 320\n    interest_expense = (45000 + 150) * 0.075\n    expected_return = 40800 * 0.082\n    periodic_pension_cost = current_service_cost + interest_expense - expected_return\n    return periodic_pension_cost",
        "ground_truth": 360.65,
        "topic": "Accounting",
        "output": [
            "Sure, let's decode the recurrent pension expenses as per US GAAP based on the given data:\n\nRecurrent pension cost components:\n1. Current service cost\n2. Interest cost (Discount rate applied to the Benefit obligation at the beginning of the year)\n3. Expected return on plan assets (Expected rate applied to the Plan assets at the beginning of the year)\n4. Amortization of past service cost (not mentioned if it is to be amortized or not, so we will simply include the entire amount for the current period)\n5. Actuarial loss (which in this case we are to disregard)\n\nLet's code this in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    current_service_cost = 320\n    past_service_cost = 150  # Assumed to be recognized in the current period\n    employer_contributions = 1200\n    benefit_obligation_begin = 45000\n    benefit_obligation_end = 48395\n    plan_assets_begin = 40800\n    plan_assets_end = 44300\n    actuarial_loss = 350\n    actual_return_on_plan_assets = 3100\n    discount_rate = 0.075\n    expected_return_rate = 0.082\n    \n    # Do math calculation to get the answer\n    \n    # Interest cost\n    interest_cost = benefit_obligation_begin * discount_rate\n    \n    # Expected return on plan assets\n    expected_return = plan_assets_begin * expected_return_rate\n    \n    # Recurrent pension cost (excluding actuarial loss)\n    recurrent_pension_cost = current_service_cost + interest_cost - expected_return + past_service_cost\n    \n    # return answer\n    return recurrent_pension_cost\n\n# Call the function and print the answer.\nprint(solution())\n```\n\nRunning this code will calculate the recurrent pension expenses which would be presented in the income statement as per US GAAP using the provided pension plan information, disregarding the actuarial loss."
        ]
    },
    {
        "question_id": "validation-79",
        "question": "What is the per unit marginal revenue attributed to marketing 250 units instead of 200 units, based on the assessment of the marketing leader from a manufacturer of niche equipment from Switzerland that posits a total income of CHF500,000 from 200 units and CHF600,000 from selling 250 units?",
        "tables": [],
        "python_solution": "def solution():\n    delta_TR = 600000 - 500000\n    delta_Q = 250 - 200\n    MR = delta_TR / delta_Q\n    return MR",
        "ground_truth": 2000.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    total_revenue_200_units = 500000\n    total_revenue_250_units = 600000\n    units_difference = 250 - 200\n\n    # Calculating the marginal revenue for the additional 50 units\n    marginal_revenue = (total_revenue_250_units - total_revenue_200_units) / units_difference\n\n    # return answer\n    return marginal_revenue\n\n# Uncomment the line below to test the function\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-80",
        "question": "Bradley took over a Spanish packaging firm. The Spanish venture included Bradley purchasing 200,000 shares at a rate of EUR90 each from a packaging company. He elected to entirely hedge the position with a six month USD/EUR forward contract. Further details of the euro hedge at the beginning and three months later are displayed in Exhibit 1. Using the information in Exhibit 1, if the Spanish shares were sold after three months, what is the mark-to-market value (in US dollars) that the manager would report?",
        "tables": [
            "| Maturity         | At Initiation | Three Months Later | At Maturity |\n|------------------|--------------|---------------------|------------|\n| Spot (USD/EUR)   | 1.3935/1.3983 | 1.4106/1.4210      | 1.4189/1.4289 |\n| 3-month forward  | -8.1/-7.6      | -21.6/-21.0           |          |\n| 6-month forward  | -19.0/-18.3   | -27.0/-26.2           |          |\n| USD Libor       | 1.266%        | 1.266%               | 1.266%   |\n| EUR Libor       | 1.814%        | 1.814%               | 1.814%   |"
        ],
        "python_solution": "def solution():\n    num_shares = 200000\n    price_per_share_eur = 90\n    total_value_eur = num_shares * price_per_share_eur\n    \n    init_forward_rate = 1.3935 - 19/10000\n    settling_forward_rate = 1.4210 - 21/10000\n    \n    diff_rate = init_forward_rate - settling_forward_rate\n    \n    notional_value_usd = diff_rate * total_value_eur\n    \n    libor = 1.266 / 100\n    investment_period = 90\n    \n    mark_to_market_usd = notional_value_usd / (1 + libor * investment_period / 360)\n    \n    return mark_to_market_usd",
        "ground_truth": -489849.626,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the mark-to-market value (in US dollars) that the manager would report after selling the Spanish shares after three months, we need to:\n\n1. Calculate the cost of the shares in euros and then convert it to dollars at the initial forward rate.\n2. Determine the value of the shares if sold after three months in euros and then convert it to dollars at the spot rate three months later.\n3. Calculate the gain or loss on the forward contract by comparing the initial forward rate to the forward rate three months later.\n\nThe formula to get the mark-to-market value is:\n```\nMark-to-Market Value = Value of Shares at Spot Rate Three Months Later - (Initial Cost of Shares in USD)\n```\nWe can use Exhibit 1 to get the data needed for the calculations.\n\nHere's the Python program to calculate the mark-to-market value:\n\n```python\ndef solution():\n    # Define variables name and value\n    num_shares = 200000\n    price_per_share_eur = 90\n    forward_rate_initial = 1.3935 + 19.0 / 10000  # Adding the forward points to the spot rate\n    forward_rate_three_months_later = 1.4106 + 27.0 / 10000  # Adding the forward points to the spot rate three months later\n    spot_rate_three_months_later = 1.4106\n    \n    # Calculate cost of shares in EUR and convert to USD at initial forward rate\n    total_cost_eur = num_shares * price_per_share_eur\n    total_cost_usd_initial = total_cost_eur * forward_rate_initial\n    \n    # Calculate value of shares sold after three months in EUR and convert to USD at spot rate three months later\n    total_value_usd_spot_three_months_later = total_cost_eur * spot_rate_three_months_later\n    \n    # Calculate mark-to-market value\n    mark_to_market_value = total_value_usd_spot_three_months_later - total_cost_usd_initial\n    \n    # Return answer\n    return mark_to_market_value\n    \n# Call the function and print the solution\nprint(solution())\n```\n\nThis program contains hardcoded values directly from the Exhibit 1. If the intention is to handle variable data, you would need to modify the function to accept inputs accordingly."
        ]
    },
    {
        "question_id": "validation-81",
        "question": "The existing yearly spot rates are presented as follows: 1 year at 2%, 2 years at 2.5%, 3 years at 3.5%, and 4 years at 5.5%. Can you tell me the forward rate for two years starting from two years from now?",
        "tables": [],
        "python_solution": "def solution():\n    # Given Spot rates\n    s1, s2, s3, s4 = 0.02, 0.025, 0.035, 0.055\n\n    # Formula for two years forward rate\n    forward_rate = (((1 + s4)**4 / (1 + s2)**2) ** (1/2)) - 1\n    \n    # Convert to percentage\n    forward_rate *= 100\n\n    return forward_rate",
        "ground_truth": 8.588,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! The forward rate for two years starting two years from now can be calculated using the spot rates given for the second and fourth years. Here is a Python program to calculate the forward rate:\n\n```python\ndef solution():\n    # Define variables name and value\n    spot_rate_2_year = 0.025\n    spot_rate_4_year = 0.055\n    time1 = 2\n    time2 = 4\n    \n    # Calculation\n    # Using the formula: (1+spot_rate_4_year)^(time2) = (1+spot_rate_2_year)^(time1) * (1+forward_rate_2_year)^(time2-time1)\n    # Solve for forward_rate_2_year\n    forward_rate_2_year = ((1 + spot_rate_4_year) ** (time2) / (1 + spot_rate_2_year) ** (time1)) ** (1 / (time2 - time1)) - 1\n    \n    # return answer\n    return forward_rate_2_year\n\n# Running the solution function to get the forward rate\nforward_rate = solution()\nforward_rate\n```\n\nWhen running this program, it will return the calculated forward rate for two years starting from two years from now based on the given spot rates."
        ]
    },
    {
        "question_id": "validation-82",
        "question": "Assuming the same series of spot rates, what is the cost of a 3-year bond that provides an annual interest payment at a 10% coupon rate?",
        "tables": [
            "| Time-to- Maturity | Spot Rates |\n| --- | --- |\n| 1 year | 8.0% |\n| 2 years | 9.0% |\n| 3 years | 9.5% |"
        ],
        "python_solution": "def solution():\n    Z1, Z2, Z3, PMT, FV = 0.08, 0.09, 0.095, 10, 100\n    PV1 = PMT / (1 + Z1)\n    PV2 = PMT / (1 + Z2)**2\n    PV3 = (PMT + FV) / (1 + Z3)**3\n    PV = PV1 + PV2 + PV3\n    return PV",
        "ground_truth": 101.458,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the cost of a 3-year bond with annual interest payments at a 10% coupon rate, given the series of spot rates, we can use the present value formula for each cash flow involved (i.e., each coupon payment and the payment of principal at maturity).\n\nWe'll discount each of the annual coupon payments and the principal amount at the given spot rates for 1, 2, and 3 years, respectively. The sum of these present values is the cost of the bond.\n\nHere's how the Python program would look:\n\n```python\ndef solution():\n    # Define given spot rates\n    spot_rates = {1: 0.08, 2: 0.09, 3: 0.095}\n    \n    # Define face value and coupon rate\n    face_value = 1000  # Assuming a standard face value of $1,000\n    coupon_rate = 0.10\n    annual_coupon_payment = face_value * coupon_rate\n    \n    # Calculate present value of each coupon payment and the face value at maturity\n    pv_coupon_payments = sum(annual_coupon_payment / (1 + spot_rates[i])**i for i in range(1, 4))\n    pv_face_value = face_value / (1 + spot_rates[3])**3\n    \n    # Sum of the present values is the cost of the bond\n    bond_cost = pv_coupon_payments + pv_face_value\n    \n    # Return the cost of the bond\n    return bond_cost\n\n# Output the function call\nresult = solution()\nprint(f\"The cost of the 3-year bond is: ${result:.2f}\")\n```\n\nThis script calculates the present value of each of the three coupon payments and the present value of the principal payment, adds them all together, and returns that sum as the cost of the bond.\n\nRemember that the `face_value` variable here is assumed to be $1,000, which is a typical face value for bonds. If you have a different face value for the bond, ensure that the `face_value` variable reflects that amount."
        ]
    },
    {
        "question_id": "validation-83",
        "question": "The unit contribution margin for an item is $20. A business's fixed production costs up to 300,000 units amounts to $500,000. At which production levels (in units) is the degree of operating leverage (DOL) likely to be the least?",
        "tables": [],
        "python_solution": "def solution():\n    contribution_margin = 20\n    fixed_costs = 500000\n    production_levels = [100000, 200000, 300000]\n    DOLs = []\n\n    for quantity in production_levels:\n        DOL = quantity * contribution_margin / (quantity * contribution_margin - fixed_costs)\n        DOLs.append(DOL)\n\n    minimum_DOL = min(DOLs)\n\n    for i in range(len(DOLs)):\n        if DOLs[i] == minimum_DOL:\n            return production_levels[i]",
        "ground_truth": 300000.0,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    unit_contribution_margin = 20\n    fixed_costs = 500000\n    \n    # Degree of Operating Leverage (DOL) is least when Contribution Margin = Fixed Costs\n    # DOL = Total Contribution Margin / (Total Contribution Margin - Fixed Costs)\n    # When Total Contribution Margin = Fixed Costs, then DOL is minimum (and equals 1)\n    \n    # Calculate break-even point in units, where Total Contribution = Fixed Costs\n    break_even_units = fixed_costs / unit_contribution_margin\n    \n    # return answer which is the break-even point in units\n    return break_even_units\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-84",
        "question": "If the periodic inventory system and FIFO method were utilized, in 2013, Corporation Z commenced operations and acquired 2,000 units of inventory, each unit purchased at $50 and sold at $70, with only 1500 units actually sold. In 2014, it acquired another 1,000 units, each unit was purchased at $60 and sold at $75, however only 500 units were sold. What is the ending inventory balance for Corporation Z in 2014?",
        "tables": [],
        "python_solution": "def solution():\n    inventory_in_2014 = 1000\n    cost_per_unit_in_2014 = 60\n    ending_inventory_balance = inventory_in_2014 * cost_per_unit_in_2014\n    return ending_inventory_balance",
        "ground_truth": 60000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Initial purchase in 2013\n    initial_units_2013 = 2000\n    purchase_price_2013 = 50\n    \n    # Inventory sold in 2013\n    units_sold_2013 = 1500\n    \n    # Remaining inventory from 2013\n    remaining_inventory_2013 = initial_units_2013 - units_sold_2013\n    \n    # New purchase in 2014\n    new_units_2014 = 1000\n    purchase_price_2014 = 60\n    \n    # Total inventory at the beginning of 2014\n    total_beginning_inventory_2014 = remaining_inventory_2013\n    \n    # Inventory sold in 2014 (500 from the beginning inventory)\n    units_sold_2014 = 500\n    \n    # Remaining beginning inventory after sales in 2014\n    remaining_beginning_inventory_after_2014 = total_beginning_inventory_2014 - units_sold_2014\n    \n    # Ending inventory balance for 2014, combine remaining beginning inventory and new purchases\n    ending_inventory_units_2014 = remaining_beginning_inventory_after_2014 + new_units_2014\n    \n    # Ending inventory balance cost (500 units from 2013 at $50 each plus 1000 units from 2014 at $60 each)\n    ending_inventory_balance_2014 = (\n        remaining_beginning_inventory_after_2014 * purchase_price_2013 +\n        new_units_2014 * purchase_price_2014\n    )\n    \n    # return answer\n    return ending_inventory_balance_2014\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-85",
        "question": "Johnson's second investment recommendation is to acquire a futures contract for a 10-year Treasury note. The base 2%, semi-annual 10-year Treasury note has a dirty price of 104.17. There have been 30 days since the last coupon payment of the 10-year Treasury note. The futures contract will terminate in 90 days. The quoted price for the futures contract is 129. The current yearly risk-free rate for three months stands at 1.65%. The conversion factor is 0.7025. Smith asks Johnson to compute the quoted futures contract price equilibrium using the carry arbitrage model. What is the equilibrium quoted 10-year Treasury note futures contract price?",
        "tables": [],
        "python_solution": "def solution():\n    B0 = 104.00\n    AI0 = 0.17\n    AIT = (120/180 * 0.02/2)\n    FVCI = 0\n    CF = 0.7025\n    Ft = (B0 + AI0 + AIT) / (1 - FVCI)\n    F_eq = Ft / CF\n    return F_eq",
        "ground_truth": 148.294,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\n# Import packages\nimport math\n\ndef solution():\n    # Given variables\n    dirty_price = 104.17          # The dirty price of the Treasury Note\n    coupon_payment_days = 30      # Days since last coupon payment\n    futures_contract_days = 90    # Days until futures contract termination\n    quoted_futures_price = 129    # The quoted price for the futures contract\n    risk_free_rate_annual = 1.65  # The current yearly risk-free rate for three months (expressed as a percentage)\n    conversion_factor = 0.7025    # The given conversion factor for the Treasury note\n\n    # Calculate the risk-free rate for the appropriate period\n    risk_free_rate_periodic = (1 + risk_free_rate_annual/100) ** (futures_contract_days/365) - 1\n\n    # Calculate the cost of carry\n    # Assuming the cost of carry includes the price of the Treasury note, the accrued interest over the period,\n    # and the interest expense of financing the position for the period, minus the coupon payment received during the period.\n    carry_cost = dirty_price * risk_free_rate_periodic\n \n    # Calculate full future price\n    future_price_full = dirty_price + carry_cost # Cost to carry the position until the futures expiration date\n\n    # Adjust the future price with the conversion factor\n    adjusted_future_price = future_price_full / conversion_factor\n    \n    # Return the adjusted future price as the equilibrium quote\n    return round(adjusted_future_price, 2)\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe provided program calculates the quoted futures contract price equilibrium using the carry arbitrage model. It declares the variables for the dirty price, the days since the last coupon payment, the days until the futures contract termination, the quoted futures price, the annual risk-free rate, and the conversion factor. It then calculates the risk-free rate for the relevant period and estimates the cost of carry. Finally, it adjusts the future price with the conversion factor and returns the rounded result as the answer."
        ]
    },
    {
        "question_id": "validation-86",
        "question": "According to the table providing necessary details about four bonds in an investment collection, what is the price value of a basis point for this collection?",
        "tables": [
            "| Par Value | Bond Price | Coupon | Modified Duration | Effective Duration | Convexity |\n| --------- | ---------- | ------ | ----------------- | ------------------ | --------- |\n| $25million | 105 | 8% | 7.9 | 8 | 122 |\n| $25million | 100 | 7% | 8.5 | 8.5 | 154 |\n| $20million | 95 | 5% | 6.3 | 2 | 87 |\n| $30million | 87 | 0% | 10.2 | 10.2 | 32 |"
        ],
        "python_solution": "def solution():\n    bond_weights = [0.25, 0.25, 0.2, 0.3]\n    bond_prices = [105, 100, 95, 87]\n    bond_durations = [8, 8.5, 2, 10.2]\n\n    portfolio_price = sum([bond_weights[i] * bond_prices[i] for i in range(len(bond_weights))])\n   \n    portfolio_duration = sum([bond_weights[i] * bond_prices[i] * bond_durations[i] for i in range(len(bond_weights))]) / portfolio_price\n\n    price_value_basis_point = portfolio_duration * 0.0001 * portfolio_price * 1000000\n\n    return price_value_basis_point",
        "ground_truth": 72672.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "The price value of a basis point (PVBP), also known as the dollar value of an 01 (DV01), is a measure used to estimate the change in the price of a bond for a 1 basis point change in yield. It is a useful measure for assessing the interest rate risk of bond portfolios.\n\nThe formula to calculate PVBP for an individual bond is typically:\n\nPVBP = (Bond Price * Modified Duration) / 10,000\n\nHowever, to calculate the price value of a basis point for a bond portfolio, we need to sum the PVBP for each bond in the portfolio.\n\nHere's the Python program to calculate the price value of a basis point for the given investment collection:\n\n```python\ndef solution():\n    # Define variables for each bond\n    bonds = [\n        {'par_value': 25000000, 'price': 105, 'modified_duration': 7.9},\n        {'par_value': 25000000, 'price': 100, 'modified_duration': 8.5},\n        {'par_value': 20000000, 'price': 95, 'modified_duration': 6.3},\n        {'par_value': 30000000, 'price': 87, 'modified_duration': 10.2},\n    ]\n    \n    # Calculate PVBP for each bond and sum them up to get total PVBP for the collection\n    total_pvbp = sum(bond['price'] * bond['modified_duration'] * bond['par_value'] / 10000 for bond in bonds)\n    \n    # Return the answer\n    return total_pvbp\n\n# Call to the solution function to get the answer\nanswer = solution()\nanswer\n```\n\nThis program will calculate the PVBP for each bond and sum them up to provide the price value of a basis point for the entire collection. Note that bond prices are usually quoted as a percentage of the par value, but the actual price used for calculations is the full price (e.g., a bond price of 105 corresponds to 105% of the par value)."
        ]
    },
    {
        "question_id": "validation-87",
        "question": "Firm XYZ has an outstanding zero-coupon bond with 1 year left until it matures. The bond, which is the company's only debt, has a face value of USD 2,000,000 and a recovery rate of 0% in the event of a default. It is currently trading at 75% of its face value. If we assume that the excess spread solely reflects credit risk and the continuously-compounded risk-free rate is 3% yearly, and using risk-neutral binomial tree methodology, what is the approximately risk-neutral 1-year probability of default for Firm XYZ?",
        "tables": [],
        "python_solution": "def solution():\n    from math import exp\n    face_value = 2000000\n    bond_price = 0.75 * face_value\n    risk_free_rate = 0.03\n    expected_payoff = bond_price * exp(risk_free_rate)\n\n    PD = 1 - (expected_payoff / face_value)\n    \n    return PD * 100",
        "ground_truth": 22.716,
        "topic": "Risk Management",
        "output": [
            "To answer the question, we need to calculate the risk-neutral probability of default. A zero-coupon bond is a bond that pays no interest and is sold at a discount from its face value.\n\nGiven:\n- Current price \\(P\\) of the bond is 75% of its face value\n- Face value \\(F\\) of the bond is USD 2,000,000\n- The continuously-compounded risk-free rate \\(r\\) is 3%\n- Recovery rate \\(R\\) is 0% in the event of default\n- Time to maturity \\(T\\) is 1 year\n\nThe price of a zero-coupon bond is given by:\n\\[ P = F \\cdot e^{-r \\cdot T} \\]\n\nHowever, because there's a probability of default, the price must also factor in the potential loss due to default, which is the face value times the probability of default. Since the recovery rate is 0%, the entire face value is lost in the event of a default.\n\nRisk-neutral valuation implies the expected payoff of the bond should equal its current market price. Therefore:\n\\[ P = (1 - \\text{probability of default}) \\cdot F \\cdot e^{-r \\cdot T} \\]\n\nSolving for the probability of default (\\(PD\\)):\n\\[ PD = 1 - \\frac{P}{F \\cdot e^{-r \\cdot T}} \\]\n\nNow, we'll implement this formula in a Python function:\n\n```python\nimport math\n\ndef solution():\n    # Define variables\n    face_value = 2000000 # Face value of the bond\n    price_percentage = 0.75 # Price of the bond as a percentage of its face value\n    price = face_value * price_percentage # The market price of the bond\n    risk_free_rate = 0.03 # Continuously-compounded risk-free rate\n    recovery_rate = 0 # Recovery rate\n    \n    # Time to maturity is 1 year, so T is 1\n    time_to_maturity = 1\n    \n    # Calculating the risk-neutral probability of default\n    probability_of_default = 1 - (price / (face_value * math.exp(-risk_free_rate * time_to_maturity)))\n    \n    # Return answer\n    return probability_of_default\n\n# To print out the result\nprint(f\"The risk-neutral 1-year probability of default for Firm XYZ is approximately {solution():.2f}\")\n```\n\nNote that this program will give us the risk-neutral probability of default for Firm XYZ."
        ]
    },
    {
        "question_id": "validation-88",
        "question": "What will be the subsequent book value per share if the corporation buys back 1 million shares at the current market rate, based on the data collected by the researcher about the corporation?",
        "tables": [
            "| Number of shares outstanding | 10 million   |\n|-----------------------------|--------------|\n| Earnings per share          | $2.00        |\n| P/E                         | 20           |\n| Book value per share        | $30          |"
        ],
        "python_solution": "def solution():\n    market_price_per_share = 40\n    shares_to_buy_back = 1e6\n    equity_reduction = market_price_per_share * shares_to_buy_back\n    book_value_equity_before_buyback = 300e6\n    book_value_equity_after_buyback = book_value_equity_before_buyback - equity_reduction\n    no_of_shares_after_buyback = 9e6\n    book_value_per_share_after_buyback = book_value_equity_after_buyback / no_of_shares_after_buyback\n    return book_value_per_share_after_buyback",
        "ground_truth": 28.889,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    number_of_shares_outstanding = 10e6  # 10 million shares\n    earnings_per_share = 2.00  # $2.00 EPS\n    pe_ratio = 20  # P/E ratio\n    book_value_per_share = 30.00  # $30 Book Value per Share\n    shares_to_buy_back = 1e6  # 1 million shares to buy back\n    \n    # Calculate the market price of the stock\n    market_price_per_share = earnings_per_share * pe_ratio\n    \n    # Calculate total book value before buyback\n    total_book_value = book_value_per_share * number_of_shares_outstanding\n    \n    # Calculate the cost of the buyback\n    cost_of_buyback = market_price_per_share * shares_to_buy_back\n    \n    # Calculate new total book value after buyback\n    new_total_book_value = total_book_value - cost_of_buyback\n    \n    # Calculate new number of shares outstanding after buyback\n    new_number_of_shares_outstanding = number_of_shares_outstanding - shares_to_buy_back\n    \n    # Calculate subsequent book value per share after buyback\n    new_book_value_per_share = new_total_book_value / new_number_of_shares_outstanding\n    \n    # return answer\n    return new_book_value_per_share\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThe `solution()` function calculates the subsequent book value per share after a corporation buys back 1 million of its own shares. It first determines the market price of the shares based on the earnings per share and P/E ratio, then calculates the total cost of the buyback. After adjusting the total book value and the number of shares outstanding following the buyback, it computes the new book value per share and returns this value as the answer."
        ]
    },
    {
        "question_id": "validation-89",
        "question": "Recently, Mr. Lee purchased a property in Shanghai and made a down payment of ¥ 5,000,000. He took out a loan for the remaining balance of ¥5,000,000 from the bank which he will repay monthly over a period of 10 years. Given that the yearly discount rate is 5.8%, what will the initial mortgage repayment be at the end of this month?",
        "tables": [],
        "python_solution": "def solution():\n    N = 10 * 12\n    I_Y = 5.8 / 12 / 100\n    PV = 5000000\n    FV = 0\n    PMT = -PV * (I_Y * ((1 + I_Y)**N)) / ((1+I_Y)**N - 1)\n    return abs(PMT)",
        "ground_truth": 55009.405,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To calculate the initial mortgage repayment for Mr. Lee's loan at the end of the month, we can use the fixed-rate mortgage formula. The formula to calculate the monthly payment (M) on a fixed-rate mortgage is:\n\nM = P [i(1+i)^n] / [(1+i)^n−1]\n\nWhere:\nP = principal loan amount (remaining balance)\ni = monthly interest rate (annual rate / 12)\nn = total number of payments (loan terms in years * 12)\n\nLet's write a Python program to compute the initial mortgage repayment.\n\n```python\ndef solution():\n    # Define variables name and value\n    principal = 5000000\n    annual_discount_rate = 5.8 / 100 # convert percent to decimal\n    loan_term_years = 10\n    \n    # Convert annual discount rate to monthly and loan term to months\n    monthly_interest_rate = annual_discount_rate / 12 \n    total_payments = loan_term_years * 12\n    \n    # Calculate the monthly mortgage payment using the formula\n    numerator = principal * monthly_interest_rate * (1 + monthly_interest_rate) ** total_payments\n    denominator = ((1 + monthly_interest_rate) ** total_payments) - 1\n    monthly_payment = numerator / denominator\n    \n    # return answer rounded to two decimals\n    return round(monthly_payment, 2)\n\n# Example usage:\nmonthly_repayment = solution()\nprint(f\"The initial mortgage repayment at the end of this month: ¥{monthly_repayment}\")\n```\n\nRun the program above to get the answer for Mr. Lee's initial mortgage repayment. The `round` function is used to round the result to two decimal places to represent the value in currency terms accurately."
        ]
    },
    {
        "question_id": "validation-90",
        "question": "An organization released a floating-rate note that has a coupon rate equivalent to the three-month MRR + 65 basis points. The interest payments are scheduled for 31 March, 30 June, 30 September, and 31 December. The three-month MRR for 31 March and 30 June stand at 1.55% and 1.35% respectively. What is the coupon rate for the interest remittance done on 30 June?",
        "tables": [],
        "python_solution": "def solution():\n    MRR_March  = 1.55\n    basis_points = 0.65\n    coupon_rate_June = MRR_March + basis_points\n    return coupon_rate_June",
        "ground_truth": 2.2,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is the Python program to calculate the coupon rate for the interest remittance done on 30 June:\n\n```python\ndef solution():\n    # Since the coupon rate is tied to the three-month MRR plus a fixed 65 basis points\n    # we just have to add those values together for the corresponding period.\n    \n    # Define variable for three-month MRR (MRR is expressed in percentage, so convert it to decimal)\n    three_month_MRR_June = 1.35\n    \n    # Define the fixed basis points as a decimal\n    fixed_basis_points = 0.65\n    \n    # Calculate the coupon rate for 30 June\n    coupon_rate_June = three_month_MRR_June + fixed_basis_points\n    \n    # Return the coupon rate for 30 June\n    return coupon_rate_June\n\n# This will print the answer\nprint(solution())\n```\n\nPlease note that the MRR rates and basis points are typically expressed in percentage terms, but when doing calculations, they should be converted to their decimal form (e.g., 1.55% as 1.55 and 65 basis points as 0.65). This conversion is assumed in the answer. However, if in your context the MRR should remain as is and just the basis points need conversion, you would need to adjust the `fixed_basis_points` variable accordingly."
        ]
    },
    {
        "question_id": "validation-91",
        "question": "What would be the expected standard deviation of the portfolio constructed by a fund manager if the correlation of returns between the two securities is 0.40?",
        "tables": [
            "| Security | Security Weight(%) | Expected Standard Deviation(%) |\n|----------|-------------------|-------------------------------|\n| 1        | 30                | 20                            |\n| 2        | 70                | 12                            |"
        ],
        "python_solution": "def solution():\n    w1 = 0.3\n    w2 = 0.7\n    sigma1 = 20 / 100    # converting the percentage to a decimal\n    sigma2 = 12 / 100    # converting the percentage to a decimal\n    rho12 = 0.40         # correlation of returns between two securities\n\n    sigma_port = ((w1 ** 2 * sigma1 ** 2) + (w2 ** 2 * sigma2 ** 2) + (2 * w1 * w2 * rho12 * sigma1 * sigma2)) ** 0.5\n\n    return sigma_port * 100    # converting the decimal to a percentage",
        "ground_truth": 12.119,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight1 = 0.30\n    weight2 = 0.70\n    std_dev1 = 0.20\n    std_dev2 = 0.12\n    correlation = 0.40\n    \n    # Do math calculation to get the answer\n    # Portfolio standard deviation formula under the assumption of two assets:\n    # √(w1²σ1² + w2²σ2² + 2w1w2σ1σ2ρ)\n    portfolio_std_dev = math.sqrt(\n        (weight1**2) * (std_dev1**2) +\n        (weight2**2) * (std_dev2**2) +\n        2 * weight1 * weight2 * std_dev1 * std_dev2 * correlation\n    )\n    \n    # Return answer\n    return portfolio_std_dev\n\n# Call the function and print the result\nprint(solution())\n```\n\nUpon calling the `solution()` function, it will return the expected standard deviation of the portfolio constructed with the given weights, standard deviations, and correlation between the securities."
        ]
    },
    {
        "question_id": "validation-92",
        "question": "Three months ago, a supervisor initiated a receive-fixed and pay-equity swap. The annualized fixed interest is 3% and the equity index was at 100 at the time of the swap. The expiry of the swap is one year with a quarterly reset, and the nominal amount is valued at $100 million. The present spot rates are as stated: At what equity index level would this equity swap value stand at zero?",
        "tables": [
            "| Years to maturity | Present Value Factor |\n|-------------------|----------------------|\n| 0.25              | 0.997506             |\n| 0.5               | 0.992556             |\n| 0.75              | 0.985222             |\n| 1                 | 0.975610             |"
        ],
        "python_solution": "def solution():\n    fixed_rate = 0.03\n    nominal_amount = 100000000\n    current_spot_rates = [0.997506, 0.992556, 0.985222]\n    number_of_days = 90\n    denominator = 360\n\n    value_fixed_leg = fixed_rate * (number_of_days / denominator) * nominal_amount * sum(current_spot_rates) + (nominal_amount * current_spot_rates[-1])\n\n    equity_index_price = value_fixed_leg / nominal_amount * 100\n    return equity_index_price",
        "ground_truth": 100.754,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "In order to calculate at what equity level the value of the equity swap would stand at zero, we need to follow a few steps:\n\nFirst, we'll calculate the present value of the fixed payments. Since the swap has a nominal amount of $100 million and an annualized fixed interest of 3%, the fixed payments would be $100 million * 3% = $3 million annually, or $0.75 million quarterly.\n\nSecond, we'll discount these fixed payments to their present value using the provided present value factors for the remaining quarters.\n\nThird, we'll determine the value of the equity leg. Since we want the swap to be at zero value, the present value of the equity leg must equal the present value of the fixed payments.\n\nHere is the Python code for the calculation:\n\n```python\ndef solution():\n    # Define variables name and value\n    nominal_amount = 100000000  # Nominal amount of the swap: $100 million\n    fixed_interest_rate = 0.03  # Annualized fixed interest rate: 3%\n    initial_equity_index = 100  # Equity index at the time of the swap\n    \n    # The quarterly fixed payment (annual payment divided by 4)\n    fixed_payment = nominal_amount * fixed_interest_rate / 4\n    \n    # Present value factors for the remaining three quarters\n    present_value_factors = [0.992556, 0.985222, 0.975610]\n    \n    # Calculate present value of the fixed payments\n    pv_fixed_payments = sum(fixed_payment * pv for pv in present_value_factors)\n    \n    # We are looking for the equity index level (E) which makes the PV of the equity leg equal to pv_fixed_payments.\n    # Since we want the swap to equal zero value:\n    # PV of equity leg (which is also E * nominal_amount * present_value_factors[-1]) = PV of fixed payments\n    # E = pv_fixed_payments / (nominal_amount * present_value_factors[-1])\n    \n    equity_index_level = pv_fixed_payments / (nominal_amount * present_value_factors[-1])\n    \n    # return answer\n    return equity_index_level\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThis program will calculate and return the equity index level at which the equity swap value stands at zero."
        ]
    },
    {
        "question_id": "validation-93",
        "question": "A financier looking to calculate the enterprise value multiple (EV/EBITDA) of a business has collected the relevant information, what is the business's EV/EBITDA multiple?",
        "tables": [
            "| Market value of debt | $10 million |\n|----------------------|-------------|\n| Market capitalization| $45 million |\n| Cash and short-term investments | $2.5 million |\n| EBITDA | $15 million |\n| Firm's marginal tax rate | 40% |"
        ],
        "python_solution": "def solution():\n    market_value_common_preferred_stock = 45\n    market_value_debt = 10\n    cash_short_term_investments = 2.5\n    EBITDA = 15\n    enterprise_value = market_value_common_preferred_stock + market_value_debt - cash_short_term_investments\n    EV_EBITDA = enterprise_value / EBITDA\n    return EV_EBITDA",
        "ground_truth": 3.5,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    market_value_of_debt = 10000000\n    market_capitalization = 45000000\n    cash_and_short_term_investments = 2500000\n    ebitda = 15000000\n    \n    # Calculate Enterprise Value (EV)\n    enterprise_value = market_value_of_debt + market_capitalization - cash_and_short_term_investments\n    \n    # Calculate the EV/EBITDA multiple\n    ev_ebitda_multiple = enterprise_value / ebitda\n    \n    # return answer\n    return ev_ebitda_multiple\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program will calculate and return the EV/EBITDA multiple of the business using the provided data."
        ]
    },
    {
        "question_id": "validation-94",
        "question": "What is the present value (PV) of $5,000 that will be received three years from now, applying a 5% discount rate, compounded monthly?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 5000\n    r = 0.05\n    m = 12\n    N = 3\n    PV = FV * (1 + r/m) ** (-m*N)\n    return PV",
        "ground_truth": 4304.881,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    future_value = 5000  # Future value of the cash to be received\n    discount_rate = 0.05  # Annual discount rate\n    periods = 3 * 12  # Total number of periods in months\n\n    # The formula for the present value of a future sum of money is:\n    # PV = FV / (1 + r/n)^(nt)\n    # where\n    # PV = present value\n    # FV = future value\n    # r = annual interest rate (as a decimal)\n    # n = number of times the interest is compounded per year\n    # t = number of years\n\n    # Apply the present value formula for compound interest\n    present_value = future_value / ((1 + (discount_rate / 12)) ** periods)\n    \n    # return answer\n    return present_value\n\n# As a check, uncomment the following line to print the result\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-95",
        "question": "The chief financial officer of a manufacturing firm based in the UK, Susan Sullivan, gathers the exchange rates from Dealer B as given in Exhibit 1. The company will receive EUR 5,000,000 from a different client in three months. Half a year ago, the firm traded EUR 5,000,000 for GBP using a forward contract of nine months at an inclusive price of GBP/EUR 0.7400. Considering Exhibits 1 and 2, what would be the mark-to-market gain for Sullivan's forward position if the position is marked to the market by gathering the GBP/EUR forward rates displayed in Exhibit 2?",
        "tables": [
            "| Currency Pair (Price/Base) | Bid    | Offer  | Midpoint |\n|----------------------------|--------|--------|----------|\n| JPY/GBP                    | 187.39 | 187.43 | 187.41   |\n| MXN/USD                    | 17.147 | 17.330 | 17.239   |\n| GBP/EUR                    | 0.7342 | 0.7344 | 0.7343   |\n| USD/EUR                    | 1.1572 | 1.1576 | 1.1574   |\n| USD/GBP                    | 1.5762 | 1.5766 | 1.5764   |",
            "|          |                        |\n|----------|------------------------|\n|Exhibit 2. GBP/EUR Forward Rates||\n| Maturity   | Forward Points  |\n| One month  | 4.40/4.55       |\n| Three months| 14.0/15.0      |\n| Six months  | 29.0/30.0       |\n|          | the GBP 90- day Libor = 0.5800%|"
        ],
        "python_solution": "def solution():\n    spot_rate = 0.7344\n    forward_points = 15/10000\n    three_month_forward_rate = spot_rate + forward_points\n    contract_rate = 0.7400\n    eur_amount = 5000000\n    libor_rate = 58/100\n\n    net_cash_flow = eur_amount * (contract_rate - three_month_forward_rate)\n    mark_to_market_gain = net_cash_flow / ((1 + libor_rate/100)**(3/12))\n\n    return mark_to_market_gain",
        "ground_truth": 20470.382,
        "topic": "Market Analysis & Economics",
        "output": [
            "Here is a Python program to calculate the mark-to-market gain for Susan Sullivan's forward position:\n\n```python\ndef solution():\n    # Define variables name and value\n    forward_contract_amount_eur = 5000000\n    forward_contract_price_gbp_eur = 0.7400\n    \n    # Exhibit 2: Three months forward points for GBP/EUR\n    forward_points_bid = 14.0\n    forward_points_offer = 15.0\n    \n    # Convert the forward points to a decimal to be added to the spot bid/offer\n    forward_points_bid /= 10000\n    forward_points_offer /= 10000\n    \n    # Current spot bid/offer for GBP/EUR from Exhibit 1\n    spot_bid = 0.7342\n    spot_offer = 0.7344\n    \n    # Calculate three months forward bid/offer rates by adding the forward points to the spot bid/offer\n    three_months_forward_bid = spot_bid + forward_points_bid\n    three_months_forward_offer = spot_offer + forward_points_offer\n    \n    # Choose the appropriate rate for valuing the contract (since Sullivan is selling EUR, use the bid rate)\n    current_market_rate = three_months_forward_bid\n    \n    # Calculate the original forward contract value and the current market value in GBP\n    original_forward_value_gbp = forward_contract_amount_eur * forward_contract_price_gbp_eur\n    current_market_value_gbp = forward_contract_amount_eur * current_market_rate\n    \n    # Calculate the mark-to-market gain or loss\n    mark_to_market_gain = current_market_value_gbp - original_forward_value_gbp\n    \n    # return answer\n    return mark_to_market_gain\n```"
        ]
    },
    {
        "question_id": "validation-96",
        "question": "What is the share value of REIT B using valuation Method 4, according to Exhibits 1 and 2?",
        "tables": [
            "| Property subsector          | REIT A Office | REIT B Storage | REIT C Health Care |\n|-----------------------------|---------------|----------------|--------------------|\n| Estimated 12 months cash net operating income (NOI) | $ 350,000    | $ 267,000        | $ 425,000            |\n| Funds from operations (FFO)   | $ 316,965    | $ 290,612        | $ 368,007            |\n| Cash and equivalents         | $ 308,700    | $ 230,850        | $ 341,000            |\n| Accounts receivable         | $ 205,800    | $ 282,150        | $ 279,000            |\n| Debt and other liabilities   | $ 2,014,000  | $ 2,013,500    | $ 2,010,000          |\n| Non-cash rents             | $ 25,991     | $ 24,702        | $ 29,808             |\n| Recurring maintenance-type capital  expenditures | $ 63,769     | $ 60,852        | $ 80,961             |\n| Shares  outstanding        | 56,100       | 67,900          | 72,300              |"
        ],
        "python_solution": "def solution():\n    FFO = 316965\n    non_cash_rents = 25991\n    recurring_maintenance_capex = 63769\n    shares_outstanding = 56100\n    P_AFFO_multiple = 18.3\n\n    AFFO = FFO - non_cash_rents - recurring_maintenance_capex\n    AFFO_per_share = AFFO / shares_outstanding\n    share_value = AFFO_per_share * P_AFFO_multiple\n\n    return share_value",
        "ground_truth": 74.115,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the share value of REIT B using valuation Method 4, we need to follow the cash available for distribution (CAD) approach described in \"Exhibits 1 and 2\", which is essentially the calculation for adjusted funds from operations (AFFO). Although the full description of Method 4 is not given, the AFFO is typically calculated by starting with funds from operations (FFO) and subtracting recurring maintenance-type capital expenditures and non-cash rents.\n\nLet's implement the solution:\n\n```python\ndef solution():\n    # Define variables name and value\n    ffo_reit_b = 290612\n    recurring_maintenance_reit_b = 60852\n    non_cash_rents_reit_b = 24702\n    shares_outstanding_reit_b = 67900\n\n    # Calculate the Adjusted Funds From Operations (AFFO) for REIT B\n    affo_reit_b = ffo_reit_b - recurring_maintenance_reit_b - non_cash_rents_reit_b\n\n    # Calculate the share value of REIT B using AFFO\n    share_value_reit_b = affo_reit_b / shares_outstanding_reit_b\n    \n    # return answer\n    return share_value_reit_b\n\n# Call the function and print the result\nprint(solution())\n```\n\nWhen you run the above code, it should return the share value for REIT B according to the provided information and the presumed calculation method of AFFO."
        ]
    },
    {
        "question_id": "validation-97",
        "question": "Firms A and B start the year with the same book value of equity and identical tax rate. They have identical operations throughout the year and record all operations similarly except for one. Both firms purchase a printer worth £300,000 with a three-year useful life and no salvage value on 1st January of the new year. Firm A capitalizes the printer and it undergoes straight-line depreciation, while Firm B expenses the printer. The following year-end data is collected for Firm A. Based on this information, what would Firm B’s return on equity be using year-end equity with the ending shareholders’ equity being £10,000,000, a tax rate of 25%, £0.00 in dividends, and a net income of £750,000?",
        "tables": [],
        "python_solution": "def solution():\n    A_net_income = 750000\n    A_equity = 10000000\n    B_net_income = A_net_income - 150000 # B company has larger expense, hence the lower net income\n    B_equity = A_equity - 150000 # B company has lower net income, hence the lower equity\n    B_ROE = B_net_income / B_equity\n    return B_ROE * 100",
        "ground_truth": 6.091,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Given data for Firm A\n    printer_cost = 300000\n    useful_life = 3\n    tax_rate = 0.25\n    net_income_A = 750000\n    dividends_A = 0\n    ending_equity_A = 10000000\n\n    # Depreciation for Firm A (since it capitalizes the printer)\n    depreciation_A = printer_cost / useful_life\n\n    # Calculate taxable income for Firm A\n    taxable_income_A = net_income_A / (1 - tax_rate)\n\n    # Add back depreciation to get pre-tax income before depreciation\n    pre_tax_income_before_depreciation_A = taxable_income_A + depreciation_A\n    \n    # Calculate Firm B's pre-tax income (which would be the same, \n    # but without depreciation since they expense the printer)\n    pre_tax_income_before_depreciation_B = pre_tax_income_before_depreciation_A\n    \n    # Since Firm B expenses the printer, the expense will reduce the pre-tax income in the first year\n    pre_tax_income_B = pre_tax_income_before_depreciation_B - printer_cost\n    \n    # Calculate the net income for Firm B after tax\n    net_income_B = pre_tax_income_B * (1 - tax_rate)\n    \n    # Firm B's ending equity will be the same as Firm A's as they start with the same book value and operations\n    ending_equity_B = ending_equity_A\n    \n    # Calculate return on equity for Firm B\n    return_on_equity_B = net_income_B / ending_equity_B\n    \n    # return answer\n    return return_on_equity_B\n\n# Call the function and print result\nresult = solution()\nprint(f\"Firm B’s return on equity: {result}\")\n```\n\nWhen you run the function `solution()` it will calculate Firm B's return on equity based on the provided data and the explanation above."
        ]
    },
    {
        "question_id": "validation-98",
        "question": "As an arbitrage trader, Bob wishes to determine the continuous implied dividend yield of a stock. He is studying the over-the-counter price of a five-year European put and call on this particular stock. The data he has includes: S = $85, K = $90, r = 5%, c = $10, p = $15. What would be the implied dividend yield of the stock?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    \n    S = 85  # The stock is currently trading at\n    K = 90  # The strike price of the option\n    r = 5/100  # Interest rate\n    c = 10  # Price of a call option\n    p = 15  # Price of a put option\n    tau = 5  # time to maturity (in years)\n\n    S_tau = c - p + K * math.exp(-r * tau)  # From put-call parity\n    y = -1/tau * math.log(S_tau / S)  # Dividend yield\n\n    return y*100  # convert it to percentage and return",
        "ground_truth": 5.337,
        "topic": "Market Analysis & Economics",
        "output": [
            "To solve this problem, you can use the put-call parity for European options on stocks that pay continuous dividends. The put-call parity equation is given by:\n\n\\[ c + K e^{-rT} = p + S e^{-qT} \\]\n\nwhere:\n- \\( c \\) is the price of the European call option\n- \\( p \\) is the price of the European put option\n- \\( K \\) is the strike price of the options\n- \\( r \\) is the risk-free interest rate, expressed as a decimal (5% is written as 0.05)\n- \\( T \\) is the time to maturity (in years)\n- \\( S \\) is the current stock price\n- \\( q \\) is the continuous dividend yield\n\nWe need to solve for \\( q \\) given the rest of the data. Bob has all the information except the dividend yield \\( q \\) and \\( T \\), the time to maturity for the options, which is five years. We'll rearrange the equation to solve for \\( q \\) and calculate it using Python.\n\nHere is the Python program to calculate the implied dividend yield:\n\n```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    S = 85  # Current stock price\n    K = 90  # Strike price\n    r = 0.05  # Risk-free interest rate\n    c = 10  # European call option price\n    p = 15  # European put option price\n    T = 5  # Time to maturity (in years)\n    \n    # Rearrange the put-call parity equation to solve for q:\n    # c + K * e^(-rT) - p = S * e^(-qT)\n    # Take the natural log of both sides and solve for q:\n    # ln(c + K * e^(-rT) - p) - ln(S) = -qT\n    # q = -(ln(c + K * e^(-rT) - p) - ln(S)) / T\n    \n    q = -(math.log(c + K * math.exp(-r * T) - p) - math.log(S)) / T\n    \n    # return answer\n    return q\n    \n# Call the function and print the result\nprint(f\"The implied dividend yield of the stock is: {solution()}\")\n```\n\nRunning this Python program will give you the implied continuous dividend yield for the stock."
        ]
    },
    {
        "question_id": "validation-99",
        "question": "The Novartis Company noted a notable rise in its profitability, which led to a material increase in its credit score. Consequently, the market demanded a 100 basis point tighter spread to Gilts on Novartis's 8-year bond. In case the bond's altered duration is 6.0 and its convexity is 55.0, what would be the effect of this change on the return?",
        "tables": [],
        "python_solution": "def solution():\n    modified_duration = 6.0\n    delta_spread = -0.01\n    convexity = 55.0\n\n    return_impact = -(modified_duration * delta_spread) + 0.5 * convexity * (delta_spread**2)\n    return return_impact*100",
        "ground_truth": 6.275,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define the basis point change and convert to decimal\n    basis_point_change = -100\n    change_in_decimal = basis_point_change / 10000\n    \n    # Altered duration in years and convexity\n    duration = 6.0\n    convexity = 55.0\n    \n    # Calculate the change in price using duration and convexity\n    # The formula for bond price change is: ΔP ≈ -D * Δy + 1/2 * C * (Δy)^2\n    # where ΔP is change in price, D is duration, Δy is yield change, and C is convexity.\n    price_change_approximation = (-duration * change_in_decimal) + (1/2 * convexity * (change_in_decimal ** 2))\n    \n    # As the question asks for the effect on the return, and the sign is opposite to yield (when yield decreases, return increases)\n    # We would return a positive change\n    effect_on_return = price_change_approximation * 100  # Convert to percent\n    \n    # Return the answer\n    return effect_on_return\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-100",
        "question": "A company debt security provides a coupon rate of 5% and only has 3 years left until it matures. The interest is given yearly. The benchmark spot curve currently lists a series of rates. Right now, the bond is trading at a Z-spread of 234 basis points. What's the bond's worth?",
        "tables": [
            "| Time-to-Maturity | Spot Rate |\n|------------------|-----------|\n| 1 year           | 4.86%     |\n| 2 years          | 4.95%     |\n| 3 years          | 5.65%     |"
        ],
        "python_solution": "def solution():\n    PMT = 5\n    FV = 100\n    S1 = 0.0486\n    S2 = 0.0495\n    S3 = 0.0565\n    Z = 0.0234\n\n    PV1 = PMT / ((1 + S1 + Z)**1)\n    PV2 = PMT / ((1 + S2 + Z)**2)\n    PV3 = (PMT + FV) / ((1 + S3 + Z)**3)\n\n    return PV1 + PV2 + PV3",
        "ground_truth": 92.383,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the bond's worth, we need to discount each of the bond's cash flows at the spot rates plus the Z-spread. The bond pays an annual coupon, so we will have three cash flows to discount: two coupon payments and the final coupon payment plus principal at maturity.\n\n```python\ndef solution():\n    \n    # Coupon rate and Z-spread provided\n    coupon_rate = 0.05  # 5%\n    z_spread = 0.0234  # 234 basis points converted to decimal\n    principal = 100  # assuming a par value of 100 as this is standard\n    \n    # Spot rates for 1, 2, and 3 years\n    spot_rates = [0.0486, 0.0495, 0.0565]\n    \n    # Calculate the bond's present value\n    bond_value = 0\n    for i in range(1, 4):\n        # Calculate the cash flow (coupon payment or coupon + principal)\n        cash_flow = coupon_rate * principal if i < 3 else (coupon_rate + 1) * principal\n        # Spot rate for the year plus the Z-spread\n        discount_rate = spot_rates[i - 1] + z_spread\n        # Present value of the cash flow\n        present_value = cash_flow / (1 + discount_rate) ** i\n        \n        # Add the present value to the total bond value\n        bond_value += present_value\n    \n    # return answer\n    return round(bond_value, 2)  # Rounding off to two decimal places for currency values\n\n# Output the result\nprint(f\"The bond's worth is: {solution()}\")\n```\n\nThe `solution()` function calculates the discounted cash flow for each year and then sums them up to find the total value of the bond. The `round()` function is used to round off the answer to two decimal places as it represents a financial value."
        ]
    },
    {
        "question_id": "validation-101",
        "question": "What is the expected return for XYZ Company if its stock has a beta of 0.65, the risk-free rate of return is 3% and the expected market return is 9%?",
        "tables": [],
        "python_solution": "def solution():\n    beta = 0.65\n    risk_free_rate = 0.03\n    expected_market_return = 0.09\n\n    expected_return = risk_free_rate + beta * (expected_market_return - risk_free_rate)\n    return expected_return",
        "ground_truth": 0.069,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Here is a Python program that calculates the expected return for XYZ Company using the Capital Asset Pricing Model (CAPM):\n\n```python\ndef solution():\n    # Define variables name and value\n    beta = 0.65\n    risk_free_rate = 0.03\n    market_return = 0.09\n    \n    # Do math calculation to get the answer\n    # CAPM formula: Expected Return = Risk-Free Rate + (Beta * (Market Return - Risk-Free Rate))\n    expected_return = risk_free_rate + (beta * (market_return - risk_free_rate))\n    \n    # return answer\n    return expected_return\n\n# Example usage:\n# print(solution())\n```\n\nPlease note that you can uncomment the `print(solution())` line to run the function and see the expected return as output."
        ]
    },
    {
        "question_id": "validation-102",
        "question": "A researcher collects the following data on a bond: Roughly modified duration 10.3829 and roughly modified convexity 141.217. What is the projected percentage price alteration for the bond should the yield to maturity fall by 50 bps?",
        "tables": [],
        "python_solution": "def solution():\n    MD = 10.3829\n    Convexity = 141.217\n    Delta_Yield= -0.005\n    Percentage_change_in_bond_price = ((-MD*Delta_Yield)+(0.5*Convexity*(Delta_Yield)**2))  \n    return Percentage_change_in_bond_price*100",
        "ground_truth": 5.368,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    duration = 10.3829\n    convexity = 141.217\n    delta_ytm = 0.0050  # 50 bps or 0.50% change in yield to maturity\n    \n    # Use the duration and convexity to estimate the price change\n    estimated_price_change = (-duration * delta_ytm) + (0.5 * convexity * (delta_ytm ** 2))\n    \n    # Convert to percentage\n    estimated_price_change_percent = estimated_price_change * 100\n    \n    # Return answer\n    return estimated_price_change_percent\n    \n# You can uncomment the following line to test the function\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-103",
        "question": "Currently, Serene Vacation Corp has 1.2 million common shares of stock outstanding with a beta of 2.2. They also have $10 million face value of bonds with five years left to maturity and an 8% coupon with semiannual payments, priced to yield 13.65%. If Serene issues up to $2.5 million of new bonds, they will be priced at par and will have a yield of 13.65%; but if they issue bonds beyond $2.5 million, the entire issuance is expected to yield 16%. Serene has found out it can issue new common stock at $10 a share. The current risk-free interest rate is 3%, and the expected market return is 10%. Serene's marginal tax rate is 30%. If Serene secures $7.5 million of new funding while keeping the same debt-to-equity ratio, what will its weighted average cost of capital be?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 10000000\n    PMT = 400000\n    N = 10\n    I_YR = 6.825/100\n    PV = FV / ((1 + I_YR)**N)\n    Equity = 1.2 * 1000000 * 10\n    to_be_raised = 7.5 * 1000000\n    bonds = to_be_raised * 0.4\n    rd = 0.16\n    t = 0.3\n    re = 0.03 + 2.2 * (0.10 - 0.03)\n    rdnt = rd * (1 - t)\n    WACC = 0.4 * rdnt + 0.6 * re\n    return WACC*100",
        "ground_truth": 15.52,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "To answer this question, we need to calculate the weighted average cost of capital (WACC) considering the new funding of $7.5 million while maintaining the same debt-to-equity ratio. This involves calculating the cost of equity, cost of new debt, and cost of existing debt and combining these with the weight of equity and debt in Serene's capital structure.\n\nWe will use the Capital Asset Pricing Model (CAPM) to calculate the cost of equity, and we will use the given yields to calculate the cost of debt. Because interest payments are tax-deductible on the corporate tax return, the after-tax cost of debt equals the pre-tax cost of debt multiplied by (1 - tax rate).\n\nHere's how you could write the program to calculate the WACC:\n\n```python\n# Import package if needs\ndef solution():\n    # Define variables name and value\n    common_shares_outstanding = 1.2e6\n    stock_price = 10\n    beta = 2.2\n    face_value_bonds = 1e7\n    coupon_rate = 0.08\n    yield_to_maturity_old = 0.1365\n    yield_to_maturity_new = 0.1365\n    yield_to_maturity_additional = 0.16\n    new_bond_issue_limit = 2.5e6\n    risk_free_rate = 0.03\n    market_return = 0.10\n    tax_rate = 0.3\n    new_funding = 7.5e6\n    \n    # Calculate the cost of equity using the Capital Asset Pricing Model (CAPM)\n    cost_of_equity = risk_free_rate + beta * (market_return - risk_free_rate)\n    \n    # Calculate the cost of existing debt\n    cost_of_existing_debt = coupon_rate * 2 * (face_value_bonds / (face_value_bonds * (1 + yield_to_maturity_old/2)**(2*5)))  # Semiannual payments\n    cost_of_existing_debt_after_tax = cost_of_existing_debt * (1 - tax_rate)\n    \n    # Calculate the current market value of equity\n    equity_value = common_shares_outstanding * stock_price\n    \n    # Calculate the cost of additional debt\n    if new_funding <= new_bond_issue_limit:\n        cost_of_new_debt = yield_to_maturity_new\n    else:\n        cost_of_new_debt = yield_to_maturity_additional\n    cost_of_new_debt_after_tax = cost_of_new_debt * (1 - tax_rate)\n    \n    # Calculate the total market value of debt\n    debt_value = face_value_bonds * (1+yield_to_maturity_old/2)**(2*5) + new_funding\n    \n    # Calculate the weights of equity and debt\n    total_value = equity_value + debt_value\n    weight_of_equity = equity_value / total_value\n    weight_of_debt = debt_value / total_value\n    \n    # Calculate the weighted average cost of capital (WACC)\n    wacc = (weight_of_equity * cost_of_equity) + (weight_of_debt * cost_of_new_debt_after_tax)\n    \n    # return answer\n    return round(wacc, 4)\n```\n\nThis function will return the WACC as a decimal value rounded to 4 decimal places. However, please note that some assumptions made in the calculation, such as the method of computing the cost of existing debt and the linear interpolation for the cost of new debt, may not fully align with actual financial practice and would require more complex modeling."
        ]
    },
    {
        "question_id": "validation-104",
        "question": "The time-to-maturity for Bond D is 3 years and it has a coupon rate of 8%. The annual payments of interest can be seen. Given the depicted spot rates, what would be the price of Bond D using these spot rates?",
        "tables": [
            "| Time-to-Maturity | Spot rates |\n|-----------------|------------|\n| 1-year            | 7%             |\n| 2-year            | 8%             |\n| 3-year            | 9%             |"
        ],
        "python_solution": "def solution():\n    PMT = 8\n    Par = 100\n    S1 = 0.07\n    S2 = 0.08\n    S3 = 0.09\n    PV = PMT/(1+S1) + PMT/((1+S2)**2) + (PMT+Par)/((1+S3)**3)\n    return PV",
        "ground_truth": 97.731,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is a Python program that calculates the price of Bond D using the provided spot rates:\n\n```python\ndef solution():\n    # Define variables name and value\n    face_value = 1000           # Assuming a typical face value for the bond\n    coupon_rate = 0.08          # Given 8% coupon rate\n    spot_rates = [0.07, 0.08, 0.09]  # Provided spot rates for 1-year, 2-year, and 3-year\n    \n    # Initialize the price of the bond\n    price = 0\n  \n    # Calculate present value of each coupon payment and the face value\n    for year in range(1, 4):\n        coupon_payment = face_value * coupon_rate  # Annual coupon payment\n        discount_factor = (1 + spot_rates[year - 1]) ** year  # Discount factor for each year\n        present_value = coupon_payment / discount_factor\n        price += present_value  # Sum up the present value of the coupon payments\n    \n    # Add the present value of the face value, discounted at the spot rate for year 3\n    price += face_value / ((1 + spot_rates[2]) ** 3)\n    \n    # return price\n    return round(price, 2)  # Rounding to 2 decimal places for currency format\n\n# Print the calculated price of Bond D\nprint(solution())\n```\n\nThis program first initializes the presumed face value of the bond, which is typically \\$1000, and then uses this face value along with the coupon rate and spot rates to calculate the present value of each annual coupon payment and the face value, adding these to compute the total bond price. It then returns the calculated price, rounded to two decimal places."
        ]
    },
    {
        "question_id": "validation-105",
        "question": "Working at the Equity investment company, Jessica, a CFA, noted that Clearwater Primary School had spent ¥360 million to acquire a 50 percent stake in Snowflake Early Learning Center on 31 December 2018. The surplus of the acquisition cost over the net assets' fair value of Snowflake was due to previously unregistered licenses. These licenses were estimated to possess an economic lifespan of five years. The value of Snowflake's assets and liabilities, excluding licenses, were equivalent to their documented book value. Clearwater and Snowflake's summarized income statements for the year ending 31 December 2018, and Balance Sheet are presented in the subsequent table: Assuming that both companies' 2019 figures mirror those of 2018 and Clearwater has command over Snowflake, what would be Clearwater’s consolidated depreciation and amortization expense for 2019?",
        "tables": [
            "|                          | Golden | Frost |\n|--------------------------|--------|-------|\n| Revenue                  | 380    | 460   |\n| Cost of goods sold       | (320)  | (210) |\n| Administrative expenses  | (110)  | (65)  |\n| Depreciation & amortization expense | (106)  | (85)  |\n| Interest expense         | (36)  | (18)   |\n| Income before            | 308    | 82    |\n| Income tax expense       | (125)  | (29)  |\n| Net income               | 183    | 53    |",
            "|                             | Golden | Frost |\n|-----------------------------|--------|-------|\n| Cash                        | 80     | 60    |\n| Account receivable          | 110    | 90    |\n| Inventory                   | 210    | 130   |\n| Total current assets        | 400    | 280   |\n| PP&E                        | 1220   | 770   |\n| Investment in Frost         | 360    | N/A   |\n| Total assets                | 1,980  | 1,050 |\n| Current liabilities         | 130    | 95    |\n| Long-term debt              | 520    | 390   |\n| Total liabilities           | 650    | 485   |\n| Common stock                | 810    | 500   |\n| Retained earnings           | 520    | 65    |\n| Total equity                | 1,330  | 565   |"
        ],
        "python_solution": "def solution():\n    unrecorded_licenses_value = 155\n    lifetime_of_unrecorded_licenses = 5\n    depreciation_of_unrecorded_licenses = unrecorded_licenses_value / lifetime_of_unrecorded_licenses\n    depreciation_and_amortization_of_Clearwater = 106\n    depreciation_and_amortization_of_Snowflake = 85\n    consolidated_depreciation_and_amortization = depreciation_and_amortization_of_Clearwater + depreciation_and_amortization_of_Snowflake + depreciation_of_unrecorded_licenses\n    return consolidated_depreciation_and_amortization",
        "ground_truth": 222.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    golden_depreciation_amortization = 106\n    frost_depreciation_amortization = 85\n    \n    # Acquisition cost in millions of yen\n    acquisition_cost = 360\n    \n    # Share of the acquisition by Golden (since Golden is Clearwater and Frost is Snowflake)\n    golden_share = 0.5\n    \n    # Economic lifespan of licenses in years\n    license_lifespan = 5\n    \n    # Calculate the annual amortization of the licenses\n    annual_amortization_licenses = (acquisition_cost * golden_share) / license_lifespan\n    \n    # Calculate the total consolidated depreciation and amortization expense\n    # Golden (Clearwater) fully consolidates Frost (Snowflake), so Golden's depreciation is already included\n    # Add the new amortization for 2019\n    consolidated_depreciation_amortization = golden_depreciation_amortization + annual_amortization_licenses\n    \n    # return answer\n    return consolidated_depreciation_amortization\n\n# The function call \nsolution()\n```\n\nNote: In practice, the calculation of depreciation and amortization would require more detailed information, especially regarding the individual assets and their respective depreciation schedules. This example assumes that the only adjustment needed for consolidation is the addition of the amortization of the licenses acquired in the investment."
        ]
    },
    {
        "question_id": "validation-106",
        "question": "The table below provides details about a zero-coupon bond. Using this table, can you identify the key rate '01 for a shift of 10 years?",
        "tables": [
            "|                  | Value  |\n|------------------|--------|\n| Initial Value    | 87.1876|\n| 2-year shift for 1bp    | 87.3212|\n| 5-year shift for 1bp    | 87.2545|\n| 10-year shift for 1bp   | 87.1454|\n| 30-year shift for 1bp   | 87.3454|"
        ],
        "python_solution": "def solution():\n    ten_year_shift_for_1_bp = 87.1454\n    initial_value = 87.1876\n    key_rate_01_for_10_year_shift = -(ten_year_shift_for_1_bp - initial_value)\n    return key_rate_01_for_10_year_shift",
        "ground_truth": 0.042,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "In the given table, \"shift for 1bp\" means how much the initial value of something changes for a 1 basis point (0.01%) shift in the interest rate for a certain maturity. For a zero-coupon bond, key rate duration ('01) measures the sensitivity of a bond's price to a 1 basis point (0.01%) change in yield for a specific maturity. It's a measure of interest rate risk.\n\nThe key rate '01 for a shift of 10 years is the change in the value of the bond when the interest rate for the 10-year maturity shifts by 1 basis point. The initial value is provided as 87.1876, and the value after a 10-year shift for 1bp is 87.1454.\n\nTo find the key rate '01 for the 10-year shift, we will calculate the difference between the initial value and the value after the 10-year shift and adjust for the 1 basis point move. The formula is:\n\n`Key Rate '01 = (Initial Value - Value after shift) / Basis Point Change`\n\nHere is the Python program to calculate the key rate '01 for a shift of 10 years:\n\n```python\ndef solution():\n    # Define variables name and value\n    initial_value = 87.1876\n    value_10yr_shift_1bp = 87.1454\n    basis_point_change = 0.01  # 1 basis point\n    \n    # Calculate change in value for the 10-year shift\n    change_in_value = initial_value - value_10yr_shift_1bp\n    \n    # Calculate the key rate '01 for 10-year shift\n    key_rate_01_10yr = change_in_value / basis_point_change\n    \n    # return answer\n    return key_rate_01_10yr\n\n# Example usage:\n# print(solution())\n```\n\nThe program defines the initial bond value and the value after a 10-year shift for a 1 basis point change. It then calculates and returns the key rate '01."
        ]
    },
    {
        "question_id": "validation-107",
        "question": "A financial expert predicts that 20% of high-risk bonds will go bankrupt. When he uses a bankruptcy prediction model, he finds that 70% of these bonds will be deemed as \"good\", suggesting a lower risk of failure. Of the bonds that went bankrupt, only 50% were rated as \"good\". Use Bayes' formula to estimate the likelihood of going bankrupt bearing a \"good\" rating. (Hint, let P(A) be the likelihood of bankruptcy, P(B) be the probability of a \"good\" rating, P(B | A) be the probability of a \"good\" rating given bankruptcy, and P(A | B) be the likelihood of bankruptcy given a \"good\" rating.)",
        "tables": [],
        "python_solution": "def solution():\n    P_A = 0.20 # probability of failure\n    P_B = 0.70 # probability of a \"good\" rating\n    P_B_A = 0.50 # probability of a \"good\" rating given failure\n\n    P_A_B = (P_B_A * P_A) / P_B # probability of failure given a \"good\" rating\n\n    return P_A_B",
        "ground_truth": 0.143,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    P_A = 0.20  # Probability of bankruptcy\n    P_B = 0.70  # Probability of a \"good\" rating\n    P_B_given_A = 0.50  # Probability of a \"good\" rating given bankruptcy\n    \n    # Applying Bayes' theorem:\n    # P(A | B) = P(B | A) * P(A) / P(B)\n    P_A_given_B = (P_B_given_A * P_A) / P_B\n    \n    # return answer\n    return P_A_given_B\n```"
        ]
    },
    {
        "question_id": "validation-108",
        "question": "If a customer needs £100,000 a year from now and the declared yearly rate is 2.50% compounded on a weekly basis, what amount should be deposited today?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 100000\n    r = 0.025\n    m = 52\n    N = 1\n    PV = FV * (1 + r/m) ** (-m*N)\n    return int(PV)",
        "ground_truth": 97531.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Import package if needed\nimport math\n\ndef solution():\n    # Define variables name and value\n    future_value = 100000  # Future value needed by the customer\n    interest_rate = 0.025  # Annual interest rate\n    compounding_periods = 52  # Compounded weekly\n    \n    # Convert annual interest rate to weekly interest rate\n    weekly_interest_rate = interest_rate / compounding_periods\n    \n    # Calculate number of compounding periods (weeks in a year)\n    number_of_periods = compounding_periods\n    \n    # Do math calculation to determine the present value\n    present_value = future_value / ((1 + weekly_interest_rate) ** number_of_periods)\n    \n    # return answer\n    return round(present_value, 2)\n\n# This will print the amount that should be deposited today\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-109",
        "question": "Based on Exhibit 1 and Zhang's beliefs about recurring costs, what is the trailing P/E she calculated for Cratt Ltd?",
        "tables": [
            "|      | 31 December 2017 | 31 December 2016 |\n|------|------------------|------------------|\n| EPS  | $1.03            | $0.89            |\n| Core EPS* | $1.31       | $1.01            |",
            "\n|                                                                                               |\n|------------------------------------------------------------------------------------------------|\n| Core EPS is a non-GAAP measure that excludes acquisition charges of                           |\n| $0.18 and $0.12 in 2017 and 2016, respectively, as well as $0.10 in 2017                      |\n| related to the settlement of a lawsuit.                                                       |\n"
        ],
        "python_solution": "def solution():\n    stock_price = 11.31\n    recurring_eps = 1.03 + 0.10\n    trailing_pe = stock_price / recurring_eps\n    return trailing_pe",
        "ground_truth": 10.009,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "In order to calculate the trailing P/E (Price to Earnings) ratio, we need two pieces of information: the price per share of the company's stock (the \"P\" in P/E) and the earnings per share (the \"E\" in P/E). The earnings per share (EPS) can be based on the last 12 months (trailing EPS) or on the projected earnings for the next 12 months (forward EPS). \n\nIn this task, the information provided includes only the EPS for two different years (2017 and 2016) and the adjusted Core EPS, which removes certain acquisition charges and a lawsuit settlement from the EPS. We are not given the price of the stock, which is necessary to calculate the P/E ratio.\n\nSince the stock price is not provided, we can't calculate the trailing P/E ratio. However, if you provide the stock price data, we can calculate the P/E using 2017's Core EPS. For the sake of completing the requested Python program structure, I'm going to leave a placeholder for the stock price variable, which should be replaced with the actual stock price data to get the trailing P/E ratio.\n\n```python\ndef solution(stock_price):\n    # Define variables name and value\n    core_eps = 1.31  # Core EPS for 2017\n    \n    # Do math calculation to get the trailing P/E\n    pe_ratio = stock_price / core_eps\n    \n    # return answer\n    return pe_ratio\n```\n\nThis function assumes that you have the stock price for Cratt Ltd as of 31 December 2017. For example, if the stock price was $50, you would call this function with `solution(50)` to get the trailing P/E ratio. Unfortunately, without the actual stock price data, we cannot calculate the exact P/E ratio."
        ]
    },
    {
        "question_id": "validation-110",
        "question": "Given the 2017 and 2018 financial reports provided by the firm, how does Jacques assess the Free Cash Flow to Equity (FCFE) of PZ Inc. for 2018, measured in millions?",
        "tables": [
            "\n|   |   | 2018 |   | 2017 |\n|---|---|------|---|------|\n|   |   |      |   |      |\n| Assets  |   |      |   |      |\n| Current assets |   |      |   |      |\n| Accounts receivable |   | 800  |   | 750  |\n| Inventories |   | 850  |   | 720  |\n| Gross fixed assets |   | 5000 |   | 4250 |\n| Accounts payable |   | $400  |   | $300 |\n| Accrued taxes and expenses  |  | 120  |   | 90  |\n| Notes payable  |  | 550  |   | 500  |\n| Long-term debt  |  | 1,500  |   | 1,400  |\n| Income Statement for the Year Ended 31 December 2018 |   |      |   |      |\n| EBITDA  |  |    |   | 2000 |\n| Depreciation expense  |   |    |   | 400 |\n| EBIT  |  |    |   | 1600 |\n| Interest expense  |  |    |   | 350 |\n| Pretax income  |  |    |   | 1250 |\n| Income tax (at 30 percent)  |  |    |   | 375 |\n| Net income  |   |    |   | $875 |\n"
        ],
        "python_solution": "def solution():\n    NI = 875 \n    NCC = 400 \n    FCInv = 750 \n    WCInv = 50 \n    Net_borrowing = 150 \n\n    FCFE = NI + NCC - FCInv - WCInv + Net_borrowing\n    return FCFE",
        "ground_truth": 625.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the Free Cash Flow to Equity (FCFE) for PZ Inc. for the year 2018, we need to undertake the following steps:\n\n1. Calculate Net Income for 2018: We have the Net Income for 2017 as $875 million. However, we need the Net Income value for 2018 which is not provided directly. \n\n2. Calculate Net Capital Expenditure (Net CapEx): This is the difference in Gross Fixed Assets between the two years plus the depreciation for 2018. The depreciation expense has been provided for 2017, but we'll assume it remains the same for 2018 unless told otherwise.\n\n3. Calculate the Change in Net Working Capital (Change in NWC): This is the difference in Current Assets (excluding Cash) minus the difference in Current Liabilities (excluding Short-Term Debt) between the two years. We'll need to estimate these values from the given data, making assumptions where necessary if complete data is not provided.\n\n4. Calculate the Net Borrowing: This is the difference in Long-term Debt plus the difference in Notes Payable between the two years.\n\nThe formula for calculating FCFE is given by:\nFCFE = Net Income - Net CapEx - Change in NWC + Net Borrowing\n\nSince Net Income for 2018 is not given, let's assume it has grown at the same rate from 2017 to 2018 as EBITDA from those years. EBITDA for 2018 can be deduced by adding the depreciation expense for 2018 (assuming it is the same as 2017 since it is not provided for 2018) to EBIT for 2018. Let's calculate EBITDA for 2018:\n\nEBITDA_2018 = EBIT_2018 + Depreciation_2018\n            = EBIT_2017 + (EBIT_2017 - EBITDA_2017) + Depreciation_2017\n            = 1600 + (1600 - 2000) + 400\n            = 1600 - 400 + 400\n            = 1600\n\nLet's implement these calculations in a Python program:\n\n```python\ndef solution():\n    # Define the given variables and calculate the missing ones\n    net_income_2017 = 875\n    accounts_receivable_2017 = 750\n    accounts_receivable_2018 = 800\n    inventories_2017 = 720\n    inventories_2018 = 850\n    gross_fixed_assets_2017 = 4250\n    gross_fixed_assets_2018 = 5000\n    depreciation_2017 = 400\n\n    accounts_payable_2017 = 300\n    accounts_payable_2018 = 400\n    accrued_taxes_and_expenses_2017 = 90\n    accrued_taxes_and_expenses_2018 = 120\n    notes_payable_2017 = 500\n    notes_payable_2018 = 550\n    long_term_debt_2017 = 1400\n    long_term_debt_2018 = 1500\n\n    # Calculate the growth rate in EBITDA\n    ebit_2017 = 1600\n    depreciation_2018 = depreciation_2017  # Assuming it remains constant\n    ebitda_2018 = ebit_2017\n\n    # Assuming Net Income grows at the same rate as EBITDA\n    net_income_growth_rate = (ebitda_2018 - (ebit_2017 - depreciation_2017)) / ebit_2017\n    net_income_2018 = net_income_2017 * (1 + net_income_growth_rate)\n\n    # Net Capital Expenditure\n    net_capex = (gross_fixed_assets_2018 - gross_fixed_assets_2017) + depreciation_2018\n\n    # Change in Working Capital\n    change_in_working_capital = ((accounts_receivable_2018 + inventories_2018) -\n                                 (accounts_receivable_2017 + inventories_2017)) - \\\n                                ((accounts_payable_2018 + accrued_taxes_and_expenses_2018) -\n                                 (accounts_payable_2017 + accrued_taxes_and_expenses_2017))\n\n    # Net Borrowing\n    net_borrowing = (long_term_debt_2018 - long_term_debt_2017) + (notes_payable_2018 - notes_payable_2017)\n\n    # FCFE calculation\n    fcfe = net_income_2018 - net_capex - change_in_working_capital + net_borrowing\n\n    # Return the FCFE\n    return fcfe\n\n# Call the function and print the result\nprint(f\"The FCFE for PZ Inc. for the year 2018 is: {solution()} million\")\n```\n\nPlease note that the above script uses several assumptions due to the lack of certain data, such as the depreciation for 2018 and the exact Net Income for 2018. In a real-world scenario, these would need to be known to accurately calculate FCFE."
        ]
    },
    {
        "question_id": "validation-111",
        "question": "The investment manager, Allen, recently took on a new client named Peter. Peter has two primary assets: human capital ($1,200,000) and financial capital ($600,000). He wishes for his total portfolio to have a 30% allocation to stocks. Assuming that human capital is considered to be 25% similar to stocks, what should be the appropriate equity allocation for Peter's financial capital?",
        "tables": [],
        "python_solution": "def solution():\n    human_capital = 1200000\n    financial_capital = 600000\n    stock_allocation_goal = 0.3\n    human_capital_stock_pct = 0.25\n\n    total_portfolio = human_capital + financial_capital\n    target_stock_percentage = total_portfolio * stock_allocation_goal\n\n    human_capital_stock_alloc = human_capital * human_capital_stock_pct\n\n    financial_capital_stock_alloc = target_stock_percentage - human_capital_stock_alloc\n\n    return financial_capital_stock_alloc",
        "ground_truth": 240000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    human_capital = 1200000\n    financial_capital = 600000\n    \n    # Human capital's portion that is similar to stocks\n    human_capital_stocks_similarity = 0.25\n    \n    # Total capital considering human capital's similarity to stocks\n    adjusted_human_capital = human_capital * human_capital_stocks_similarity\n    \n    # Total portfolio value considering adjusted human capital\n    total_portfolio_value = adjusted_human_capital + financial_capital\n    \n    # Overall desired stock allocation for the total portfolio\n    desired_stock_allocation = 0.30\n    \n    # Calculate the amount of stocks in the total portfolio\n    stocks_in_total_portfolio = total_portfolio_value * desired_stock_allocation\n\n    # Since part of human capital is already similar to stocks, subtract that amount\n    necessary_stocks_in_financial_capital = stocks_in_total_portfolio - adjusted_human_capital\n    \n    # Calculate the appropriate equity allocation for Peter's financial capital\n    equity_allocation_financial_capital = necessary_stocks_in_financial_capital / financial_capital\n    \n    # return answer\n    return equity_allocation_financial_capital\n\n# Calling the solution function and printing the result\nprint(solution())\n```\n\nThis program calculates the desired stock allocation in financial capital by adjusting human capital's similarity to stocks. It subtracts the amount of human capital considered as similar to stocks from the total desired stock allocation and determines the necessary equity allocation for the financial capital to achieve the overall portfolio stock allocation goal."
        ]
    },
    {
        "question_id": "validation-112",
        "question": "If a corporation switches from last-in, first-out (LIFO) to first-in, first-out (FIFO), how much higher would the net income (in $ thousands) for 2014 be, considering that the corporate tax rate for the current and all previous years has been 30% according to the data collected by a data analyst?",
        "tables": [
            "| ($ thousands)             |       | 2014 | 2013 |\n|---------------------------|-------|------|------|\n| Sales                     |       | 2125 | 2003 |\n| End of year inventories (LIFO) |       | 312  | 280  |\n| LIFO reserve              |       | 82   | 64   |\n| Net profit margin         |       | 4.9% | 4.0% |"
        ],
        "python_solution": "def solution():\n    net_profit_margin = 0.049\n    sales = 2125\n    tax_rate = 0.3\n    lifo_reserve_2014 = 82\n    lifo_reserve_2013 = 64\n\n    net_income_lifo = net_profit_margin * sales\n    change_in_lifo_reserve = lifo_reserve_2014 - lifo_reserve_2013\n    net_income_fifo = net_income_lifo + change_in_lifo_reserve * (1 - tax_rate)\n\n    increase_in_net_income = net_income_fifo - net_income_lifo\n\n    return increase_in_net_income",
        "ground_truth": 12.6,
        "topic": "Accounting",
        "output": [
            "To calculate how much higher the net income for 2014 would be if the corporation switches from LIFO to FIFO, we need to understand the effect of the LIFO reserve. The LIFO reserve is the difference between the inventory reported using LIFO and what it would have been reported using FIFO. An increase in the LIFO reserve from the previous year to the current year adds to the cost of goods sold (COGS) and thereby decreases the net income under LIFO.\n\nThe increase in LIFO reserve for 2014 is the difference between the 2014 and 2013 LIFO reserves.\n\nThen to calculate the net income effect, we add the increase in the LIFO reserve back to the net income for 2014, as it would not have been subtracted under FIFO. Since corporate tax rate is applied to profits, we must consider the tax effect on the increased LIFO reserve. \n\nHere's how the calculation is performed:\n\n```python\ndef solution():\n    # Define variables name and value\n    lifo_reserve_2014 = 82\n    lifo_reserve_2013 = 64\n    tax_rate = 0.30\n\n    # Calculate the increase in LIFO reserve\n    increase_in_lifo_reserve = lifo_reserve_2014 - lifo_reserve_2013\n    \n    # Adjust the increase by the tax rate to find the effect on net income\n    additional_net_income = increase_in_lifo_reserve * (1 - tax_rate)\n    \n    # return answer in $ thousands\n    return additional_net_income\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nLet's run this code block to find out how much higher the net income for 2014 would be if the corporation switched from LIFO to FIFO."
        ]
    },
    {
        "question_id": "validation-113",
        "question": "If the 1-year spot rate is 1.02%, the 2-year spot rate is 1.65% and the 3-year spot rate stands at 2.15%, how would you compute the 1-year implied forward rate two years in the future?",
        "tables": [],
        "python_solution": "def solution():\n    S2 = 1.65 / 100\n    S3 = 2.15 / 100\n    f21 = ((1+S3)**3 / (1+S2)**2) - 1\n    return f21 * 100",
        "ground_truth": 3.157,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    spot_rate_1_year = 0.0102\n    spot_rate_2_year = 0.0165\n    spot_rate_3_year = 0.0215\n    \n    # Do math calculation to get the answer\n    # First calculate the present value factors for 2 and 3 year spot rates\n    present_value_factor_2_year = 1 / (1 + spot_rate_2_year)**2\n    present_value_factor_3_year = 1 / (1 + spot_rate_3_year)**3\n    \n    # Now, calculate the forward rate between year 2 and year 3 using the formula for implied forward rates:\n    forward_rate = ((present_value_factor_2_year / present_value_factor_3_year) ** (1 / 1)) - 1\n    \n    # return answer\n    return forward_rate\n\n# Call the solution function and print the result to get the 1-year implied forward rate two years in the future\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-114",
        "question": "Based on the BSM model, what is the value of the put option for company XYZ's stock, currently trading at $48.6? Presume that the volatility is 30%, the continuously compounded risk-free rate stands at 0.3%, we assume X is equal to 45, T equals 0.25, N(d1) is 0.6352 and N(d2) is 0.5486.",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    X = 45 # Strike Price\n    S = 48.6 # Stock Price\n    T = 0.25 # Time to maturity in years\n    r = 0.003 # Risk-free interest rate\n    Nd1 = 0.6352 # Value of cumulative standard normal distribution at d1\n    Nd2 = 0.5486 # Value of cumulative standard normal distribution at d2\n    Nd1_neg = 1 - Nd1 \n    Nd2_neg = 1 - Nd2 \n    \n    put_option_price = math.exp(-r * T) * X * Nd2_neg - S * Nd1_neg\n    \n    return put_option_price",
        "ground_truth": 2.568,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the value of a put option using the Black-Scholes-Merton (BSM) model, you can use the formula:\n\nP = Xe^(-rT)N(-d2) - SN(-d1)\n\nwhere:\n- P is the price of the put option.\n- X is the strike price of the option, which is 45.\n- S is the current stock price, which is 48.6.\n- T is the time to expiration, which is 0.25.\n- r is the risk-free rate, which is 0.3% or 0.003 in decimal.\n- N(d1) is the cumulative normal distribution function value for d1, which is 0.6352.\n- N(d2) is the cumulative normal distribution function value for d2, which is 0.5486.\n  \nN(-d1) and N(-d2) can be calculated as 1 - N(d1) and 1 - N(d2), respectively, because the cumulative normal distribution is symmetric about zero.\n\nHere's the Python program that calculates the value of a put option using the BSM model:\n\n```python\nfrom math import exp\n\ndef solution():\n    # Define variables name and value\n    S = 48.6  # Current stock price\n    X = 45    # Strike price\n    T = 0.25  # Time to expiration in years\n    r = 0.003 # Risk-free rate (continuously compounded)\n    N_d1 = 0.6352 # Cumulative distribution function value for d1\n    N_d2 = 0.5486 # Cumulative distribution function value for d2\n    \n    # Calculate N(-d1) and N(-d2)\n    N_minus_d1 = 1 - N_d1\n    N_minus_d2 = 1 - N_d2\n    \n    # Calculate the put option price using the BSM formula\n    P = X * exp(-r * T) * N_minus_d2 - S * N_minus_d1\n    \n    # return answer\n    return round(P, 2)\n```\n\nCall this function to get the value of the put option:\n\n```python\nput_option_value = solution()\nprint(put_option_value)\n```\n\nPlease note that this program rounds the calculated put option value to two decimal places. If more precision is needed, you can adjust the `round` function accordingly or remove it."
        ]
    },
    {
        "question_id": "validation-115",
        "question": "What is the sample standard deviation from the following 10 measurements taken from a roughly normal group?",
        "tables": [
            "| Observation | 1  | 2   | 3 | 4   | 5  | 6  | 7  | 8 | 9 | 10  |\n|-------------|----|-----|---|-----|----|----|----|---|---|-----|\n| Value       | -3 | -11 | 3 | -18 | 18 | 20 | -6 | 9 | 2 | -16 |"
        ],
        "python_solution": "def solution():\n    import math\n    measurements = [-3, -11, 3, -18, 18, 20, -6, 9, 2, -16]\n    mean = sum(measurements) / len(measurements)\n    variance = sum((xi - mean) ** 2 for xi in measurements) / (len(measurements) - 1)\n    return math.sqrt(variance)",
        "ground_truth": 13.181,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To find the sample standard deviation, we can make use of Python code where we first calculate the sample mean, then use this to find the sum of squared differences from the mean for each observation, and finally divide by the number of observations minus 1 (for sample standard deviation) and take the square root of the result.\n\nHere is the program:\n\n```python\nimport math\n\ndef solution():\n    # Define the observed values\n    values = [-3, -11, 3, -18, 18, 20, -6, 9, 2, -16]\n\n    # Calculate the mean of the sample\n    mean = sum(values) / len(values)\n    \n    # Calculate the sum of squares of differences from the mean\n    sum_of_squares = sum((x - mean) ** 2 for x in values)\n    \n    # Calculate the sample standard deviation\n    sample_std_dev = math.sqrt(sum_of_squares / (len(values) - 1))\n    \n    # Return the answer\n    return sample_std_dev\n\n# This call to the solution function would compute the sample standard deviation\nprint(solution())\n```\n\nWhen you call `solution()`, the function will calculate and return the sample standard deviation based on the observations provided."
        ]
    },
    {
        "question_id": "validation-116",
        "question": "The reference weights and yields for each of the five stocks in the Olympia index are presented below. The Kurok Fund employs the Olympia Index as its benchmark, and the fund's portfolio weights are also outlined in the chart. What is the value added (active return) for the Kurok Fund?",
        "tables": [
            "| Stock | Portfolio Weight (%) | Benchmark Weight (%) | 2016 Return (%) |\n|-------|---------------------|----------------------|-----------------|\n| 1     | 30                  | 24                   | 14              |\n| 2     | 30                  | 20                   | 15              |\n| 3     | 20                  | 20                   | 12              |\n| 4     | 10                  | 18                   | 8               |\n| 5     | 10                  | 18                   | 10              |"
        ],
        "python_solution": "def solution():\n    portfolio_weights = [0.30, 0.30, 0.20, 0.10, 0.10]\n    portfolio_returns = [14, 15, 12, 8, 10]\n    benchmark_weights = [0.24, 0.20, 0.20, 0.18, 0.18]\n    benchmark_returns = [14, 15, 12, 8, 10]\n\n    portfolio_return = sum([weight * return_val for weight, return_val in zip(portfolio_weights, portfolio_returns)])\n    benchmark_return = sum([weight * return_val for weight, return_val in zip(benchmark_weights, benchmark_returns)])\n\n    active_return = portfolio_return - benchmark_return\n    \n    return active_return/100",
        "ground_truth": 0.009,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Each stock performance as tuples of (Portfolio Weight, Benchmark Weight, Return)\n    stocks = [\n        (30, 24, 14),\n        (30, 20, 15),\n        (20, 20, 12),\n        (10, 18, 8),\n        (10, 18, 10)\n    ]\n    \n    # Calculate portfolio and benchmark returns\n    portfolio_return = sum(portfolio_weight * return_ / 100 for portfolio_weight, _, return_ in stocks)\n    benchmark_return = sum(benchmark_weight * return_ / 100 for _, benchmark_weight, return_ in stocks)\n    \n    # Calculate active return by subtracting benchmark return from portfolio return\n    active_return = portfolio_return - benchmark_return\n    \n    # return answer\n    return active_return\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nWhen you run this program, it will calculate the active return of the Kurok Fund compared to the Olympia Index as a benchmark. This value represents the value added by the fund's management strategy."
        ]
    },
    {
        "question_id": "validation-117",
        "question": "An MBS made up of four distinct mortgage pools: $1 million of mortgages maturing in 30 days, $2 million of mortgages maturing in 90 days, $3 million of mortgages maturing in 180 days, and $4 million of mortgages maturing in 360 days, is owned by XYZ Inc. Could you calculate the weighted average maturity (WAM) for this MBS?",
        "tables": [],
        "python_solution": "def solution():\n    maturity_values = [30, 90, 180, 360] # in days\n    weights = [1, 2, 3, 4] # in million dollars\n    total_maturity = sum([maturity_values[i] * weights[i] for i in range(len(maturity_values))])\n    total_weight = sum(weights)\n    return total_maturity / total_weight",
        "ground_truth": 219.0,
        "topic": "Risk Management",
        "output": [
            "Certainly! The Weighted Average Maturity (WAM) can be calculated by multiplying the maturity of each mortgage pool by its proportion of the total MBS value, and then summing these products. The Python program for this would look like the following:\n\n```python\ndef solution():\n    # Define variables name and value\n    maturities = [30, 90, 180, 360]\n    amounts = [1e6, 2e6, 3e6, 4e6]\n    total_mbs_value = sum(amounts)\n    \n    # Calculate the weighted average maturity (WAM)\n    WAM = sum(maturity * amount / total_mbs_value for maturity, amount in zip(maturities, amounts))\n    \n    # return answer\n    return WAM\n\n# You can run the solution function and it will return the weighted average maturity of the MBS.\n```"
        ]
    },
    {
        "question_id": "validation-118",
        "question": "What is the value of the Paasche index for the consumption basket shown in Exhibit 1 for December?",
        "tables": [
            "| Date         |November 2010   |         | December 2010  |         |\n| -------------|:--------------:| -------:|:--------------:| -------:|\n| Goods        |Quantity        |Price    |Quantity        |Price    |\n| Sugar        |70kg            |C0.90/kg |120kg           |£1.00/kg |\n| Cotton       |60kg            |E0.60/kg |50kg            |€0.80/kg |"
        ],
        "python_solution": "def solution():\n    numerator = (120 * 1) + (50 * 0.8)\n    denominator = (120 * 0.9) + (50 * 0.6)\n    paasche_index = (numerator/denominator) * 100\n    return paasche_index",
        "ground_truth": 115.942,
        "topic": "Market Analysis & Economics",
        "output": [
            "To calculate the value of the Paasche index for the given consumption basket, we will use the following formula:\n\nPaasche index \\( P_1 \\) for period 1 (December 2010) is given by:\n\n\\[ P_1 = \\frac{\\sum (p_1 \\cdot q_1)}{\\sum (p_0 \\cdot q_1)} \\times 100 \\]\n\nwhere:\n- \\( p_1 \\) is the price of a given good in period 1 (December 2010)\n- \\( q_1 \\) is the quantity of a given good in period 1 (December 2010)\n- \\( p_0 \\) is the price of a given good in the base period (November 2010)\n\nNow, let's generate the Python program to compute the Paasche index:\n\n```python\ndef solution():\n    # Define variables for quantities and prices\n    # November 2010 quantities and prices (base period)\n    q0_sugar = 70  # kg\n    p0_sugar = 0.90  # £/kg\n    \n    q0_cotton = 60  # kg\n    p0_cotton = 0.60  # €/kg converted to £/kg\n    \n    # December 2010 quantities and prices (current period)\n    q1_sugar = 120  # kg\n    p1_sugar = 1.00  # £/kg\n    \n    q1_cotton = 50  # kg\n    p1_cotton = 0.80  # €/kg converted to £/kg\n\n    # Assuming the exchange rate for converting € to £ is 1:1 for simplicity\n    # Do math calculation to get the Paasche index\n    sum_p0_q1 = (p0_sugar * q1_sugar) + (p0_cotton * q1_cotton)\n    sum_p1_q1 = (p1_sugar * q1_sugar) + (p1_cotton * q1_cotton)\n    \n    # Calculating the Paasche index\n    paasche_index = (sum_p1_q1 / sum_p0_q1) * 100\n    \n    # return the answer\n    return paasche_index\n\n# To use the solution function and print the Paasche index value\nprint(solution())\n```\n\nPlease note that the exchange rates are not specified, and the assumption of a 1:1 exchange rate between the Euro (€) and the Pound Sterling (£) is made for simplicity's sake. In a real-world scenario, you would need to use the appropriate exchange rate for the conversion before performing the calculations."
        ]
    },
    {
        "question_id": "validation-119",
        "question": "Smith is a tax consultant who offers tax education advice to individual clients. One of Smith's clients is Sarah. Sarah wants Smith to examine Mutual Fund X, which has an embedded gain of 10% of the closing portfolio value. Sarah requests Smith to compute a post-liquidation return for the last three-year period. Mutual Fund X showed after-tax returns of 9.0% in the first year, 5% in the second year, and 8% in the third year, and capital gains are taxed at a 25% rate. What is the annualized after-tax post-liquidation return worked out by Smith?",
        "tables": [],
        "python_solution": "def solution():\n    # Given\n    returns = [0.09, 0.05, 0.08] # After-tax returns for the three years\n    tax_rate = 0.25 # Capital gains tax rate\n    embedded_gain = 0.10 # Embedded gain of the portfolio\n\n    # Calculate the final after-tax portfolio value\n    portfolio_value = 1\n    for r in returns:\n        portfolio_value *= (1 + r)\n\n    # Account for the unrealized capital gains\n    portfolio_value *= (1 - embedded_gain * tax_rate)\n\n    # Annualize the after-tax post-liquidation return\n    annualized_return = (portfolio_value ** (1 / len(returns))) - 1\n\n    return annualized_return*100 # Converting decimal return to percentage",
        "ground_truth": 6.418,
        "topic": "Accounting",
        "output": [
            "Below is a Python program that calculates the annualized after-tax post-liquidation return:\n\n```python\ndef solution():\n    # Define the after-tax returns for each year\n    after_tax_returns = [0.09, 0.05, 0.08]  # given as percentages, for 9%, 5%, and 8% respectively\n    \n    # Define the embedded gain and tax rate\n    embedded_gain_percent = 0.10  # 10% of the closing portfolio value, as an embedded gain\n    capital_gains_tax_rate = 0.25  # taxes are at a 25% rate\n    \n    # Calculate the after-tax effect of the embedded gain\n    after_tax_embedded_gain = 1 + (embedded_gain_percent * (1 - capital_gains_tax_rate))\n    \n    # Calculate the compounded after-tax return including the embedded gain.\n    compounded_return = 1\n    for return_percentage in after_tax_returns:\n        after_tax = 1 + return_percentage * (1 - capital_gains_tax_rate)\n        compounded_return *= after_tax\n\n    compounded_return *= after_tax_embedded_gain\n    \n    # Calculate the annualized return over the 3-year period\n    years = 3\n    annualized_return = (compounded_return ** (1 / years)) - 1\n    \n    # Return annualized_return as percentage\n    return annualized_return * 100\n\n# Example usage:\n# annualized_after_tax_return = solution()\n# print(f\"Annualized After-Tax Post-Liquidation Return: {annualized_after_tax_return:.2f}%\")\n```\n\nCalling the function `solution()` will perform the calculations and return the annualized after-tax post-liquidation return over the 3-year period as a percentage."
        ]
    },
    {
        "question_id": "validation-120",
        "question": "Assuming the going rate for the base asset at present is $50, with the risk-free rate being 4%, and the contract ends in three months. If the current value of the advantages is $5, and the current value of the disadvantages is $6. What would be the forward price?",
        "tables": [],
        "python_solution": "def solution():\n    T = 3 / 12\n    s0 = 50\n    r = 0.04\n    q1 = 5\n    q2 = 6\n    \n    forward_price = s0 * ((1+r)**T) - ((q1 - q2) * ((1+r)**T))\n    \n    return forward_price",
        "ground_truth": 51.503,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    spot_price = 50\n    risk_free_rate = 0.04\n    time_in_years = 3 / 12\n    advantages = 5\n    disadvantages = 6\n    \n    # Do math calculation to get the forward price\n    forward_price = (spot_price + advantages - disadvantages) * (1 + risk_free_rate * time_in_years)\n    \n    # return answer\n    return forward_price\n\n# Call the solution function and print returned value\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-121",
        "question": "Currently, the Chinese Yuan is valued at 1.1757 in terms of the Hong Kong Dollar, and the Australian Dollar is valued at 5.0765 in terms of the Chinese Yuan. What is the cross rate for the Hong Kong Dollar to the Australian Dollar?",
        "tables": [],
        "python_solution": "def solution():\n    HKD_CNY = 1.1757\n    CNY_AUD = 5.0765\n    HKD_AUD = HKD_CNY * CNY_AUD\n    return HKD_AUD",
        "ground_truth": 5.968,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    yuan_to_hkd = 1.1757\n    aud_to_yuan = 5.0765\n    \n    # Do math calculation to get the answer\n    hkd_to_aud = yuan_to_hkd * aud_to_yuan\n    \n    # return answer\n    return hkd_to_aud\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe above program calculates the cross rate for the Hong Kong Dollar to the Australian Dollar by multiplying the rate at which the Chinese Yuan is valued against the Hong Kong Dollar with the rate at which the Australian Dollar is valued against the Chinese Yuan."
        ]
    },
    {
        "question_id": "validation-122",
        "question": "What's the cost of the annuity that has a YTM of 5.5% and pays out $100,000 annually for 40 years?",
        "tables": [],
        "python_solution": "def solution():\n    N = 40\n    PMT = 100000\n    I_Y = 5.5 / 100\n    \n    PV = PMT * ((1 - (1 + I_Y) ** -N) / I_Y)\n    \n    return PV",
        "ground_truth": 1604612.469,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Certainly! To calculate the present value of an annuity, you can use the present value annuity formula which is:\n\n\\[ PVA = PMT \\times \\left(1 - \\left(1 + r\\right)^{-n}\\right) / r \\]\n\nWhere:\n- \\( PVA \\) is the present value of the annuity.\n- \\( PMT \\) is the annual payout ($100,000 in this case).\n- \\( r \\) is the periodic interest rate (YTM of 5.5% annually in this case).\n- \\( n \\) is the total number of periods (40 years in this case).\n\nLet's implement this in a Python program.\n\n```python\ndef solution():\n    # Define variables name and value\n    PMT = 100000  # Annual payout\n    r = 0.055     # YTM of 5.5%, in decimal\n    n = 40        # Duration of the annuity in years\n    \n    # Do math calculation to get the answer using the Present Value of Annuity Formula\n    PVA = PMT * ((1 - (1 + r)**-n) / r)\n    \n    # return answer\n    return PVA\n\n# Call the function and print the result\nprint(f\"The cost of the annuity: {solution()}\")\n```\n\nWhen you run the above function, it will calculate the present value of an annuity that pays out $100,000 annually for 40 years, with a YTM of 5.5%."
        ]
    },
    {
        "question_id": "validation-123",
        "question": "What is the anticipated standard deviation for the following portfolio, assuming a correlation of 0.25 between the two securities?",
        "tables": [
            "| Security | Security Weight(%) | Expected Standard Deviation(%) |\n|----------|-------------------|--------------------------------|\n| 1        | 40                | 30                             |\n| 2        | 60                | 15                             |"
        ],
        "python_solution": "def solution():\n    w1 = 0.4\n    w2 = 0.6\n    sigma1 = 0.3\n    sigma2 = 0.15\n    rho = 0.25\n    sigma_port = ((w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2*w1*w2*sigma1*sigma2*rho))**0.5\n    return sigma_port*100",
        "ground_truth": 16.703,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight_sec1 = 0.40  # Security 1 weight\n    weight_sec2 = 0.60  # Security 2 weight\n    sd_sec1 = 0.30     # Standard deviation of security 1\n    sd_sec2 = 0.15     # Standard deviation of security 2\n    correlation = 0.25  # Correlation between the securities\n\n    # Calculate the portfolio standard deviation using the formula for combined standard deviation of two assets\n    portfolio_variance = (weight_sec1 * sd_sec1)**2 + (weight_sec2 * sd_sec2)**2 + \\\n        2 * weight_sec1 * weight_sec2 * sd_sec1 * sd_sec2 * correlation\n    \n    # Portfolio standard deviation is the square root of variance\n    portfolio_sd = math.sqrt(portfolio_variance)\n    \n    # Return answer\n    return round(portfolio_sd, 4)\n\n# You can print the result to check the answer\nprint(solution())\n```\n\nThis program calculates the anticipated standard deviation for a portfolio consisting of two securities with given weights, standard deviations, and correlation. The `round` function is used to round the result to four decimal places, and the `print` statement can be used to verify the output."
        ]
    },
    {
        "question_id": "validation-124",
        "question": "Given that an artwork was created and sold in 2015 for $1000, and the creation process cost $300. When computing GDP using the sum-of-value-added approach, what is the value of the final step in creating the artwork?",
        "tables": [],
        "python_solution": "def solution():\n    cost_of_artwork = 1000\n    cost_of_creation = 300\n    final_value = cost_of_artwork - cost_of_creation\n    return final_value",
        "ground_truth": 700.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    final_sale_price = 1000\n    creation_cost = 300\n    \n    # The value of the final step is the sale price minus the creation cost\n    value_added = final_sale_price - creation_cost\n    \n    # return answer\n    return value_added\n\n# Example of how the function can be called\n#print(solution())\n```\nThis program calculates the value added to the artwork in its final step, which is the difference between the final sale price and the creation cost."
        ]
    },
    {
        "question_id": "validation-125",
        "question": "What is the effective annual rate if the yearly rate for the stock market is 14.31% and it's compounded quarterly?",
        "tables": [],
        "python_solution": "def solution():\n    annual_rate = 0.1431\n    compounding_frequency = 4\n\n    ear = (1 + (annual_rate / compounding_frequency))**compounding_frequency - 1\n\n    return ear*100.0",
        "ground_truth": 15.096,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here's the Python program to calculate the effective annual rate (EAR) when the yearly rate is 14.31% and it's compounded quarterly:\n\n```python\ndef solution():\n    # Define variables name and value\n    nominal_rate = 0.1431  # The yearly rate for the stock market as a decimal\n    compounding_periods = 4  # Compounded quarterly\n\n    # Do math calculation to get the answer\n    effective_annual_rate = (1 + nominal_rate / compounding_periods) ** compounding_periods - 1 \n    \n    # return answer\n    return effective_annual_rate\n\n# You can call the function to get the result if needed\n# print(f\"The effective annual rate is: {solution() * 100:.2f}%\")\n```\n\nWhen you call the `solution()` function, it will return the effective annual rate as a decimal. If you want to see the percentage, you can multiply by 100 and format it accordingly."
        ]
    },
    {
        "question_id": "validation-126",
        "question": "An investor from Australia currently manages an equity portfolio valued at A$240 million. He is contemplating adjusting the portfolio based on an evaluation of the risk and return possibilities confronting the Australian economy. The table below contains data pertaining to the Australian investment markets and the economic situation: Using the data in the table, determine the anticipated annual equity return using the Grinold–Kroner model (the number of outstanding shares is presumed to remain unchanged).",
        "tables": [
            "| 10-Year Historical | Current | Capital Market Expectations |\n|---|---|---|\n| Average government bond yield: 2.8% | 10-year government bond yield:2.3% | |\n| Average annual equity return: 4.6% | Year-over-year equity return:-9.4% | |\n| Average annual inflation rate: 2.3% | Year-over-year inflation rate:2.1% | Expected annual inflation: 2.3% |\n| Equity market P/E (beginning of period): 15x | Current equity market P/E: 14.5x | Expected equity market P/E: 14.0x |\n| Average annual dividend income return: 2.6% | | Expected annual income return: 2.4% |\n| Average annual real earnings growth: 6.0% | | Expected annual real earnings growth: 5.0% |"
        ],
        "python_solution": "def solution():\n    annual_income_return = 2.4 / 100\n    expected_annual_real_earning_growth = 5.0 / 100\n    expected_inflation_rate = 2.3 / 100\n    expected_nominal_earning_growth_return = expected_annual_real_earning_growth + expected_inflation_rate\n    expected_repricing_return = (14 - 14.5) / 14.5 \n    return annual_income_return + expected_nominal_earning_growth_return + expected_repricing_return",
        "ground_truth": 0.063,
        "topic": "Market Analysis & Economics",
        "output": [
            "To calculate the expected annual equity return using the Grinold-Kroner model, we need to consider the following components:\n\n- \\( D/Y \\): Dividend Yield (expected annual income return)\n- \\( I/Y \\): Inflation rate (expected annual inflation)\n- \\( E/P \\): Earnings Yield, which is the inverse of the P/E ratio (expected earnings divided by price)\n- \\( g \\): Real growth in earnings (expected annual real earnings growth)\n- \\( \\Delta S \\): Change in shares outstanding, which is zero in this case (the number of outstanding shares is presumed to remain unchanged)\n\nThe Grinold-Kroner model is given by the formula:\n\n\\[ k = (D/Y) + (I/Y) + (E/P) + g - (\\Delta S) \\]\n\nwhere \\( k \\) is the expected annual equity return.\n\nLet's implement the Python program to calculate the expected annual equity return:\n\n```python\ndef solution():\n    # Define variables name and value\n    expected_income_return = 2.4 / 100  # D/Y, expressed as a decimal\n    expected_inflation = 2.3 / 100      # I/Y, expressed as a decimal\n    expected_pe_ratio = 14.0            # P/E (given as Expected equity market P/E)\n    expected_real_growth = 5.0 / 100    # g, expressed as a decimal\n    change_in_shares = 0                # ΔS, no change in shares\n    \n    # Earnings yield (E/P) is the inverse of P/E ratio\n    earnings_yield = 1 / expected_pe_ratio\n    \n    # Do math calculation to get the answer using the Grinold–Kroner model\n    expected_annual_equity_return = (expected_income_return + expected_inflation +\n                                     earnings_yield + expected_real_growth -\n                                     change_in_shares)\n    \n    # Convert to percentage format\n    expected_annual_equity_return_percent = expected_annual_equity_return * 100\n    \n    # return answer\n    return expected_annual_equity_return_percent\n\n# Call the function and print the result\nprint(solution())\n```\n\nWhen you execute this function, it will calculate and return the anticipated annual equity return expressed as a percentage, based on the Grinold–Kroner model."
        ]
    },
    {
        "question_id": "validation-127",
        "question": "The variances of shares X and shares Y are 0.25 and 0.64 respectively, and the correlation between these two securities is 0.09. What is the covariance of the returns?",
        "tables": [],
        "python_solution": "def solution():\n    variance_X = 0.25\n    variance_Y = 0.64\n    correlation = 0.09\n    \n    covariance = correlation * (variance_X**0.5) * (variance_Y**0.5)\n    return covariance",
        "ground_truth": 0.036,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here's the Python program that calculates the covariance of the returns based on the given variances and correlation:\n\n```python\ndef solution():\n    # Define variables name and value\n    variance_X = 0.25\n    variance_Y = 0.64\n    correlation_XY = 0.09\n    \n    # Do math calculation to get the answer\n    # Covariance = Correlation * (Standard Deviation of X) * (Standard Deviation of Y)\n    covariance_XY = correlation_XY * (variance_X**0.5) * (variance_Y**0.5)\n    \n    # return answer\n    return covariance_XY\n    \n# This is optional for direct testing\nif __name__ == '__main__':\n    answer = solution()\n    print(\"Covariance of the returns:\", answer)\n```\n\nThe `solution` function calculates the covariance between the two securities using the correlation coefficient and the standard deviations derived from the variances. The standard deviation is the square root of the variance, which is computed as `variance**0.5` in Python."
        ]
    },
    {
        "question_id": "validation-128",
        "question": "The effective annual return on an investment is 9%. What would be the return on a bond-equivalent basis?",
        "tables": [],
        "python_solution": "def solution():\n    EAR = 0.09\n    BEY = (pow((1 + EAR), 0.5) - 1) * 2\n    return BEY",
        "ground_truth": 0.088,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To solve this problem, we need to convert the effective annual return to a bond-equivalent yield. The bond-equivalent yield (BEY) for a semi-annual bond is calculated by doubling the semi-annual yield. The semi-annual yield is obtained by calculating the equivalent yield for a 6-month period, which can be derived by taking the square root of the yield over a 12-month period (in this case, the effective annual return of 9%) and then subtracting 1. \n\nHere is a Python program that performs this calculation:\n\n```python\ndef solution():\n    # Define variables name and value\n    effective_annual_return = 0.09  # 9% effective annual return\n    \n    # Calculate semi-annual yield\n    semi_annual_yield = (1 + effective_annual_return)**(1/2) - 1\n\n    # Convert to bond-equivalent yield\n    bey = semi_annual_yield * 2\n    \n    # return answer\n    return bey\n\n# Call the function and print the result\nprint(solution())\n```\n\nNote that this assumes that the bond pays interest semiannually, which is typical for many bonds when calculating the bond-equivalent yield."
        ]
    },
    {
        "question_id": "validation-129",
        "question": "In 2016, Emily purchased a machine for $50,000 and its useful life is ten years. It has a residual value of $5,000. What is the depreciation of this machine in 2016 using the double-declining balance method?",
        "tables": [],
        "python_solution": "def solution():\n    cost_of_machine = 50000\n    useful_life = 10\n    residual_value = 5000\n    depreciation = cost_of_machine * (2/useful_life)\n    return depreciation",
        "ground_truth": 10000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cost = 50000\n    residual_value = 5000\n    useful_life = 10\n    year = 2016  # The year of purchase and the first year of depreciation\n\n    # Calculate the annual depreciation rate using the double-declining balance method\n    depreciation_rate = (1 / useful_life) * 2\n\n    # Calculate the depreciation for the first year (2016)\n    depreciation_first_year = (cost - residual_value) * depreciation_rate\n    \n    # return answer\n    return depreciation_first_year\n    \n# Example usage:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-130",
        "question": "If the exchange rate for the Euro (EUR) in London stands at GBP/EUR 0.8878, what would probably be the exchange rate for the British pound (GBP) in Frankfurt (EUR/GBP)?",
        "tables": [],
        "python_solution": "def solution():\n    gbp_eur = 0.8878\n    eur_gbp = 1 / gbp_eur\n    return eur_gbp",
        "ground_truth": 1.126,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    exchange_rate_london = 0.8878\n    \n    # Do math calculation to get the answer\n    # The exchange rate EUR/GBP is the reciprocal of GBP/EUR.\n    exchange_rate_frankfurt = 1 / exchange_rate_london\n    \n    # return answer\n    return exchange_rate_frankfurt\n    \n# Optionally, you may wish to print or otherwise use the result\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-131",
        "question": "If we assume an existing market risk-free rate of 4% annually, and the yield on the Corporation B bond is 6% annually, what is the inferred probability of default based on the current bond interest rate, presuming the market is fairly priced, and the recovery rate on the corporation's bonds is 70%?",
        "tables": [],
        "python_solution": "def solution():\n    risk_free_rate = 0.04\n    yield_corp_B_bond = 0.06\n    recovery_rate = 0.7\n\n    credit_spread = yield_corp_B_bond - risk_free_rate\n    LGD = 1 - recovery_rate\n    default_probability = credit_spread / LGD\n\n    return default_probability * 100",
        "ground_truth": 6.667,
        "topic": "Risk Management",
        "output": [
            "Here is a Python program that calculates the inferred probability of default based on the provided information:\n\n```python\ndef solution():\n    # Define variables name and value\n    risk_free_rate = 0.04  # Risk-free rate (4% annually)\n    bond_yield = 0.06      # Yield on Corporation B bond (6% annually)\n    recovery_rate = 0.70   # Recovery rate on the corporation's bonds (70%)\n\n    # The formula to calculate the probability of default is:\n    # (bond_yield - risk_free_rate) / (1 - recovery_rate)\n    probability_of_default = (bond_yield - risk_free_rate) / (1 - recovery_rate)\n\n    # return answer\n    return probability_of_default\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThe program defines the given values as variables. It then uses the formula to calculate the probability of default, which is the difference between the bond yield and the risk-free rate divided by one minus the recovery rate, assuming the market is fairly priced. The `solution()` function returns this calculated probability."
        ]
    },
    {
        "question_id": "validation-132",
        "question": "Analyst Johnson is determining the RAROC of a commercial loan portfolio for Company P. He has gathered the following details: The primary borrowing is $1.3 billion. The predicted pre-tax profit from the loan portfolio is 7%. The estimated direct annual operation cost is around $6 million. The loan portfolio is backed by $1.3 billion of consumer deposits and the interest rate is at 5%. Johnson is also predicting that the expected yearly loss on the portfolio is 0.3% of the principal. On top of this, Johnson estimates the unexpected loss on the principal amount could be as high as 8%. Further, Johnson takes into consideration that the risk-free rate is 1.5% and the effective tax rate is 25%. Finally, Johnson presumes there will not be any transfer pricing issues. Based off the definition of RAROC, what would Johnson's prediction about RAROC be?",
        "tables": [],
        "python_solution": "def solution():\n    principal = 1300000000\n    predicted_pre_tax_profit_rate = 7/100\n    operation_cost = 6000000\n    interest_rate = 5/100\n    expected_loss_rate = 0.3/100\n    unexpected_loss_rate = 8/100\n    risk_free_rate = 1.5/100\n    tax_rate = 25/100\n    \n    unexpected_loss = principal * unexpected_loss_rate\n    economic_capital = unexpected_loss\n    return_on_economic_capital = economic_capital * risk_free_rate\n    \n    expected_revenue = principal * predicted_pre_tax_profit_rate\n    interest_expense = principal * interest_rate\n    expected_loss = principal * expected_loss_rate\n    \n    RAROC = ((expected_revenue - operation_cost - expected_loss - interest_expense + return_on_economic_capital ) * (1-tax_rate)) / economic_capital\n    \n    return RAROC * 100",
        "ground_truth": 12.736,
        "topic": "Risk Management",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    principal = 1.3e9 # $1.3 billion\n    pre_tax_profit_percentage = 7 / 100\n    operation_cost = 6e6 # $6 million\n    deposit_cost = 1.3e9 * 5 / 100 # $1.3 billion at 5%\n    expected_loss_rate = 0.3 / 100\n    unexpected_loss_rate = 8 / 100\n    risk_free_rate = 1.5 / 100\n    tax_rate = 25 / 100\n\n    # Expected Pre-Tax Return on Risk Adjusted Capital\n    expected_pre_tax_return = (pre_tax_profit_percentage * principal) - operation_cost - deposit_cost\n\n    # Expected Loss\n    expected_loss = expected_loss_rate * principal\n\n    # Adjusted Expected Pre-Tax Return\n    adjusted_expected_pre_tax_return = expected_pre_tax_return - expected_loss\n\n    # Economic Capital\n    economic_capital = unexpected_loss_rate * principal\n\n    # RAROC calculation\n    raroc = adjusted_expected_pre_tax_return / economic_capital\n\n    # after tax RAROC\n    after_tax_raroc = raroc * (1 - tax_rate)\n\n    # Adding Risk Free Rate\n    answer = after_tax_raroc + risk_free_rate\n    \n    # return answer\n    return answer\n\n# Running the solution to get the result\nprint(solution())\n```\n\nThe above Python program defines the necessary variables based on the given financial information. It uses these variables to calculate the adjusted expected pre-tax return, accounts for expected losses, and identifies the economic capital required. Finally, it computes RAROC by dividing the adjusted expected pre-tax return by the economic capital. It then adjusts for the effective tax rate and adds the risk-free rate to get the final RAROC. The program should return the predicted RAROC based on the given data and assumptions."
        ]
    },
    {
        "question_id": "validation-133",
        "question": "An insurance firm projects that next year, 40% of clients with only a car insurance plan will renew it, and 70% of clients with only a house insurance plan will do the same. The firm also projects that 80% of clients with both a car and a house insurance plan will renew at least one of these plans next year. According to the firm's records, 70% of clients have a car insurance plan, 50% have a house insurance plan, and 20% have both types of plans. Based on these estimates by the firm, what is the percentage of clients that will renew at least one plan next year?",
        "tables": [],
        "python_solution": "def solution():\n    PAH = 0.20\n    PAHc = 0.70 - PAH\n    AcH = 0.50 - PAH\n    res = 0.40 * PAHc + 0.70 * AcH + 0.80 * PAH\n    return res * 100",
        "ground_truth": 57.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables for each type of insurance plan\n    car_insurance_clients = 0.70\n    house_insurance_clients = 0.50\n    both_insurance_clients = 0.20\n    \n    # Only car or only house insurance plan without considering overlaps\n    only_car_insurance_clients = car_insurance_clients - both_insurance_clients\n    only_house_insurance_clients = house_insurance_clients - both_insurance_clients\n    \n    # Define variables for renewal rates\n    car_renewal_rate = 0.40\n    house_renewal_rate = 0.70\n    both_renewal_rate = 0.80\n    \n    # Calculate the renewal rates for each category\n    renewals_only_car = only_car_insurance_clients * car_renewal_rate\n    renewals_only_house = only_house_insurance_clients * house_renewal_rate\n    renewals_both = both_insurance_clients * both_renewal_rate\n    \n    # Calculate the total renewal rate\n    total_renewals = renewals_only_car + renewals_only_house + renewals_both\n    \n    # Convert to percentage\n    renewal_percentage = total_renewals * 100\n    \n    # return answer\n    return renewal_percentage\n    \n# Execute the function and print the result\nprint(solution())\n```\n\nThis function calculates the percentage of clients expected to renew at least one insurance plan based on the given project renewal rates and the percentages of clients with different types of insurance plans."
        ]
    },
    {
        "question_id": "validation-134",
        "question": "The following spot and forward rates are provided: Present 1-year spot rate is 6%. The one-year forward rate one year from now is 8%. The one-year forward rate two years from now is 10%. What is the worth of a 3-year, 10% annually paid, bond with a par value of $1000?",
        "tables": [],
        "python_solution": "def solution():\n    bond_value = 100 / (1.06) + 100 / ((1.06) * (1.08)) + 1100 / ((1.06) * (1.08) * (1.1))\n    return int(bond_value)",
        "ground_truth": 1055.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the worth of the bond, we need to discount each of the bond's cash flows by the appropriate rate. The present value (PV) of the bond can be calculated by summing the present value of all the coupon payments and the present value of the par value. Given that the bond has a 10% coupon rate and a par value of $1000, it will pay $100 annually for three years and a final payment of $1000 at the end of the third year. We will use the spot rate for the first year, the one-year forward rate one year from now for the second year, and the one-year forward rate two years from now for the third year.\n\nHere's how we can implement the calculation in a Python function:\n\n```python\ndef solution():\n    # Define the variables\n    face_value = 1000\n    coupon_rate = 0.10\n    coupon_payment = face_value * coupon_rate\n    spot_rate_1 = 0.06\n    forward_rate_1 = 0.08\n    forward_rate_2 = 0.10\n    \n    # Calculate the present value of the first coupon payment\n    pv_coupon_1 = coupon_payment / (1 + spot_rate_1)\n    \n    # Calculate the present value of the second coupon payment\n    # We discount for two periods at the spot rate for the first period\n    # and the forward rate for the second period\n    pv_coupon_2 = coupon_payment / ((1 + spot_rate_1) * (1 + forward_rate_1))\n    \n    # Calculate the present value of the third coupon payment and par value\n    # We discount for three periods at the spot rate for the first,\n    # the forward rate for the second and the forward rate for the third period\n    pv_coupon_3_and_par = (coupon_payment + face_value) / ((1 + spot_rate_1) * (1 + forward_rate_1) * (1 + forward_rate_2))\n    \n    # Calculate the present value of the bond by summing all the present values\n    value_of_bond = pv_coupon_1 + pv_coupon_2 + pv_coupon_3_and_par\n    \n    # Return the value of the bond\n    return round(value_of_bond, 2)  # Round the result for precision\n\n# Calling the function to get the result\nprint(solution())\n```\n\nThis function will calculate the present value of each cash flow, sum them up, and return the total present value of the bond, rounded to two decimal places.\n"
        ]
    },
    {
        "question_id": "validation-135",
        "question": "If Allison, a CFA, was revising her company's estimates for US equity returns and thought that over time the growth of the US labor input would be 0.9% per year and labor productivity would increase by 1.5%, inflation would stand at 2.1%, the dividend yield would be 2.25%, and the P/E growth would be nonexistent, what was probably her benchmark forecast for continuously compounded long-term US equity returns?",
        "tables": [],
        "python_solution": "def solution():\n    growth_of_labor_input = 0.9\n    labor_productivity_increase = 1.5\n    inflation = 2.1\n    dividend_yield = 2.25\n    \n    baseline_projection = growth_of_labor_input + labor_productivity_increase + inflation + dividend_yield\n\n    return baseline_projection/100",
        "ground_truth": 0.068,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables\n    labor_input_growth = 0.009\n    labor_productivity_growth = 0.015\n    inflation = 0.021\n    dividend_yield = 0.0225\n    pe_growth = 0\n    \n    # Gordon growth model extension: \n    # Real growth rate of earnings = Growth rate of labor input + Growth rate of labor productivity\n    # Nominal growth rate of earnings = Real growth rate of earnings + Inflation\n    # Total return = Dividend Yield + Growth rate of earnings + P/E growth\n    \n    # Calculate real growth rate of earnings\n    real_earnings_growth = labor_input_growth + labor_productivity_growth\n\n    # Calculate nominal growth rate of earnings\n    nominal_earnings_growth = real_earnings_growth + inflation\n\n    # Calculate total return (ignoring P/E growth since it's zero)\n    total_return = dividend_yield + nominal_earnings_growth\n    \n    # Return answer as continuously compounded return\n    continuously_compounded_return = total_return\n    \n    return continuously_compounded_return\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program defines the necessary variables taking into account the growth of labor input, labor productivity, inflation, dividend yield, and P/E growth to produce a benchmark forecast for continuously compounded long-term US equity returns. It calculates the real and nominal growth rate of earnings and then adds them to the dividend yield to get the total nominal return, which is the answer needed since P/E growth is nonexistent."
        ]
    },
    {
        "question_id": "validation-136",
        "question": "If an $100 million retirement fund has 80% in equity with a beta of 1.2, how many stock index futures would need to be purchased to change the allocation to 60% in equity? This assumes a stock index value of 1,200, a multiplier of $250, and a beta of 0.95.",
        "tables": [],
        "python_solution": "def solution():\n    target_equity = 0.60\n    initial_equity = 0.80\n    portfolio_value = 100000000\n    futures_value = 1200 * 250\n    beta_stock = 1.2\n    beta_future = 0.95\n    delta_equity = (target_equity - initial_equity) * portfolio_value\n    delta_beta = (0 - beta_stock)/beta_future\n    futures_contracts = delta_beta * (delta_equity/futures_value)\n    return int(futures_contracts)",
        "ground_truth": 84.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To answer this question using a Python program, we need to first calculate the current equity position, determine the desired equity position after adjusting the allocation, and figure out the position change. Then, we'll calculate the number of stock index futures contracts required to achieve the adjustment, considering the beta adjustment needed since the equity and the index have different betas.\n\nHere's a Python program that does this:\n\n```python\ndef solution():\n    # Define variables name and value\n    retirement_fund = 100000000 # $100 million fund\n    current_equity_allocation = 0.80\n    desired_equity_allocation = 0.60\n    index_value = 1200\n    multiplier = 250\n    equity_beta = 1.2\n    future_beta = 0.95\n\n    # Current equity position\n    current_equity_position = retirement_fund * current_equity_allocation\n    \n    # Desired equity position after adjustment\n    desired_equity_position = retirement_fund * desired_equity_allocation\n    \n    # Determine the change in position needed\n    position_change = current_equity_position - desired_equity_position\n    \n    # Adjust the position change for the difference in beta\n    beta_adjusted_position_change = position_change * (equity_beta / future_beta)\n    \n    # Calculate the number of futures contracts needed\n    number_of_contracts = beta_adjusted_position_change / (index_value * multiplier)\n    \n    # return the rounded number of contracts to be purchased (as it's not possible to purchase a fraction of a contract)\n    return round(number_of_contracts)\n```\n\nAfter running this program, you will get the number of stock index futures contracts needed to adjust the allocation of the equity in the retirement fund."
        ]
    },
    {
        "question_id": "validation-137",
        "question": "According to the analyst's data within the context of the capital asset pricing model, if the anticipated return for Share B is 11.4% and the risk-free rate is 3%, what is the projected return for the market?",
        "tables": [
            "| Security | Expected Standard Deviation(%) | Beta |\n|----------|-------------------------------|------|\n| Security 1 | 25 | 1.50 |\n| Security 2 | 15 | 1.40 |\n| Security 3 | 20 | 1.60 |"
        ],
        "python_solution": "def solution():\n    risk_free_rate = 3.0\n    expected_return_share_b = 11.4\n    beta = 1.4\n    market_risk_premium = (expected_return_share_b - risk_free_rate) / beta\n    return risk_free_rate + market_risk_premium",
        "ground_truth": 9.0,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\n# Import package if needs\ndef solution():\n    # Define variables name and value\n    expected_return_b = 0.114  # Expected return for Share B (11.4% as decimal)\n    risk_free_rate = 0.03      # Risk-free rate (3% as decimal)\n    beta_b = 1.40              # Beta for Security 2\n    \n    # Do math calculation to get the answer\n    # According to the Capital Asset Pricing Model (CAPM):\n    # Expected Return = Risk-Free Rate + Beta * (Market Return - Risk-Free Rate)\n    # Rearranging the formula to solve for the market return:\n    # Market Return = (Expected Return - Risk-Free Rate) / Beta + Risk-Free Rate\n    market_return = (expected_return_b - risk_free_rate) / beta_b + risk_free_rate\n    \n    # return the answer as a percentage\n    # Since we are asked for projected return for the market, we return the decimal as a percentage\n    answer = market_return * 100  # Convert to percentage\n    return round(answer, 1)  # Round to one decimal place, if needed\n    \n# Call the function and print the result for verification\nprint(solution())\n```\n\nThis program defines the necessary variables and uses the CAPM formula to solve for the expected market return, then returns the result as a percentage, rounding to one decimal place if necessary."
        ]
    },
    {
        "question_id": "validation-138",
        "question": "What should be the total cost reported on the balance sheet for the scientific equipment that Corporation BMT bought for its product development?",
        "tables": [
            "| Purchase price | $32,500 |\n| -------------- | ------- |\n| Freight and insurance | $2,100 |\n| Installation  | $800 |\n| Testing | $500 |\n| Training staff on maintaining machine | $1000 |"
        ],
        "python_solution": "def solution():\n    equipment_cost = 32500\n    delivery_cost = 2100 \n    installation_cost = 800\n    testing_cost = 500\n    total_cost = equipment_cost + delivery_cost + installation_cost + testing_cost\n    return total_cost",
        "ground_truth": 35900.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    purchase_price = 32500\n    freight_and_insurance = 2100\n    installation = 800\n    testing = 500\n    training_staff = 1000\n    \n    # Do math calculation to get the total cost\n    total_cost = purchase_price + freight_and_insurance + installation + testing + training_staff\n    \n    # Return answer\n    return total_cost\n\n# Note: If you want to execute the function to see the result, you can call the function like this:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-139",
        "question": "According to the financial information of a PE fund named XZY Corporation with a carried interest rate of 20%, and which has a total pledged capital of $100 million. At the end of the last year, the total paid-in capital was $90 million while $30 million was the total distributions given to LPs. The value of year-end NAV, both before and after distributions, stood at $160 million and $130 million respectively. Their projected NAV before any distributions for the next year is $250 million. What is their forecasted carried interest for the next year?",
        "tables": [],
        "python_solution": "def solution():\n    committed_capital = 100\n    nav_before_distribution = 250\n    nav_before_distribution_prev = 160\n    carried_interest_rate = 20 / 100\n    if nav_before_distribution > committed_capital:\n        carried_interest = (nav_before_distribution - nav_before_distribution_prev) * carried_interest_rate\n        return carried_interest\n    else:\n        return 0",
        "ground_truth": 18.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    carried_interest_rate = 0.20\n    total_pledged_capital = 100000000\n    total_paid_in_capital = 90000000\n    total_distributions = 30000000\n    year_end_NAV_before_distribution = 160000000\n    year_end_NAV_after_distribution = 130000000\n    projected_NAV_next_year = 250000000\n    \n    # Calculate the hurdle: total paid-in capital plus total distributions\n    hurdle = total_paid_in_capital + total_distributions\n    \n    # Calculate the net profits: projected NAV (next year) - hurdle\n    net_profits = projected_NAV_next_year - hurdle\n\n    # Calculate the carried interest: net profits * carried interest rate\n    carried_interest = net_profits * carried_interest_rate if net_profits > 0 else 0\n    \n    # return answer\n    return carried_interest\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis Python program calculates the forecasted carried interest for the next year based on the provided financial information of the XZY Corporation."
        ]
    },
    {
        "question_id": "validation-140",
        "question": "What will be the worth of $75,000 invested now for six years at an annual interest rate of 7% compounded quarterly?",
        "tables": [],
        "python_solution": "def solution():\n    PV = 75000\n    r = 0.07\n    N = 6\n    m = 4\n\n    FV = PV * (1 + r/m)**(m*N)\n    \n    return int(FV) # rounding down intentionally as per the requirements.",
        "ground_truth": 113733.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    principal = 75000  # Initial amount invested\n    annual_rate = 0.07  # Annual interest rate in decimal form\n    compounding_frequency = 4  # Quarterly compounding\n    time_in_years = 6  # Investment duration in years\n    \n    # Do math calculation to get the future value\n    future_value = principal * ((1 + annual_rate / compounding_frequency) ** (compounding_frequency * time_in_years))\n    \n    # return answer\n    return future_value\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-141",
        "question": "Based on the information given in the chart, what is the deferred tax liability (in millions) at the end of 2014 for a firm that has newly appraised a depreciable asset, predicting its remaining lifespan will be an additional 20 years? The tax rate for all the years is 30% and note that tax laws do not recognize the asset's revaluation.",
        "tables": [
            "| Original Values and Estimates (millions) | Accounting Purposes | Tax Purposes |\n| ---------------------------------------- | ------------------- | ------------ |\n| Acquisition cost in 2011                | £8,000              | £8,000       |\n| Depreciation, straight line              | 20 years            | 8 years      |\n| Accumulated depreciation, end of 2013   | £1,200              | £3,000       |\n| Net balance, end of 2013                | £6,800              | £5,000       |\n| **Re-estimated Values and Estimates, Start of 2014** |               |              |\n| Revaluation balance, start of 2014      | £10,000             | Not applicable |\n| New estimated life                      | 20 years            |              |"
        ],
        "python_solution": "def solution():\n    tax_rate = 0.30\n    tax_base = 4000\n    carrying_amount = 6300\n    deferred_tax_liability = tax_rate * (carrying_amount - tax_base)\n    return deferred_tax_liability",
        "ground_truth": 690.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    acquisition_cost = 8000  # in millions\n    accounting_depreciation_years = 20  # Accounting purposes (originally and after revaluation)\n    tax_depreciation_years = 8  # Tax purposes\n    accumulated_depreciation_accounting = 1200  # in millions at the end of 2013\n    accumulated_depreciation_tax = 3000  # in millions at the end of 2013\n    revaluation_balance = 10000  # in millions at the start of 2014\n    net_balance_accounting = 6800  # in millions at the end of 2013\n    net_balance_tax = 5000  # in millions at the end of 2013\n    tax_rate = 0.30  # 30%\n\n    # Calculate the annual depreciation\n    annual_depreciation_accounting = revaluation_balance / accounting_depreciation_years\n    annual_depreciation_tax = acquisition_cost / tax_depreciation_years\n\n    # Update the accumulated depreciation at the end of 2014\n    accumulated_depreciation_accounting_end_2014 = accumulated_depreciation_accounting + annual_depreciation_accounting\n    accumulated_depreciation_tax_end_2014 = accumulated_depreciation_tax + annual_depreciation_tax\n\n    # Calculate the net book values at the end of 2014\n    net_book_value_accounting = revaluation_balance - accumulated_depreciation_accounting_end_2014\n    net_book_value_tax = acquisition_cost - accumulated_depreciation_tax_end_2014\n\n    # Calculate the temporary difference\n    temporary_difference = net_book_value_accounting - net_book_value_tax\n\n    # Calculate the deferred tax liability\n    deferred_tax_liability = temporary_difference * tax_rate\n\n    # return answer\n    return deferred_tax_liability\n\n# Call the solution function and print the result\nresult = solution()\nprint(f\"The deferred tax liability at the end of 2014 is £{result} million.\")\n```\n\nIn this program, I have calculated the annual depreciation expense for both accounting and tax purposes, updated the accumulated depreciation for the year 2014, found the net book values for accounting and tax purposes at the end of 2014, and then found the temporary difference between them. The deferred tax liability is then calculated by applying the tax rate to the temporary difference."
        ]
    },
    {
        "question_id": "validation-142",
        "question": "What is the standard deviation of sales for an organization, given its probability distribution?",
        "tables": [
            "| Probability | Sales ($ millions) |\n|-------------|--------------------|\n| 0.05        | 70                 |\n| 0.70        | 40                 |\n| 0.25        | 25                 |"
        ],
        "python_solution": "def solution():\n    # defining probabilities and sales\n    prob = [0.05, 0.70, 0.25]\n    sales = [70, 40, 25]\n\n    # calculating expected sales\n    expected_sales = sum(p*s for p, s in zip(prob, sales))\n\n    # calculating variance\n    variance = sum(p*((s - expected_sales) ** 2) for p, s in zip(prob, sales))\n\n    # computing the standard deviation\n    std_dev = variance ** 0.5\n\n    return std_dev",
        "ground_truth": 9.808,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    probabilities = [0.05, 0.70, 0.25]\n    sales = [70, 40, 25]\n\n    # Calculate the expected value of the sales\n    expected_value = sum(p * s for p, s in zip(probabilities, sales))\n    \n    # Calculate the variance of the sales\n    variance = sum(p * ((s - expected_value) ** 2) for p, s in zip(probabilities, sales))\n    \n    # Calculate the standard deviation of the sales\n    standard_deviation = math.sqrt(variance)\n    \n    # return answer\n    return standard_deviation\n    \n# The following line is to output the answer\n# print(solution())\n```\n\nThis program calculates the standard deviation of sales for an organization based on the given probability distribution. It first determines the expected value, then the variance, and finally takes the square root of the variance to find the standard deviation."
        ]
    },
    {
        "question_id": "validation-143",
        "question": "XYZ SF, a home decor retailing corporation, provides its workers with a defined benefit retirement plan. The company's contributions stand at 1,200. The PBO at the start of the year was 45,000 and by the end of the year, it was 43,500. The plan's assets were valued at 40,800 at the start and 39,650 at the end of the year. Can you compute the overall recurring pension cost utilizing this provided data?",
        "tables": [],
        "python_solution": "def solution():\n    ending_funded_status = 39650 - 43500\n    beginning_funded_status = 40800 - 45000\n    company_contribution = 1200\n    tppc = ending_funded_status - beginning_funded_status - company_contribution\n    return abs(tppc)",
        "ground_truth": 850.0,
        "topic": "Accounting",
        "output": [
            "To calculate the overall recurring pension cost, we need to find out the service cost, interest cost, return on plan assets, and any other components that make up the pension cost.\n\nThe service cost can often be considered the new benefits earned by employees during the year and is often given by the company or estimated based on the plan's formula. Since this information is not provided, we will assume it to be the company's contributions unless mentioned otherwise.\n\nThe interest cost is the increase in the projected benefit obligation (PBO) due to the passage of time. This is not provided directly, but we can estimate it based on the change in PBO during the year, considering there are no other sources of change such as plan amendments, settlements, or curtailments.\n\nThe expected return on plan assets is the income earned from the assets in the plan, such as dividends from stocks or interest from bonds. This can be calculated based on the change in the plan's assets value during the year.\n\nOther adjustments might include past service costs, actuarial gains and losses, and amortization of existing deferred amounts, but these are not mentioned in the provided data.\n\nHere is the Python program that calculates the overall recurring pension cost:\n\n```python\ndef solution():\n    # Define variables name and value\n    company_contributions = 1200\n    beginning_pbo = 45000\n    ending_pbo = 43500\n    beginning_plan_assets = 40800\n    ending_plan_assets = 39650\n    \n    # The actual service cost would need to be provided by the company, but based on the example we'll assume \n    # it is the company's contributions since we have no other information to go on\n    service_cost = company_contributions\n    \n    # Estimating the interest cost, assuming that all changes in PBO are due to the interest cost\n    # and there are no other plan amendments or curtailments\n    interest_cost = ending_pbo - beginning_pbo\n    \n    # Calculate the return on plan assets\n    actual_return_on_assets = beginning_plan_assets - ending_plan_assets\n    \n    # Add the service and interest cost, then subtract the return on assets\n    pension_cost = service_cost + interest_cost - actual_return_on_assets\n    \n    # return answer\n    return pension_cost\n\n# Call the solution function and print the result for verification\nprint(solution())\n```\nRemember, this is a simplification as a full pension cost calculation would require more detailed information about the defined benefit pension plan and its actuarial assumptions."
        ]
    },
    {
        "question_id": "validation-144",
        "question": "John oversees a fund, with the returns for the first three years displayed below: What will be the holding period return?",
        "tables": [
            "| Year | Investment | Return |\n|------|------------|--------|\n| 1    | $500       | 12%    |\n| 2    | $600       | 5%     |\n| 3    | $1000      | 1%     |"
        ],
        "python_solution": "def solution():\n    HPR = (1.12 * 1.05 * 1.01) - 1\n    return HPR * 100",
        "ground_truth": 18.776,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define the investment and returns for each year\n    investments = [500, 600, 1000]\n    returns = [0.12, 0.05, 0.01]\n\n    # Calculate the total amount after each investment period\n    total_return_percent = 0\n    total_investment = 0\n\n    for i in range(len(investments)):\n        total_return_percent += investments[i] * returns[i]\n        total_investment += investments[i]\n\n    # Calculate the holding period return (HPR)\n    holding_period_return = total_return_percent / total_investment\n\n    # Return the answer as a percentage\n    return holding_period_return * 100\n\n# Call the function and print the result if you want to display the result\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-145",
        "question": "Taking into account the provided data, what number of shares should be applied when figuring out the business' diluted EPS? The business had 60,000 common shares out in the open all through the year and also had 5,000 outstanding warrants throughout the entire year, each can be converted into share at $25 per share. The stock's price at the end of year was $30, and the average stock price for the year of the business was $20.",
        "tables": [],
        "python_solution": "def solution():\n    common_shares = 60000\n    warrants = 5000\n    exercise_price = 25\n    avg_price = 20\n\n    if avg_price < exercise_price:\n        return common_shares\n    else:\n        return common_shares + warrants\n    return common_shares",
        "ground_truth": 60000.0,
        "topic": "Accounting",
        "output": [
            "Here's a Python program to calculate the number of shares to be applied when figuring out the business's diluted EPS:\n\n```python\ndef solution():\n    # Define the variables\n    common_shares_outstanding = 60000\n    warrants_outstanding = 5000\n    conversion_price_per_warrant = 25\n    year_end_stock_price = 30\n    average_stock_price_for_year = 20\n\n    # Calculate the number of shares resulting from warrant conversion\n    # if the conversion is advantageous (market price > conversion price)\n    if year_end_stock_price > conversion_price_per_warrant:\n        cash_received_from_warrant_conversion = warrants_outstanding * conversion_price_per_warrant\n        shares_issued_from_warrants = cash_received_from_warrant_conversion / year_end_stock_price\n\n        # Total shares for diluted EPS includes both common shares and shares from warrant conversion\n        total_shares_for_diluted_eps = common_shares_outstanding + shares_issued_from_warrants\n    else:\n        # If the conversion is not advantageous, do not convert, and only common shares are considered\n        total_shares_for_diluted_eps = common_shares_outstanding\n\n    # return answer\n    return total_shares_for_diluted_eps\n\nnumber_of_shares = solution()\nprint(f\"The number of shares to be applied for diluted EPS is: {number_of_shares}\")\n```\n\nPlease note that in practice, companies may use more complex methods to calculate diluted EPS, including considering the treasury stock method for options and warrants, and whether it's a full year conversion or not. The treasury stock method would calculate incremental shares as `(market price - exercise price) * number of options / market price`. This is a simplified version without those considerations."
        ]
    },
    {
        "question_id": "validation-146",
        "question": "Louis is working on the valuation for XY Corporation, a producer and supplier of red wine that recently purchased a large bottling firm to expand its product range. This purchase will greatly influence XY's future outcomes. Knowing that XY projected EPS and Current share price are $2 and $40 respectively, what would be the most suitable price-to-earnings ratio to apply in the valuation of XY?",
        "tables": [],
        "python_solution": "def solution():\n    current_price = 40\n    projected_EPS = 2\n    PE_ratio = current_price / projected_EPS\n    return PE_ratio",
        "ground_truth": 20.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To find the most suitable price-to-earnings ratio for the valuation of XY Corporation, we divide the current share price by the projected earnings per share (EPS). Here's the Python program that performs this calculation:\n\n```python\ndef solution():\n    # Define variables name and value\n    projected_eps = 2  # Projected Earnings Per Share (EPS)\n    current_share_price = 40  # Current share price\n    \n    # Do math calculation to get the answer\n    pe_ratio = current_share_price / projected_eps\n    \n    # return answer\n    return pe_ratio\n    \n# Calling the function\nprint(solution())\n```\n\nPlease note that this program will provide a numerical answer based on current share price and projected EPS, which is how the P/E ratio is generally calculated. However, it must be understood that the most 'suitable' P/E ratio might involve more complexity in a real-world valuation, such as considering industry averages, growth rates, market conditions, and company specifics. This program does not consider those complexities and is a basic mathematical calculation."
        ]
    },
    {
        "question_id": "validation-147",
        "question": "Given the following performance figures for a substitute investment. Presume the highest drawdown risk remains consistent at 10.2% per time period. Also assume the mean drawdown risk remains constant at 6.8% per time period. Based on this information, can you work out the Calmar ratio using the conventional method? What does the Calmar ratio turn out to be?",
        "tables": [
            "| 1 Year | 3 Years | 5 Years | Since Inception |\n|--------|---------|---------|-----------------|\n| 5.3%   | 6.2%    | 4.7%    | 4.4%            |"
        ],
        "python_solution": "def solution():\n    average_compounded_return = 6.2\n    maximum_drawdown = 10.2\n    calmar_ratio = average_compounded_return / maximum_drawdown\n    return calmar_ratio",
        "ground_truth": 0.608,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "The Calmar Ratio is a measure of investment performance that is calculated by dividing the annualized rate of return by the maximum drawdown, typically expressed as a percentage. Assuming the since inception performance figure represents the annualized rate of return, we would use the since inception figure (4.4%) to calculate the Calmar Ratio. The maximum drawdown is provided as a consistent value of 10.2%.\n\nHere is the program to calculate the Calmar Ratio:\n\n```python\ndef solution():\n    # Define variables name and value\n    annualized_return = 4.4\n    max_drawdown = 10.2\n    \n    # Convert percentages to decimals\n    annualized_return /= 100\n    max_drawdown /= 100\n    \n    # Do math calculation to get the Calmar ratio\n    calmar_ratio = annualized_return / max_drawdown\n    \n    # return Calmar ratio\n    return calmar_ratio\n\n# Call the function and print the answer\nprint(solution())\n```\n\nExecuting this program will calculate the Calmar Ratio by dividing the since inception annualized return by the maximum drawdown, both expressed as decimal values. The `print` statement at the end is used to display the calculated Calmar Ratio."
        ]
    },
    {
        "question_id": "validation-148",
        "question": "Bloomfield informs Smith that he observed 500 shares of BYYP stock being traded every 20 minutes for a duration of an hour. He also tells Smith that he saw a similar trading pattern in the stock during the previous trading day. Bloomfield instructs Smith to place an order to buy BYYP stock, assuming that a trader is looking for liquidity and is executing a large purchase order by dividing it into smaller parts. Based on Exhibit 1, what is the average effective spread of the BYYP transactions?",
        "tables": [
            "| Trade | Trade Price | Prevailing Bid | Prevailing Offer |\n|-------|-------------|----------------|------------------|\n| 1     | 41.50       | 41.45          | 41.50            |\n| 2     | 41.75       | 41.73          | 41.75            |"
        ],
        "python_solution": "def solution():\n    trade1_price = 41.50\n    trade1_midpoint = 41.475\n    trade2_price = 41.75\n    trade2_midpoint = 41.74\n    \n    effective_spread_trade1 = 2 * (trade1_price - trade1_midpoint)\n    effective_spread_trade2 = 2 * (trade2_price - trade2_midpoint)\n    \n    average_effective_spread = (effective_spread_trade1 + effective_spread_trade2) / 2\n    \n    return average_effective_spread",
        "ground_truth": 0.035,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "To calculate the average effective spread, we need to look at the difference between the trade price and the midpoint of the prevailing bid and offer for each trade and then average this value across all the trades.\n\nThe midpoint for each trade is computed as (Prevailing Bid + Prevailing Offer) / 2. Then, the effective spread for each trade is twice the absolute value of the difference between the trade price and the midpoint, because the effective spread represents the cost both to buy and to sell, hence the multiplication by 2.\n\nLet's compute this in the Python program:\n\n```python\ndef solution():\n    # Data for trades\n    trades = [\n        {'trade_price': 41.50, 'prevailing_bid': 41.45, 'prevailing_offer': 41.50},\n        {'trade_price': 41.75, 'prevailing_bid': 41.73, 'prevailing_offer': 41.75}\n    ]\n    \n    # Initialize the total effective spread\n    total_effective_spread = 0\n    \n    # Calculate the effective spread for each trade\n    for trade in trades:\n        midpoint = (trade['prevailing_bid'] + trade['prevailing_offer']) / 2\n        effective_spread = 2 * abs(trade['trade_price'] - midpoint)\n        total_effective_spread += effective_spread\n    \n    # Calculate the average effective spread\n    average_effective_spread = total_effective_spread / len(trades)\n    \n    # return the answer\n    return average_effective_spread\n\n# Call the function to get the average effective spread\nprint(solution())\n```\n\nThe program calculates the average effective spread for the trades of BYYP stock provided in the table."
        ]
    },
    {
        "question_id": "validation-149",
        "question": "If a never-ending preferred share starts its initial three-monthly payout of $2.00 in five quarters, and the annual rate of yield needed is 6% compounding every quarter, what is the current value of the share?",
        "tables": [],
        "python_solution": "def solution():\n    A = 2.0\n    r = 0.06 / 4\n    N = 4\n    FV = A / r\n    PV = FV / ((1 + r) ** N)\n    return int(PV)",
        "ground_truth": 125.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    quarterly_payout = 2.00\n    # The quarterly rate is the annual rate divided by 4\n    quarterly_rate = 0.06 / 4\n    # The payouts start in five quarters, so they are delayed by 5 periods.\n    delay_periods = 5\n    \n    # Calculate the present value of a perpetuity using the formula PV = C / r\n    # It is necessary to adjust the payout and the rate to account for the delay\n    present_value = (quarterly_payout / quarterly_rate)\n    \n    # Calculate the present value of the delayed perpetuity\n    present_value_delayed = present_value / ((1 + quarterly_rate)**delay_periods)\n    \n    # return answer\n    return round(present_value_delayed, 2)\n\n# Note: The rounding is done to match financial practice where results are often needed to two decimal places.\n```\n\nThis program calculates the current value of a perpetual preferred share that starts payouts in five quarters, given a quarterly payout and desired rate of yield. It uses the formula for the present value of a perpetuity, adjusted for the delay in payouts. The result is rounded to two decimal places to conform with common financial reporting standards."
        ]
    },
    {
        "question_id": "validation-150",
        "question": "If Corporation B purchases a license for $6,500, intending to utilize it for four years but expecting to gain benefits from it for only three years and applying the straight-line amortization method, what would be the accumulated amortization at the conclusion of Year 2?",
        "tables": [],
        "python_solution": "def solution():\n    license_cost = 6500\n    useful_years = 3\n    year = 2\n    annual_amortization = license_cost / useful_years\n    accumulated_amortization = annual_amortization * year\n    return accumulated_amortization",
        "ground_truth": 4333.333,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    purchase_price = 6500\n    useful_life = 3\n    \n    # Calculate annual amortization expense using the straight-line method\n    annual_amortization = purchase_price / useful_life\n    # Calculate accumulated amortization at the end of Year 2\n    accumulated_amortization_end_of_year_2 = annual_amortization * 2\n    \n    # return the accumulated amortization at the end of Year 2\n    return accumulated_amortization_end_of_year_2\n\n# If you would like to use the function to calculate the accumulated amortization, you can call it like this:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-151",
        "question": "A buyer is thinking about acquiring a common share that comes with a $2.00 yearly dividend. The dividend is predicted to increase at a pace of 4 percent every year. If the buyer’s necessary return rate is 7 percent, what would be the inherent worth of the share?",
        "tables": [],
        "python_solution": "def solution():\n    D0 = 2.00\n    g = 0.04\n    r = 0.07\n    D1 = D0 * (1 + g)\n    V0 = D1 / (r - g)\n    return V0",
        "ground_truth": 69.333,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    dividend = 2.00\n    growth_rate = 0.04\n    required_return = 0.07\n    \n    # Do math calculation to get the answer\n    # Using the Gordon Growth Model to calculate the intrinsic value of the share.\n    intrinsic_value = dividend * (1 + growth_rate) / (required_return - growth_rate)\n    \n    # return answer\n    return intrinsic_value\n\n# Example usage:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-152",
        "question": "In the previous quarter, we noted the market share data of various businesses as follows: Based on this information, what is the concentration ratio of the four firms?",
        "tables": [
            "| Company   | Sales(in millions of€) |\n|-----------|-----------------------|\n| Ajiwo     | 500                   |\n| Bdfhyj    | 350                   |\n| Cegfd     | 270                   |\n| Ddgh      | 200                   |\n| Ebned     | 150                   |\n| All others| 40                    |"
        ],
        "python_solution": "def solution():\n    total_market_share = 500 + 350 + 270 + 200 + 150 + 40\n    top_4_firms_share = 500 + 350 + 270 + 200\n    concentration_ratio = top_4_firms_share / total_market_share\n    return concentration_ratio * 100",
        "ground_truth": 87.417,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Sales in millions for the top four firms\n    sales_ajiwo = 500\n    sales_bdfhyj = 350\n    sales_cegfd = 270\n    sales_ddgh = 200\n    \n    # All other firms are not in the top four so we ignore them in the concentration ratio\n    \n    # Calculate total sales for the top four firms\n    total_top_four_sales = sales_ajiwo + sales_bdfhyj + sales_cegfd + sales_ddgh\n    \n    # Do math calculation to get the concentration ratio\n    # Concentration ratio for the top four firms is their combined sales divided by the total sales\n    total_sales = total_top_four_sales + 40  # Including \"All others\"\n\n    concentration_ratio = total_top_four_sales / total_sales\n    \n    # return answer\n    return concentration_ratio\n    \n# Call the function to output the answer\nsolution()\n```"
        ]
    },
    {
        "question_id": "validation-153",
        "question": "The KY corporation is a company based in the US with US GAAP. It also has two subsidiaries in Europe: ZX financial service and CO financial consultant. Simon, CFA, has put together a forecast for KY's 2018 financial statement: Simon predicts that ZX financial service will have 3,500 in sales and 1,500 in cost of sales in 2018. If KY decides to employ the current rate method to translate the results of subsidiary ZX into US dollars, could you calculate the gross profit margin for 2018?",
        "tables": [
            "|   | Forecasted Balance Sheet Data for Ll at 31 December 2018 |\n|---|--------------------------------------------------------|\n| Cash | 120 |\n| Accounts receivable | 30 |\n| Inventory | 450 |\n| Fixed assets | 800 |\n| Total assets | 1,400 |\n| Liabilities | 320 |\n| Common stock | 780 |\n| Retained earning | 300 |",
            "|                               | Exchange rates ($/€) |\n|-------------------------------|----------------------|\n| when fixed assets were acquired | 1.55                 |\n| 31 December 2018               | 1.77                 |\n| 2018 average                    | 1.68                 |"
        ],
        "python_solution": "def solution():\n    sales = 3500\n    cost_of_sales = 1500\n\n    gross_profit = sales - cost_of_sales\n    gross_profit_margin = gross_profit / sales\n    \n    return gross_profit_margin",
        "ground_truth": 0.571,
        "topic": "Accounting",
        "output": [
            "To calculate the gross profit margin for subsidiary ZX's 2018 financial results, we need to convert the sales and cost of sales from euros to dollars using the current rate at 31 December 2018. The gross profit margin is calculated as:\n\\[ \\text{Gross Profit Margin} = \\frac{\\text{Sales} - \\text{Cost of Sales}}{\\text{Sales}} \\times 100\\% \\]\n\nThe current rate at 31 December 2018 is given as $1.77 for each euro. So we will convert euros to dollars using this exchange rate.\n\nHere is the Python program to calculate the gross profit margin:\n\n```python\ndef solution():\n    # Forecasted financial data for subsidiary ZX in euros\n    sales_eur = 3500\n    cost_of_sales_eur = 1500\n    \n    # Current exchange rate at 31 December 2018\n    exchange_rate = 1.77\n    \n    # Convert euros to dollars\n    sales_usd = sales_eur * exchange_rate\n    cost_of_sales_usd = cost_of_sales_eur * exchange_rate\n    \n    # Calculate gross profit and gross profit margin\n    gross_profit = sales_usd - cost_of_sales_usd\n    gross_profit_margin = (gross_profit / sales_usd) * 100\n    \n    # return gross profit margin\n    return gross_profit_margin\n\n# Call the function and print the answer\nprint(solution())\n```\n\nRunning this program will give you the gross profit margin in percentage for the subsidiary ZX for 2018."
        ]
    },
    {
        "question_id": "validation-154",
        "question": "Considering the events recorded in 2014, what was the net cash flow from investing activities for the firm, as shown on the 2014 cash flow statement (in thousands)?",
        "tables": [
            "|             | $ thousands |\n|-------------|-------------|\n| Purchase of securities for trading purposes | 240 |\n| Proceeds from the sale of trading securities | 300 |\n| Proceeds from issuance of bonds | 500 |\n| Purchase of 30% of the shares of an affiliated company | 275 |"
        ],
        "python_solution": "def solution():\n    purchase_affiliated_company = -275000\n    net_cash_flow = purchase_affiliated_company\n    return net_cash_flow/1000",
        "ground_truth": -275.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    purchase_of_trading_securities = 240\n    proceeds_from_sale_of_trading_securities = 300\n    proceeds_from_issuance_of_bonds = 500\n    purchase_of_affiliated_company_shares = 275\n\n    # Do math calculation to get the answer\n    # Note that proceeds from sales and issuance are positive cash flows,\n    # while purchase of securities is a negative cash flow.\n    # However, the purchase of an affiliate company's shares and proceeds from bonds\n    # are not typically included in cash flows from investing activities;\n    # bond proceeds are a financing activity, and affiliates are considered differently.\n    # Thus, only trading securities are considered here.\n    \n    net_cash_flowed_investing = proceeds_from_sale_of_trading_securities - purchase_of_trading_securities\n    \n    # return answer\n    return net_cash_flowed_investing\n\n# Call the function and print the result\nprint(solution())  # Output will be in $ thousands\n```\nThe program correctly calculates the net cash flow from investing activities by taking into account the cash inflow from the sale of trading securities and the outflow from the purchase of trading securities. The purchase of shares of an affiliated company is an investing activity, but proceeds from the issuance of bonds are a financing activity and therefore are not included in this calculation. The returned value will represent the net cash flow from investing activities in thousands of dollars."
        ]
    },
    {
        "question_id": "validation-155",
        "question": "Given the details about stock market fluctuations, with a 38% chance of it going up, a 46% chance of it staying the same, and a 16% chance of it falling, what is the likelihood that the stock's value will be at $45?",
        "tables": [
            "\n|              | Market continues to rise |      |      | Market unchanges |      |      | Market continues to decline |      |      |\n|--------------|--------------------------|------|------|------------------|------|------|------------------------------|------|------|\n| stock price  | $25                      | $45  | $60  | $25              | $45  | $60  | $25                          | $45  | $60  |\n| probability  | 5%                       | 65%  | 30%  | 35%              | 55%  | 9%   | 62%                          | 38%  | 0%   |\n"
        ],
        "python_solution": "def solution():\n    probability_up = 0.38 * 0.65\n    probability_same = 0.46 * 0.56\n    probability_down = 0.16 * 0.38\n    total_probability = probability_up + probability_same + probability_down\n    return total_probability * 100",
        "ground_truth": 56.54,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define the probabilities for each market condition\n    probability_market_rise = 0.38\n    probability_market_unchanged = 0.46\n    probability_market_decline = 0.16\n    \n    # Define the probabilities for the stock being at $45 given each market condition\n    probability_45_rise = 0.65 # 65% chance when market continues to rise\n    probability_45_unchanged = 0.55 # 55% chance when market unchanged\n    probability_45_decline = 0.38 # 38% chance when market continues to decline\n    \n    # Calculate the overall probability that the stock's value will be at $45\n    total_probability_45 = (\n        (probability_45_rise * probability_market_rise) +\n        (probability_45_unchanged * probability_market_unchanged) +\n        (probability_45_decline * probability_market_decline)\n    )\n    \n    # return answer\n    return total_probability_45\n    \n# The following line will print the result for quick debugging\n# print(solution())\n```\n\nWhen you run the `solution` function, it will return the combined probability of the stock price being at $45 under all market conditions."
        ]
    },
    {
        "question_id": "validation-156",
        "question": "In a repurchase agreement, Company X sells a bond with a face value of $10 million to Company Y on August 1, with an invoice price of $11 million for a 20-day period. Concurrently, Company X consents to reacquire the $10 million worth bond at a price equal to the initial invoice price plus an interest calculated at a repo rate of 20%. Based on the provided details, what is the repurchase cost?",
        "tables": [],
        "python_solution": "def solution():\n    face_value = 10  # face value of the bond in million\n    invoice_price = 11  # invoice price of the bond in million\n    repo_rate = 20 / 100  # repo rate\n    time_period = 20  # time period in days\n\n    repurchase_cost = invoice_price * (1 + repo_rate * time_period / 360)  # calculation of repurchase cost\n    return repurchase_cost  # return repurchase cost",
        "ground_truth": 11.122,
        "topic": "Risk Management",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    face_value = 10000000\n    invoice_price = 11000000\n    repo_rate = 0.20\n    days = 20\n    days_in_year = 365\n    \n    # Calculate the interest for the 20-day period\n    interest = (invoice_price * repo_rate) * (days / days_in_year)\n    \n    # Calculate the repurchase cost\n    repurchase_cost = invoice_price + interest\n    \n    # return answer\n    return repurchase_cost\n\n# Call the function to get the answer\nsolution()\n```"
        ]
    },
    {
        "question_id": "validation-157",
        "question": "Business B announced and distributed cash dividends worth $8 million and an impairment expense of $12 million in 2017. They categorized the dividend payment as a financing activity. What is the value of Business B's operating cash flow for 2017 (in $ millions)?",
        "tables": [
            "| Balances as of Year Ended 31 December | 2016 | 2017 |\n| --- | --- | --- |\n| Retained earnings | 110 | 125 |\n| Accounts receivable | 45 | 48 |\n| Inventory | 24 | 20 |\n| Accounts payable | 30 | 33 |"
        ],
        "python_solution": "def solution():\n    REB = 0\n    NI = 23\n    Div = 0\n    REE = 0\n    impairment = 12\n    AR_change = (48-45)\n    Inv_change = (20-24)\n    AP_change = (33-30)\n    CFO = NI + impairment - AR_change - Inv_change + AP_change\n    return CFO",
        "ground_truth": 39.0,
        "topic": "Accounting",
        "output": [
            "To determine the operating cash flow for Business B for the year 2017, we would typically need information from the company's cash flow statement. However, we can infer some aspects from the change in balance sheet accounts such as accounts receivable, inventory, and accounts payable, along with information about dividends and non-cash expenses (e.g., impairment). This inference is grounded in the indirect method of calculating operating cash flow, which starts with net income and adjusts for non-cash expenses and changes in working capital.\n\nGiven the information provided, we do not have the net income explicitly stated, but we can derive an estimate based on the change in retained earnings, addition of dividends, and the impairment expense. The calculation is as follows:\n\nOperating Cash Flow = Change in Retained Earnings + Dividends + Impairment Expense + Changes in Working Capital\n\nThe changes in working capital are derived from the changes in accounts receivable, inventory, and accounts payable. The change in retained earnings is the difference between the year-end retained earnings figures for 2016 and 2017.\n\nLet's use this information to write the Python program.\n\n```python\ndef solution():\n    # Define variables name and value\n    retained_earnings_2016 = 110\n    retained_earnings_2017 = 125\n    accounts_receivable_2016 = 45\n    accounts_receivable_2017 = 48\n    inventory_2016 = 24\n    inventory_2017 = 20\n    accounts_payable_2016 = 30\n    accounts_payable_2017 = 33\n    dividends = 8\n    impairment_expense = 12\n\n    # Calculate change in retained earnings\n    change_in_retained_earnings = retained_earnings_2017 - retained_earnings_2016\n\n    # Calculate changes in working capital\n    change_in_accounts_receivable = accounts_receivable_2016 - accounts_receivable_2017\n    change_in_inventory = inventory_2016 - inventory_2017\n    change_in_accounts_payable = accounts_payable_2017 - accounts_payable_2016\n\n    # Calculate total change in working capital\n    total_change_in_working_capital = change_in_accounts_receivable + change_in_inventory + change_in_accounts_payable\n\n    # Calculate operating cash flow\n    operating_cash_flow = change_in_retained_earnings + dividends + impairment_expense + total_change_in_working_capital\n\n    # return answer\n    return operating_cash_flow\n\n# Let's call the function and print out the operating cash flow for 2017\nprint(solution())\n```\n\nWhen you run the above program, it calculates the operating cash flow for Business B for the year 2017 based on the information available and the standard methodology employed when using the indirect method on cash flow statements."
        ]
    },
    {
        "question_id": "validation-158",
        "question": "Suppose the number of defective vehicles adheres to the Possion distribution. Also, suppose that 5% of the vehicles arriving at the production line are defective. Then, if you randomly pick 5 vehicles on the production line, what's the likelihood that one is defective?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    n = 5\n    p = 0.05\n    lambda_ = n * p\n    k = 1\n    probability = ((lambda_ ** k) * math.exp(-lambda_)) / math.factorial(k)\n    return probability",
        "ground_truth": 0.195,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom math import exp\n\ndef solution():\n    # Define variables name and value\n    lambd = 0.05  # The average number of defective vehicles (5% of 1)\n    k = 1  # Number of defective vehicles to find\n    n = 5  # Total number of vehicles sampled\n    \n    # The probability of exactly k successes (k defective vehicles) in n trials \n    # (vehicles) from a Poisson distribution is given by the formula\n    # P(k; λ) = (e^−λ * λ^k) / k!\n    \n    # Since we need the probability for exactly one defective vehicle,\n    # the formula simplifies to P(1; 0.05) = e^−0.05 * 0.05^1 / 1! \n    # which equals 0.05/e^0.05, since 1! = 1.\n    \n    # Do math calculation to get the answer\n    probability_one_defective = (exp(-lambd * n) * (lambd * n)**k) / 1\n    \n    # return answer\n    return probability_one_defective\n    \n# This would run the solution and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-159",
        "question": "What is the projected price value of a basis point for a bond that provides a 3% coupon rate with yearly coupons, has nine years until maturity, a yield-to-maturity of 5%, and is valued at 85.784357 per 100 of par value?",
        "tables": [],
        "python_solution": "def solution():\n    coupon_rate = 3\n    maturity_years = 9\n    yield_to_maturity = 5\n    bond_value = 85.784357\n\n    PV_minus = sum([coupon_rate/(1 + (yield_to_maturity - 0.01)/100)**i for i in range(1, maturity_years+1)])\n    PV_minus += 100/(1 + (yield_to_maturity - 0.01)/100)**maturity_years\n\n    PV_plus = sum([coupon_rate/(1 + (yield_to_maturity + 0.01)/100)**i for i in range(1, maturity_years+1)])\n    PV_plus += 100/(1 + (yield_to_maturity + 0.01)/100)**maturity_years\n\n    PVBP = (PV_minus - PV_plus) / 2\n\n    return PVBP",
        "ground_truth": 0.065,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the projected price value of a basis point (PVBP) for the given bond, we will need to consider the bond's cash flows and the change in yield. A basis point is 1/100th of a percentage point, so we will calculate the price change of the bond when the yield-to-maturity (YTM) changes by one basis point (0.01%).\n\nHere is the Python program that performs these calculations:\n\n```python\ndef bond_price(ytm, years, coupon_rate, par_value):\n    \"\"\"Calculate the price of the bond for a given yield to maturity.\"\"\"\n    price = 0\n    for t in range(1, years + 1):\n        # Calculate present value of each coupon payment and the face value\n        price += (coupon_rate * par_value) / ((1 + ytm)**t)\n    # Add present value of the par value (redeemed at maturity)\n    price += par_value / ((1 + ytm)**years)\n    return price\n\ndef solution():\n    # Define variables\n    coupon_rate = 0.03  # 3%\n    years_to_maturity = 9\n    ytm = 0.05  # Yield-to-maturity of 5%\n    par_value = 100  # Par value of the bond\n    current_price = 85.784357\n    \n    # Calculate the current bond price based on the 5% yield\n    price_at_current_yield = bond_price(ytm, years_to_maturity, coupon_rate, par_value)\n    \n    # Calculate the price of the bond if the YTM changes by 1 basis point (0.0001)\n    price_at_adjusted_yield = bond_price(ytm + 0.0001, years_to_maturity, coupon_rate, par_value)\n    \n    # The difference between the two prices is the projected price value of a basis point\n    pvbp = (price_at_current_yield - price_at_adjusted_yield)\n    \n    # return answer\n    return pvbp\n\n# print the result\nprint(solution())\n```\n\nThe above program includes a function `bond_price` that calculates the price of the bond given a certain yield to maturity, and then `solution` calculates the current price and the price after a 1 basis point adjustment to the yield. The difference gives us the PVBP. Note that we are assuming annual coupon payments as per question details."
        ]
    },
    {
        "question_id": "validation-160",
        "question": "Suppose a community has an established average of 1,000. Imagine that 1,600 samples are randomly selected (with replacement) from this community. The average of these observed samples turns out to be 998.7, and their standard deviation is 100. What is the standard error of the sample mean?",
        "tables": [],
        "python_solution": "def solution():\n    sample_std_dev = 100\n    n = 1600\n    std_error = sample_std_dev / (n ** 0.5)\n    return std_error",
        "ground_truth": 2.5,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Import package if needed\nfrom math import sqrt\n\ndef solution():\n    # Define variables name and value\n    sample_size = 1600\n    sample_standard_deviation = 100\n    \n    # Do math calculation to get the answer\n    standard_error = sample_standard_deviation / sqrt(sample_size)\n    \n    # return answer\n    return standard_error\n    \n```\n\nThis program returns the standard error of the sample mean, based on the provided sample size and standard deviation."
        ]
    },
    {
        "question_id": "validation-161",
        "question": "The Smith family has an investment portfolio that is comprised of $500,000 in stocks and $330,000 in fixed income products. The Smiths also own a house valued at $350,000, with $175,000 still owed on the mortgage. The total present value of their earnings before they retire is estimated to be $980,000, and the future expected consumption is projected to be worth $870,000 at present. The Smiths have plans to cover their children's college tuition costs amounting to $150,000 at present value. They also wish to establish a family foundation in 25 years, projected to be worth $600,000 at present. Using the information provided, prepare an economic balance sheet for the Smith family. Determine their economic net worth.",
        "tables": [],
        "python_solution": "def solution():\n    equity = 500000\n    fixed_income = 330000\n    residence = 350000\n    pre_retirement_earnings = 980000\n\n    mortgage_debt = 175000\n    consumption = 870000\n    tuition_fee = 150000\n    foundation = 600000\n\n    total_economic_assets = equity + fixed_income + residence + pre_retirement_earnings\n    total_economic_liabilities = mortgage_debt + consumption + tuition_fee + foundation\n    economic_net_worth = total_economic_assets - total_economic_liabilities\n    return economic_net_worth",
        "ground_truth": 365000.0,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Asset values\n    stocks = 500000\n    fixed_income = 330000\n    house_value = 350000\n    present_earnings = 980000\n    \n    # Liability values\n    mortgage = 175000\n    future_consumption = 870000\n    college_tuition = 150000\n    family_foundation = 600000\n    \n    # Calculate total assets and total liabilities\n    total_assets = stocks + fixed_income + house_value + present_earnings\n    total_liabilities = mortgage + future_consumption + college_tuition + family_foundation\n    \n    # Calculate economic net worth\n    economic_net_worth = total_assets - total_liabilities\n    \n    # return answer\n    return economic_net_worth\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-162",
        "question": "The products were sold to clients by XYZ Corporation on 30 June 2006 for an overall cost of €10,000. The sale conditions stipulate that the payment must be finalized within 30 days. The goods had a cost value of €8,000. What is the probable net shift in XYZ Corporation's total assets on 30 June 2006 due to this sale?",
        "tables": [],
        "python_solution": "def solution():\n    sales_price = 10000\n    cost_price = 8000\n    net_increase_assets = sales_price - cost_price\n    return net_increase_assets",
        "ground_truth": 2000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define the sales revenue and the cost of goods sold\n    sales_revenue = 10000\n    cost_of_goods_sold = 8000\n\n    # The probable net shift in total assets is calculated as the sales revenue minus the cost value of the goods sold\n    net_shift_in_total_assets = sales_revenue - cost_of_goods_sold\n\n    # return the net shift in total assets\n    return net_shift_in_total_assets\n\n# Note: This solution presumes that accounts receivable increase by the sales revenue amount and that there's a decrease in inventory by the cost of goods sold. This is a simplified calculation and doesn't consider other factors such as taxes or additional expenses that may be associated with the sale.\n```"
        ]
    },
    {
        "question_id": "validation-163",
        "question": "Assuming a tax rate of 35%, if a business is 60% financed by debt and has an equity beta of 1.4, what would be the asset beta of that business?",
        "tables": [],
        "python_solution": "def solution():\n    tax_rate = 0.35\n    debt_ratio = 0.60\n    equity_beta = 1.4\n    debt_to_equity_ratio = debt_ratio/(1 - debt_ratio)\n    asset_beta = equity_beta / (1 + ((1 - tax_rate)*debt_to_equity_ratio))\n    return asset_beta",
        "ground_truth": 0.709,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    tax_rate = 0.35\n    debt_ratio = 0.6\n    equity_beta = 1.4\n    equity_ratio = 1 - debt_ratio\n\n    # Do math calculation to get the answer\n    # The asset beta formula in a levered firm is given by:\n    # asset_beta = equity_beta / (1 + (1 - tax_rate) * (debt_ratio / equity_ratio))\n    asset_beta = equity_beta / (1 + (1 - tax_rate) * (debt_ratio / equity_ratio))\n    \n    # return answer\n    return asset_beta\n    \n# Call the function and print the result to verify the correct workings of the function\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-164",
        "question": "A retirement fund worth $100 million currently consists of 80% shares and 20% bonds. The beta of the shares section is 1.2, with the term of the bonds part being 5.0. How many stock index futures need to be purchased in order to shift the distribution to 60% shares and 40% bonds? Refer to the additional data: The value of the stock index stands at 1,200, the multiplier is $250, and the beta equals 0.95. The cost of a bond futures agreement is $105,300, which carries an underlying adjusted duration of 6.5.",
        "tables": [],
        "python_solution": "def solution():\n    current_value = 100000000\n    current_shares_value = 0.8 * current_value\n    target_shares_value = 0.6 * current_value\n    shares_value_to_be_shifted = current_shares_value - target_shares_value\n    beta_shares = 1.2\n    beta_stock_index = 0.95\n    stock_index_value = 1200\n    contract_price = 250\n    number_of_contracts = (0-beta_shares/beta_stock_index)*(shares_value_to_be_shifted/(stock_index_value * contract_price))\n    return int(number_of_contracts)",
        "ground_truth": -84.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Given values\n    fund_value = 100e6  # Total fund value ($100 million)\n    current_shares_percentage = 0.80\n    current_bonds_percentage = 0.20\n    target_shares_percentage = 0.60\n    target_bonds_percentage = 0.40\n    \n    # Beta values\n    shares_beta = 1.2\n    stock_index_beta = 0.95\n    \n    # Futures values\n    stock_index_value = 1200\n    stock_index_multiplier = 250\n    bond_future_price = 105300\n    bond_future_adjusted_duration = 6.5\n    \n    # Term of bonds\n    bond_term = 5.0\n    \n    # Calculate the current value of shares and bonds\n    current_value_of_shares = fund_value * current_shares_percentage\n    current_value_of_bonds = fund_value * current_bonds_percentage\n    \n    # Calculate the target value of shares and bonds\n    target_value_of_shares = fund_value * target_shares_percentage\n    target_value_of_bonds = fund_value * target_bonds_percentage\n    \n    # Calculate how much value needs to be adjusted for both shares and bonds\n    shares_difference = target_value_of_shares - current_value_of_shares\n    bonds_difference = target_value_of_bonds - current_value_of_bonds\n    \n    # Calculate the equity futures adjustment\n    equity_futures_adjustment = shares_difference / (stock_index_value * stock_index_multiplier)\n    \n    # Calculate the bond futures adjustment\n    bond_futures_adjustment = bonds_difference / (bond_future_price * bond_future_adjusted_duration)\n    \n    # Calculate the number of futures to buy/sell for stock index \n    number_of_stock_index_futures = equity_futures_adjustment * (shares_beta / stock_index_beta)\n    \n    # As the result is only required for stock index futures, rounding the result to the nearest integer\n    number_of_stock_index_futures = round(number_of_stock_index_futures)\n    \n    return number_of_stock_index_futures\n\n# Call the solution function\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-165",
        "question": "Assuming a 30% marginal tax rate and an additional 5% risk premium for shares as opposed to bonds, what is the cost of equity using the bond-yield-plus-risk-premium method for a 20-year, $1,000 non-callable bond with 8% annual coupons that is presently valued at $1,105.94?",
        "tables": [],
        "python_solution": "def solution():\n    # Define constants\n    risk_premium = 5\n    yield_to_maturity = 7\n\n    # Calculate cost of equity\n    cost_of_equity = yield_to_maturity + risk_premium\n    return cost_of_equity",
        "ground_truth": 12.0,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "Below is the Python program that calculates the cost of equity using the bond-yield-plus-risk-premium method:\n\n```python\ndef solution():\n    # Variables\n    annual_coupon = 0.08  # 8% annual coupon rate\n    bond_face_value = 1000  # $1,000 face value of the bond\n    bond_market_price = 1105.94  # Current market price of the bond\n    tax_rate = 0.30  # 30% marginal tax rate\n    risk_premium = 0.05  # 5% risk premium for shares\n    \n    # Calculate the annual coupon payment\n    annual_coupon_payment = annual_coupon * bond_face_value\n\n    # Calculate the cost of debt with tax adjustment\n    cost_of_debt_after_tax = (annual_coupon_payment / bond_market_price) * (1 - tax_rate)\n\n    # Calculate the cost of equity using the bond-yield-plus-risk-premium method\n    cost_of_equity = cost_of_debt_after_tax + risk_premium\n\n    # Return answer\n    return cost_of_equity\n\n# Call the function and print the result\nprint(solution())\n```\n\nBy running this code, you will obtain the cost of equity according to the bond-yield-plus-risk-premium method for the given bond."
        ]
    },
    {
        "question_id": "validation-166",
        "question": "Compute the equal-weighted index value for these three shares, assuming the starting index value is 121.",
        "tables": [
            "|          | March 31, 20X7 Share Price | March 31, 20X7 Number of Shares Outstanding (thousands) | April 30, 20X7 Share Price | April 30, 20X7 Number of Shares Outstanding (thousands) |\n|----------|---------------------------|-----------------------------------------------------|----------------------------|--------------------------------------------------------|\n| Stock X  | $15                       | 100                                                 | $20                        | 100                                                    |\n| Stock Y  | $20                       | 1,000                                               | $30                        | 1,000                                                  |\n| Stock Z  | $30                       | 2,000                                               | $25                        | 2,000                                                  |"
        ],
        "python_solution": "def solution():\n    starting_index = 121\n    shares = [(20/15-1), (30/20-1), (25/30-1)]\n    average_share = sum(shares) / len(shares)\n    new_index = starting_index * (1 + average_share)\n    return new_index",
        "ground_truth": 147.889,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    starting_index = 121\n    # Prices and outstanding shares as of March 31, 20X7\n    prices_march = [15, 20, 30]\n    shares_outstanding_march = [100, 1000, 2000]\n    \n    # Prices and outstanding shares as of April 30, 20X7\n    prices_april = [20, 30, 25]\n    shares_outstanding_april = [100, 1000, 2000]\n    \n    # Calculate total market capitalization for March 31, 20X7 and April 30, 20X7\n    total_market_cap_march = sum([price * shares for price, shares in zip(prices_march, shares_outstanding_march)])\n    total_market_cap_april = sum([price * shares for price, shares in zip(prices_april, shares_outstanding_april)])\n    \n    # Calculate the equal-weighted index value\n    ratio = total_market_cap_april / total_market_cap_march\n    equal_weighted_index = starting_index * ratio\n    \n    # return answer\n    return equal_weighted_index\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program will calculate the equal-weighted index value for the three shares by first calculating the total market capitalization for each date, then comparing the ratio of the April market cap to the March market cap and applying that ratio to the starting index value to get the equal-weighted index value."
        ]
    },
    {
        "question_id": "validation-167",
        "question": "Lillian, who is the portfolio manager for BC pension, has recently been considering the inclusion of QX Corp. (New York Stock Exchange:  QX) to her portfolio. After a thorough analysis of the company and its competitors, she is of the opinion that the company will witness exceptional growth for the next 4 years followed by normal growth. Therefore, she concludes that a two-stage DDM is the most suitable for assessing the stock's value. In 2017, the total dividends QX Corp. paid was $0.22. She anticipates a growth rate of 12 percent for the upcoming 4 years and 6 percent thereafter. The required return is projected to be 9 percent. What would be the terminal value of the stock according to this method?",
        "tables": [],
        "python_solution": "def solution():\n    D_0 = 0.22\n    g_short_term = 0.12\n    g_long_term = 0.06\n    r = 0.09\n    n = 4\n\n    D_n = D_0 * ((1 + g_short_term) ** n)\n    P_n = D_n * (1 + g_long_term) / (r - g_long_term)\n    \n    return P_n",
        "ground_truth": 12.231,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define the variables\n    # Dividends for the current year\n    D0 = 0.22\n    # Growth rate for the first stage\n    g1 = 0.12\n    # Growth rate for the second stage\n    g2 = 0.06\n    # Required rate of return\n    r = 0.09\n    \n    # Do math calculation to get the terminal value at the end of Year 4\n    # Calculate the dividend for each of the first 4 years \n    D1 = D0 * (1 + g1)\n    D2 = D1 * (1 + g1)\n    D3 = D2 * (1 + g1)\n    D4 = D3 * (1 + g1)\n    \n    # Calculate the terminal value at the end of the year 4 \n    # using the Gordon Growth Model which assumes a constant growth thereafter\n    terminal_value = D4 * (1 + g2) / (r - g2)\n    \n    # return the terminal value\n    return terminal_value\n\n# Call the function and print the output\nprint(solution())\n```\n\nThis program has a function that calculates the terminal value at the end of the 4th year by first calculating the dividends for each of the first 4 years considering the initial dividend and the growth rate for that period. It then calculates the terminal value using the Gordon Growth Model which is a model for determining the present value of a stock based on a future series of dividends that grow at a constant rate. The terminal value is the present value at the end of the high-growth period."
        ]
    },
    {
        "question_id": "validation-168",
        "question": "A bond is presently priced at 98.722 for every 100 of face value. If the yield-to-maturity (YTM) of this bond increases by 10 basis points, the complete price of the bond is forecasted to descend to 98.669. If the bond's YTM diminishes by 10 basis points, the total price of the bond is projected to ascend to 98.782. Can you determine the approximate convexity of this bond?",
        "tables": [],
        "python_solution": "def solution():\n    PV_minus = 98.782\n    PV_plus = 98.669\n    PV_0 = 98.722\n    delta_yield = 0.001\n    approx_convexity = (PV_minus + PV_plus - 2*PV_0) / (delta_yield**2 * PV_0)\n    return approx_convexity",
        "ground_truth": 70.906,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! To determine the approximate convexity of a bond, we can use the following formula for convexity approximation:\n\nConvexity ≈ (P(+) + P(-) - 2P(0)) / (2 * P(0) * Δy^2)\n\nwhere:\n- P(+) is the price of the bond if the yield decreases (98.782)\n- P(-) is the price of the bond if the yield increases (98.669)\n- P(0) is the initial price of the bond (98.722)\n- Δy is the change in yield in decimal form (10 basis points = 0.0010)\n\nLet's create a Python program to calculate the approximate convexity:\n\n```python\ndef solution():\n    # Define given bond prices and yield change\n    initial_price = 98.722  # P(0)\n    price_if_yield_decreases = 98.782  # P(+)\n    price_if_yield_increases = 98.669  # P(-)\n    change_in_yield = 0.0010  # Δy (10 basis points)\n    \n    # Calculate convexity using the approximation formula\n    convexity = (price_if_yield_decreases + price_if_yield_increases - 2 * initial_price) / (2 * initial_price * change_in_yield**2)\n    \n    # Return approximate convexity\n    return convexity\n\n# You can run the function to get the answer\nprint(solution())\n```\n\nPlease note that this calculation provides an approximation of the bond's convexity. In practice, more precise calculations would involve the bond's cash flows and the exact timing of those cash flows."
        ]
    },
    {
        "question_id": "validation-169",
        "question": "In light of the recent economic slump that negatively impacted the cyclical petrochemical industry, what would be the most fitting price-to-sales ratio for PetroChem Co, a publicly listed European petrochemical engineering company that Jacques is analyzing, if their net sales per share and current share price are $35 and $56 respectively?",
        "tables": [],
        "python_solution": "def solution():\n    net_sales_per_share = 35\n    current_share_price = 56\n    price_to_sales_ratio = current_share_price / net_sales_per_share\n    return price_to_sales_ratio",
        "ground_truth": 1.6,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    net_sales_per_share = 35\n    current_share_price = 56\n    \n    # Do math calculation to get the Price-to-Sales ratio\n    price_to_sales_ratio = current_share_price / net_sales_per_share\n    \n    # return answer\n    return price_to_sales_ratio\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe function `solution` calculates the price-to-sales (P/S) ratio by dividing the current share price by the net sales per share. When you run the function, it will return the P/S ratio, which represents how much investors are paying for a dollar of the company's sales."
        ]
    },
    {
        "question_id": "validation-170",
        "question": "Given the same data for a different business and assuming a 365-day year, what is the corporation's days of payables for the current year?",
        "tables": [
            "|                   | Current Year | Previous Year |\n|-------------------|--------------|---------------|\n| Sales             | $12,000      | $10,000       |\n| Cost of goods sold| $9,000       | $7,500        |\n| Inventory         | $1,200       | $1,000        |\n| Accounts payable  | $600         | $600          |"
        ],
        "python_solution": "def solution():\n    total_payables = 1000000  # assume\n    cost_of_goods_sold = 15324675  # assume\n\n    days_of_payables = (total_payables / cost_of_goods_sold) * 365\n    return days_of_payables",
        "ground_truth": 23.818,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cost_of_goods_sold_current_year = 9000\n    avg_accounts_payable = (600 + 600) / 2  # Average of current year and previous year\n\n    # Do math calculation to get the answer\n    payables_turnover = cost_of_goods_sold_current_year / avg_accounts_payable\n    days_of_payables = 365 / payables_turnover\n    \n    # return answer\n    return days_of_payables\n\n# The function call\nanswer = solution()\nprint(f\"The corporation's days of payables for the current year: {answer}\")\n```"
        ]
    },
    {
        "question_id": "validation-171",
        "question": "What is the percent of contribution to VaR from Asset A in a portfolio, that comprises of two assets: A and B, where Asset A's value is $5,000,000 with a marginal VaR of 0.0452 and Asset B's value is $3,000,000 with a marginal VaR of 0.0332?",
        "tables": [],
        "python_solution": "def solution():\n    asset_A_value = 5000000\n    asset_B_value = 3000000\n    asset_A_MVaR = 0.0452\n    asset_B_MVaR = 0.0332\n    component_VaR_A = asset_A_value * asset_A_MVaR\n    component_VaR_B = asset_B_value * asset_B_MVaR\n    portfolio_VaR = component_VaR_A + component_VaR_B\n    percent_of_contribution_to_VaR_A = component_VaR_A / portfolio_VaR\n    return percent_of_contribution_to_VaR_A * 100",
        "ground_truth": 69.41,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    asset_A_value = 5000000\n    asset_B_value = 3000000\n    marginal_VaR_A = 0.0452\n    marginal_VaR_B = 0.0332\n\n    # Calculate the total VaR\n    contribution_A = asset_A_value * marginal_VaR_A\n    contribution_B = asset_B_value * marginal_VaR_B\n    total_VaR = contribution_A + contribution_B\n\n    # Calculate the percent of contribution to VaR from Asset A\n    percent_contribution_A = (contribution_A / total_VaR) * 100\n\n    # return answer\n    return percent_contribution_A\n\n# Call the function to test\nprint(solution())  # This line is just for demonstrative purposes and can be omitted in actual answer submission\n```\n\nThe above program will calculate the percent of contribution to VaR from Asset A by first calculating the contribution of each asset to the total VaR and then finding the percentage contribution of Asset A."
        ]
    },
    {
        "question_id": "validation-172",
        "question": "An investment manager has a collection of options on XYZ, a stock that doesn't pay dividends. The collection consists of 5,000 deep in-the-money call options on XYZ and 20,000 deep out-of-the-money call options on XYZ. The portfolio also holds 10,000 future contracts on XYZ. Currently, XYZ is trading at USD 52. Given that there are 252 trading days annually, the volatility of XYZ is 12% per year, and each of the option and future contracts represents one share of XYZ, what is the 1-day 99% VaR of the portfolio?",
        "tables": [],
        "python_solution": "def solution():\n    position_delta = 1*5000 + 0*20000 + 1*10000\n    price_per_share = 52\n    volatility = 0.12\n    confidence_level = 2.326\n    trading_days = 252\n\n    var = confidence_level * price_per_share * position_delta * volatility * (1/trading_days)**0.5\n\n    return var",
        "ground_truth": 13714.668,
        "topic": "Risk Management",
        "output": [
            "To calculate the 1-day 99% Value at Risk (VaR) of the portfolio, we need to first calculate the daily volatility and then apply the VaR formula. The daily volatility (\\(\\sigma_{daily}\\)) can be calculated using the annual volatility (\\(\\sigma_{annual}\\)) as:\n\n\\[\n\\sigma_{daily} = \\frac{\\sigma_{annual}}{\\sqrt{252}}\n\\]\n\nThe VaR metric estimates how much a set of investments might lose, given normal market conditions, in a set time period such as a day. The 99% VaR is calculated by multiplying the daily volatility by the z-value of the probability level (in this case, 2.33 for a 99% confidence interval) and the current value of the assets in the portfolio. For simplicity, let's assume the deep in-the-money call options and deep out-of-the-money call options have no intrinsic value variation due to the deepness of their moneyness, which means we consider only the 10,000 future contracts in VaR calculation.\n\nThe formula for the 1-day 99% VaR is:\n\n\\[\n\\text{VaR} = \\text{Position Size} \\times \\text{Stock Price} \\times \\sigma_{daily} \\times z\n\\]\n\nWhere:\n- Position Size is the total number of shares represented by the future contracts, which is 10,000.\n- Stock Price is the current trading price of XYZ, which is USD 52.\n- \\(\\sigma_{daily}\\) is the daily volatility.\n- \\(z\\) is the z-score for the 99% confidence level, which is approximately 2.33 for a one-tailed test.\n\nLet's put this into a Python function:\n```python\nfrom math import sqrt\n\ndef solution():\n    # Given variables\n    annual_volatility = 0.12  # 12% annual volatility\n    stock_price = 52  # Current stock price in USD\n    position_size = 10000  # Number of future contracts representing shares\n    z_score = 2.33  # Z-score for 99% confidence interval\n    trading_days = 252\n    \n    # Convert annual volatility to daily volatility\n    daily_volatility = annual_volatility / sqrt(trading_days)\n    \n    # Calculate the 1-day 99% VaR\n    var = position_size * stock_price * daily_volatility * z_score\n    \n    # Return the VaR value\n    return var\n\n# See the result\nprint(solution())\n```\n\nPlease note that this calculation does not take into account the actual delta of the options or any intrinsic value the options may have. In a real-life scenario, these factors should be considered as well, and the calculation would be more complex, especially for options. The assumption is that the options are so deep in/out of the money that their delta is near 0/1 (for puts/calls respectively) and that their value wouldn't change significantly for a small change in the stock price over a single day."
        ]
    },
    {
        "question_id": "validation-173",
        "question": "The defined contribution pension plan of Redwood Inc. has periodic contributions of $6 million, service costs of $0.8 million, and an actuarial gain of $2.5 million. What is the total of the pension expense?",
        "tables": [],
        "python_solution": "def solution():\n    contributions = 6\n    service_costs = 0.8\n    gain = 2.5\n    # In a defined contribution pension plan, the pension expense is equal to the contributions made by the company\n    pension_expense = contributions  \n    return pension_expense",
        "ground_truth": 6.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    periodic_contributions = 6_000_000\n    service_costs = 800_000\n    actuarial_gain = 2_500_000\n    \n    # Do math calculation to get the answer\n    # Pension expense is the sum of service costs and actuarial losses,\n    # minus actuarial gains. Periodic contributions do not affect pension expense.\n    pension_expense = service_costs - actuarial_gain\n    \n    # return answer\n    return pension_expense\n    \n# This is the main function that calls the solution and \n# print the result which is the pension expense for Redwood Inc.\nif __name__ == \"__main__\":\n    print(f\"Pension Expense: {solution()}\")  # Should print the pension expense value\n```\n\nNote: Since actuarial gains decrease pension expense and there are no losses indicated in the problem, this formula simply subtracts gains from the service cost. Periodic contributions are generally set aside for funding the pension plan and are not considered an expense."
        ]
    },
    {
        "question_id": "validation-174",
        "question": "In her role as an analyst for REDD, Xiaomei Zhu focuses on the consumer credit sector. Zhu and her team collected data in 2012 to ascertain the projected return for this sector, as depicted in Exhibit 1. After evaluating various strategies, Zhu and her team chose to apply the bond-yield-plus-risk-premium method. Considering the information in Exhibit 1 and the technique employed by Zhu's team, what was the predicted return for the consumer credit industry in 2012?",
        "tables": [
            "| Securities and Interest Rates | Expected Yield (%) |\n| --- | --- |\n| 10-yearUS Treasury securities | 3.8 |\n| Short-term real rate | 2 |\n| Long-term real rate | 2.3 |\n| 10-year AA corporate bond yield | 4.4 |\n\n| Type of Premium | Premium (%) |\n| --- | --- |\n| Inflation premium | 0.8 |\n| Illiquidity premium | 0.9 |\n| Equity risk premium | 8.4 |"
        ],
        "python_solution": "def solution():\n    government_bond_yield = 3.8\n    equity_risk_premium = 8.4\n    expected_return = government_bond_yield + equity_risk_premium\n    return expected_return",
        "ground_truth": 12.2,
        "topic": "Market Analysis & Economics",
        "output": [
            "Based on the information provided and the bond-yield-plus-risk-premium approach, we can predict the return for the consumer credit industry. For this approach, we typically take the yield of a relevant bond and add a risk premium specific to the sector that is being analyzed. In this scenario, since the sector in question is consumer credit, the most appropriate benchmark might be the 10-year AA corporate bond yield, which needs to be augmented by specific premiums that reflect additional risks of the sector.\n\nThe equity risk premium is typically associated with stocks rather than bonds, so it might not directly apply here unless specified. The inflation and illiquidity premiums, on the other hand, are more relevant to bond investments. However, the information provided does not explicitly say which premiums to include.\n\nAssuming \"risk premium\" here encompasses both the illiquidity premium and the inflation premium (since these two are types of premiums relevant to bond yields), we would proceed as follows in the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    corporate_bond_yield = 4.4\n    inflation_premium = 0.8\n    illiquidity_premium = 0.9\n    \n    # Do math calculation to get the answer\n    # Assume risk premiums are additive\n    predicted_return = corporate_bond_yield + inflation_premium + illiquidity_premium\n    \n    # return answer\n    return predicted_return\n\n# Run the function and print the answer\nprint(f\"Predicted return for the consumer credit industry: {solution()}%\")\n```\n\nIf the Equity risk premium should be considered for some reason, though it typically applies to equities, it can be added as well:\n\n```python\ndef solution():\n    # Define variables name and value\n    corporate_bond_yield = 4.4\n    inflation_premium = 0.8\n    illiquidity_premium = 0.9\n    equity_risk_premium = 8.4\n    \n    # Do math calculation to get the answer\n    # Assume risk premiums are additive and that equity risk premium is also considered\n    predicted_return = corporate_bond_yield + inflation_premium + illiquidity_premium + equity_risk_premium\n    \n    # return answer\n    return predicted_return\n\n# Run the function and print the answer\nprint(f\"Predicted return, including equity risk premium: {solution()}%\")\n```\n\nHowever, it's important to note that without more context or specific requirements from the given scenario, it's uncertain whether the equity risk premium should be included in this calculation."
        ]
    },
    {
        "question_id": "validation-175",
        "question": "The small securities company's research department director, Brian, is in charge of a team that includes 2 junior analysts using the relative value approach to determine a company's worth. Brian informed the 2 junior analysts that using the earnings from the latest 4 quarters may not accurately reflect cyclical companies' long-term earning potential. Therefore, they may find significantly different P/E ratios even though the company's business outlook remains the same. Brian suggested using normalized EPS to solve this issue. Having gathered information about the company throughout the most recent complete cycle, the 2 junior analysts found that the company's balance sheet reveals total assets worth 2100 million and total liabilities of 1200 million. The value of the preferred equity is $120 million, and there are 32 million common shares outstanding. Given this information, what is the company's normalized EPS?",
        "tables": [
            "| Year | ROE   |\n|------|-------|\n| 2013 | 12.00%|\n| 2014 | 13.10%|\n| 2015 | 10.55%|\n| 2016 | 11.20%|\n| 2017 | 12.05%|"
        ],
        "python_solution": "def solution():\n    total_assets = 2100\n    total_liabilities = 1200\n    preferred_equity = 120\n    common_shares = 32\n    roe_values = [12.00, 13.10, 10.55, 11.20, 12.05]\n\n    average_roe = sum(roe_values) / len(roe_values)\n    total_shareholder_equity = total_assets - total_liabilities\n    common_equity_value = total_shareholder_equity - preferred_equity\n    bvps = common_equity_value / common_shares\n    normalized_eps = (average_roe / 100) * bvps\n\n    return normalized_eps",
        "ground_truth": 2.871,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the company's normalized EPS (Earnings Per Share), we need to first determine the average Return on Equity (ROE) over the complete business cycle (from 2013 to 2017). The ROE can be used to calculate the average earnings given that ROE = Net Income / Shareholder's Equity.\n\nOnce we have the average net income, we compute the equity available to common shareholders by subtracting the value of preferred equity from the total equity (which is total assets minus total liabilities). The normalized EPS is then calculated by dividing the average net income by the number of common shares outstanding.\n\nHere is the Python program that performs these calculations:\n\n```python\ndef solution():\n    # Define variables name and value\n    roe_years = [2013, 2014, 2015, 2016, 2017]\n    roes = [0.12, 0.131, 0.1055, 0.112, 0.1205]  # ROE values as decimals\n    total_assets = 2100  # in million dollars\n    total_liabilities = 1200  # in million dollars\n    preferred_equity = 120  # in million dollars\n    common_shares_outstanding = 32  # in million shares\n    \n    # Calculate average ROE over the given years\n    avg_roe = sum(roes) / len(roes)\n    \n    # Calculate equity\n    total_equity = total_assets - total_liabilities\n    # Equity available to common shareholders\n    common_equity = total_equity - preferred_equity\n    \n    # Calculate average net income using average ROE\n    avg_net_income = avg_roe * common_equity\n    \n    # Calculate normalized EPS (Earnings Per Share)\n    normalized_eps = avg_net_income / common_shares_outstanding\n    \n    # return answer\n    return normalized_eps\n\n# Execute the function and print the result\nnormalized_eps = solution()\nprint(\"The company's normalized EPS is:\", normalized_eps)\n```\n\nThe `solution()` function calculates the company's normalized EPS, and the result is printed at the end. Note that `roe_years` is not used in the calculation as it's not needed to compute the average ROE; it's just for reference."
        ]
    },
    {
        "question_id": "validation-176",
        "question": "Based on Exhibit 2, what is the average effective spread of the three trades when Smith talks about a market buy order for 5,000 shares of a thinly traded stock?",
        "tables": [
            "| Trade # | Time     | Trade Price | Trade Size | Bid Price | Ask Price |\n|---------|----------|-------------|------------|-----------|-----------|\n| 1       | 9.45 a.m.| $25.20      | 1,200      | $25.17    | $25.20    |\n| 2       | 9.55 a.m.| $25.22      | 1,300      | $25.19    | $25.22    |\n| 3       | 11.30 a.m.| $25.27     | 2,500      | $25.22    | $25.26    |"
        ],
        "python_solution": "def solution():\n    # trades prices\n    trade_prices = [25.20, 25.22, 25.27]\n    # bid and ask prices for each trade\n    bid_ask_prices = [(25.20, 25.17), (25.22, 25.19), (25.26, 25.22)]\n    \n    # calculate the effective spread for each trade\n    effective_spreads = [2 * (trade_price - ((ask + bid) / 2)) for trade_price, (ask, bid) in zip(trade_prices, bid_ask_prices)]\n    \n    # calculate the average effective spread\n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    return average_effective_spread",
        "ground_truth": 0.04,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "To calculate the average effective spread across the trades, we can subtract the bid price from the trade price (for market buy orders) and then take the average of these differences (spreads) for each trade.\n\nHere's a Python program that computes the average effective spread:\n\n```python\ndef solution():\n    # Define variables for trade prices, bid prices, and trade sizes\n    trades = [\n        {'trade_price': 25.20, 'bid_price': 25.17},\n        {'trade_price': 25.22, 'bid_price': 25.19},\n        {'trade_price': 25.27, 'bid_price': 25.22},\n    ]\n    \n    # Calculate effective spreads for each trade\n    effective_spreads = [(trade['trade_price'] - trade['bid_price']) * 2 for trade in trades]\n    \n    # Calculate average effective spread\n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    # Return answer\n    return average_effective_spread\n\n# Running the solution function and printing the answer\nprint(solution())\n```\n\nThe multiplication by 2 in the effective spreads calculation reflects the bid-ask spread being on both sides of the trade price (the difference between the trade execution price and both the bid and ask prices)."
        ]
    },
    {
        "question_id": "validation-177",
        "question": "If a two-year fixed-for-floating MRR swap is at 1.00%, and the yield of the two-year US Treasury bond is 0.63%, what would be the swap spread?",
        "tables": [],
        "python_solution": "def solution():\n    mrr_swap = 1.00\n    treasury_yield = 0.63\n    swap_spread = mrr_swap - treasury_yield\n    return swap_spread",
        "ground_truth": 0.37,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is the requested Python program to calculate the swap spread:\n\n```python\ndef solution():\n    # Define variables name and value\n    mrr_swap_rate = 1.00\n    treasury_bond_yield = 0.63\n    \n    # Do math calculation to get the answer\n    swap_spread = mrr_swap_rate - treasury_bond_yield\n    \n    # return answer\n    return swap_spread\n\n# You can call the solution function to get the answer.\nprint(solution())\n```\n\nWhen you run this program, it will output the swap spread."
        ]
    },
    {
        "question_id": "validation-178",
        "question": "An expert has compiled the major forecasts and assumptions for a J REIT. What is the inherent worth of the J REIT per share utilizing the two-step dividend discount model?",
        "tables": [
            "| Current risk-free rate | 3.00% |\n|------------------------|-------|\n| Beta of the T REIT     | 1.1   |\n| Market risk premium    | 5.00% |\n| Expected dividend per share, 1 year from today | $1.13 |\n| Expected dividend per share, 2 years from today| $1.22 |\n| Long-term growth rate in dividends, starting in year 3 | 5.00% |"
        ],
        "python_solution": "def solution():\n    discount_rate = 0.085\n    dividend_y1 = 1.13\n    dividend_y2 = 1.22\n    growth_rate = 0.05\n\n    stock_price = (dividend_y1 / (1+discount_rate)) + (dividend_y2 / ((1+discount_rate)**2)) + ((dividend_y2*(1+growth_rate))/(discount_rate-growth_rate))/((1+discount_rate)**2)\n    return stock_price",
        "ground_truth": 33.168,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the intrinsic value of the J REIT per share using the two-step dividend discount model (DDM), we need to discount the expected dividends for the first two years and then calculate the present value of all future dividends starting from year 3, assuming a constant growth rate from that point onward.\n\nThe formula to calculate the present value of the expected dividends for the first two years is:\n\nPV = D1 / (1 + r) + D2 / (1 + r)^2\n\nHere, PV is the present value, D1 and D2 are the expected dividends in years 1 and 2, respectively, and r is the required rate of return.\n\nThe required rate of return is computed using the Capital Asset Pricing Model (CAPM):\n\nr = risk_free_rate + beta * (market_risk_premium)\n\nTo find the present value of the dividends from year 3 into perpetuity, we use the Gordon Growth Model (a stage of the DDM), which calculates the present value of a perpetuity that grows at a constant rate:\n\nP3 = D3 / (r - g)\n\nwhere P3 is the present value of the dividends from year 3 onwards, D3 is the dividend in year 3 (which we calculate by taking year 2 dividend and growing it by the long-term growth rate), and g is the long-term growth rate.\n\nThe total intrinsic value of the J REIT per share is then the sum of PV and P3 discounted back to today's value.\n\nLet's write the Python program to calculate this:\n\n```python\ndef solution():\n    # Define variables name and value\n    risk_free_rate = 0.03\n    beta = 1.1\n    market_risk_premium = 0.05\n    expected_dividend_year_1 = 1.13\n    expected_dividend_year_2 = 1.22\n    long_term_growth_rate = 0.05\n\n    # Calculate the required rate of return using CAPM\n    required_return = risk_free_rate + beta * market_risk_premium\n\n    # Calculate the present value of dividends for year 1 and 2\n    present_value_dividends = (expected_dividend_year_1 / (1 + required_return) +\n                               expected_dividend_year_2 / ((1 + required_return) ** 2))\n\n    # Calculate the dividend for year 3 using the growth rate\n    dividend_year_3 = expected_dividend_year_2 * (1 + long_term_growth_rate)\n    \n    # Calculate the present value of all future dividends starting from year 3\n    present_value_perpetuity = dividend_year_3 / (required_return - long_term_growth_rate)\n\n    # Discount the perpetuity back to today's value (it is already in year 2 terms, so discount one period)\n    present_value_perpetuity_discounted = present_value_perpetuity / (1 + required_return)\n\n    # Sum the present values to get the intrinsic value per share\n    intrinsic_value = present_value_dividends + present_value_perpetuity_discounted\n    \n    # Return the intrinsic value rounded to two decimal places\n    return round(intrinsic_value, 2)\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThis program defines the variables based on the provided inputs, calculates the required rate of return using CAPM, computes the present values of the expected dividends in the first two years, calculates the continuation value using the Gordon Growth Model, and sums both to get the intrinsic value of the J REIT per share. The sum of these values provides the intrinsic value of the stock."
        ]
    },
    {
        "question_id": "validation-179",
        "question": "Azarov has requested Bector to implement the ML model on the test dataset for Dataset XYZ, considering a threshold p-value of 0.65. Exhibit 2 includes a specimen of outcomes from the test dataset corpus. Given the data in Exhibit 2, what is the accuracy computation for the test set sample of Dataset XYZ?",
        "tables": [
            "| Sentence # | Actual Sentiment | Target p-Value |\n|------------|------------------|----------------|\n| 1          | 1                | 0.75           |\n| 2          | 0                | 0.45           |\n| 3          | 1                | 0.64           |\n| 4          | 1                | 0.81           |\n| 5          | 0                | 0.43           |\n| 6          | 1                | 0.78           |\n| 7          | 0                | 0.59           |\n| 8          | 1                | 0.60           |\n| 9          | 0                | 0.67           |\n| 10         | 0                | 0.54           |"
        ],
        "python_solution": "def solution():\n    TP = 3\n    TN = 4\n    FP = 1\n    FN = 2\n    accuracy = (TP + TN)/(TP + FP + TN + FN)\n    return accuracy",
        "ground_truth": 0.7,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here's how you could write a Python function to compute the accuracy based on the provided data and the threshold p-value of 0.65:\n\n```python\ndef solution():\n    # Define variables name and value\n    threshold_p_value = 0.65\n    data = [\n        {\"Sentence\": 1, \"Actual Sentiment\": 1, \"Target p-Value\": 0.75},\n        {\"Sentence\": 2, \"Actual Sentiment\": 0, \"Target p-Value\": 0.45},\n        {\"Sentence\": 3, \"Actual Sentiment\": 1, \"Target p-Value\": 0.64},\n        {\"Sentence\": 4, \"Actual Sentiment\": 1, \"Target p-Value\": 0.81},\n        {\"Sentence\": 5, \"Actual Sentiment\": 0, \"Target p-Value\": 0.43},\n        {\"Sentence\": 6, \"Actual Sentiment\": 1, \"Target p-Value\": 0.78},\n        {\"Sentence\": 7, \"Actual Sentiment\": 0, \"Target p-Value\": 0.59},\n        {\"Sentence\": 8, \"Actual Sentiment\": 1, \"Target p-Value\": 0.60},\n        {\"Sentence\": 9, \"Actual Sentiment\": 0, \"Target p-Value\": 0.67},\n        {\"Sentence\": 10, \"Actual Sentiment\": 0, \"Target p-Value\": 0.54},\n    ]\n    \n    # Do math calculation to get the answer\n    correct_predictions = 0\n    total_predictions = len(data)\n    \n    for record in data:\n        predicted_sentiment = 1 if record[\"Target p-Value\"] >= threshold_p_value else 0\n        if predicted_sentiment == record[\"Actual Sentiment\"]:\n            correct_predictions += 1\n    \n    accuracy = correct_predictions / total_predictions\n    \n    # return answer\n    return accuracy\n\n# Call the solution function and print the accuracy\nprint(solution())\n```\n\nThis program defines the threshold p-value and then iterates through each record in the data, calculating whether the model's prediction is correct based on whether the p-value is above or below the threshold. It then calculates the accuracy by dividing the number of correct predictions by the total number of predictions."
        ]
    },
    {
        "question_id": "validation-180",
        "question": "The collection of investments includes two zero-coupon bonds, each priced at $10. The initial bond possesses a modified duration of a year, while the second bond carries a modified duration of nine years. With an even yield curve and a consistent yield of 5%, all alterations of the yield curve result in equal shifts. Given that the daily instability of the yield equals 1%, can you best estimate the daily value at risk (VAR) for the collection of investments at the 95% certainty level?",
        "tables": [],
        "python_solution": "def solution():\n    dollar_duration = 1*10 + 9*10\n    daily_var = dollar_duration * 0.01 * 1.65\n    return daily_var",
        "ground_truth": 1.65,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To calculate the daily value at risk (VAR) for the portfolio of investments at the 95% confidence level, we need to determine the total modified duration of the portfolio and apply the yield volatility to this total duration. Here is how we can write the Python program to perform this calculation:\n\n```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    bond1_duration = 1\n    bond2_duration = 9\n    bond_price = 10\n    number_of_bonds = 2\n    yield_volatility = 0.01  # 1%\n    confidence_level = 0.95\n    \n    # Calculate the portfolio duration: since we have 2 bonds and both contribute to the duration\n    portfolio_duration = bond1_duration + bond2_duration\n\n    # Calculate the daily yield change: 1% volatility \n    daily_yield_change = yield_volatility / 100\n\n    # Value at Risk calculation:\n    # VAR = Portfolio Value * Portfolio Duration * Daily Yield Change * Z-Score\n    # Get Z-Score for the 95% confidence level\n    z_score = norm.ppf(confidence_level)\n\n    # Since the price is the same for both bonds, we can simply double the price\n    portfolio_value = bond_price * number_of_bonds\n\n    # Calculate VAR\n    var = portfolio_value * portfolio_duration * daily_yield_change * z_score\n    \n    # return the absolute value of VAR as it represents a loss\n    return abs(var)\n\n# This is the VAR value at 95% confidence level\nvar_value = solution()\nprint(f\"The daily VAR at 95% confidence level is: {var_value}\")\n```\n\nThis program uses the scipy package to find the Z-score corresponding to the 95% confidence level. The VAR is calculated assuming that the bonds' prices are affected by the duration and the daily yield change. Here, the Z-score helps to scale the VAR to the 95% confidence level. The result will be the estimate of the maximum expected daily loss at the 95% confidence level due to the yield volatility of 1%."
        ]
    },
    {
        "question_id": "validation-181",
        "question": "For an investment of USD100 that produces after-tax cash flows of USD40 in the first year, USD80 in the second year, and USD120 in the third year, given a required rate of return of 20%, what would be the Net Present Value?",
        "tables": [],
        "python_solution": "def solution():\n    cash_flows = [-100, 40, 80, 120]\n    rate_of_return = 0.20\n    NPV = 0\n    for t in range(len(cash_flows)):\n        NPV += cash_flows[t] / ((1+rate_of_return) ** t)\n    return NPV",
        "ground_truth": 58.333,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "Here's a Python program that calculates the Net Present Value (NPV) for the given investment scenario:\n\n```python\ndef solution():\n    # Define variables name and value\n    cash_flows = [40, 80, 120]\n    investment = 100\n    rate_of_return = 0.20\n    \n    # Calculate Present Value for each cash flow and subtract the investment\n    npv = sum([cf / ((1 + rate_of_return) ** i) for i, cf in enumerate(cash_flows, start=1)]) - investment\n    \n    # return answer\n    return npv\n\n# Test the function\nprint(solution())  # Output should be the Net Present Value\n```\n\nThis function calculates the present value of each cash flow by dividing the cash flow by (1 + the required rate of return) raised to the power of the period number, where the first period is 1, not 0 (since the cash flows are received at the end of each year). Then it sums these values to get the total present value of the cash flows, and subtracts the initial investment to get the Net Present Value."
        ]
    },
    {
        "question_id": "validation-182",
        "question": "If a corporation issues a bond with specific features on January 1, 2014, and the market interest rate for its bonds stands at 5%, what would be its interest cost ( in millions) for the year 2014 under International Financial Reporting Standards (IFRS)?",
        "tables": [
            "| | |\n|---|---|\n|Face value|£50 million|\n|Coupon rate, paid annually|4%|\n|Time to maturity|10 years (31 December 2033)|\n|Issue price (per £100)|£92.28|"
        ],
        "python_solution": "def solution():\n    liability_value = 0.9228 * 50\n    market_rate = 0.05\n    interest_expense = liability_value * market_rate\n    return interest_expense",
        "ground_truth": 2.307,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    face_value = 50e6  # £50 million\n    coupon_rate = 0.04  # 4% annual\n    issue_price_per_100 = 92.28  # £92.28 per £100\n    market_interest_rate = 0.05  # 5%\n    \n    # Calculate the issue price of the bond\n    issue_price = (issue_price_per_100 / 100) * face_value\n    \n    # Calculate interest cost under IFRS for the year 2014\n    # Under IFRS, interest cost is calculated using the effective interest rate method\n    interest_cost = market_interest_rate * issue_price\n    \n    # Convert the interest cost to millions\n    interest_cost_millions = interest_cost / 1e6\n    \n    # return answer\n    return interest_cost_millions\n\n# Call the function and print the result\nprint(solution())\n```\n\nWhen you run this Python program, it will print out the interest cost in millions of pounds for the year 2014 calculated using the effective interest rate method according to IFRS."
        ]
    },
    {
        "question_id": "validation-183",
        "question": "At present, James has $750,000 in cash and short-term investment. He then consults with his portfolio manager Simmons regarding his investment holdings. As per the assessment, James' human capital is estimated at $1.2 million, out of which 30% appears to be similar to equity. Simmons concludes that a total target allocation of 45% equity is suitable for James. To reach the desired equity allocation for total economic wealth, what should be the financial capital equity allocation for James?",
        "tables": [],
        "python_solution": "def solution():\n    human_capital = 1200000\n    financial_capital = 750000\n    target_equity_allocation = 0.45\n\n    total_economic_wealth = human_capital + financial_capital\n    target_equity_allocation_value = total_economic_wealth * target_equity_allocation\n    human_capital_equity_allocation = human_capital * 0.30\n    financial_capital_equity_allocation = target_equity_allocation_value - human_capital_equity_allocation\n    financial_capital_equity_allocation_percentage = financial_capital_equity_allocation / financial_capital\n    \n    return financial_capital_equity_allocation_percentage * 100",
        "ground_truth": 69.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cash_and_investments = 750000  # James' current financial capital\n    human_capital = 1200000  # James' human capital\n    human_capital_equity_like = human_capital * 0.3  # Equity-like portion of human capital\n    total_target_equity_allocation = 0.45  # Target allocation of equity in total economic wealth\n    \n    # Calculate total economic wealth\n    total_economic_wealth = cash_and_investments + human_capital\n    \n    # Calculate desired value of equity in total economic wealth\n    desired_total_equity_value = total_economic_wealth * total_target_equity_allocation\n    \n    # Subtract equity-like portion of human capital to find financial capital equity allocation\n    financial_capital_equity_allocation = desired_total_equity_value - human_capital_equity_like\n    \n    # Return the financial capital equity allocation\n    return financial_capital_equity_allocation\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-184",
        "question": "Because of considerable growth prospects, Firm B has put a halt to its dividends for the earliest four years. The executives assert that during the fifth year, they will distribute a dividend of $2.5 for each share. After that, the dividend is predicted to expand at a 5% annual rate indefinitely. A 12% return rate is needed. What is the intrinsic value of Firm B's stock?",
        "tables": [],
        "python_solution": "def solution():\n    D5 = 2.5\n    r = 0.12\n    g = 0.05\n\n    P4 = D5 / (r - g)\n    V0 = P4 / (1 + r)**4\n\n    return V0",
        "ground_truth": 22.697,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is the Python program that calculates the intrinsic value of Firm B's stock:\n\n```python\ndef solution():\n    # Given values\n    dividend_year_5 = 2.5\n    growth_rate = 0.05\n    required_return = 0.12\n    \n    # Calculate the present value of the dividend in Year 5\n    # This is done by discounting the dividend to the present value\n    present_value_dividend_year_5 = dividend_year_5 / (1 + required_return)**5\n    \n    # Calculate the present value of the growth dividends using the Gordon Growth Model (dividing the dividend at t=5 by the difference of required return and growth rate)\n    present_value_growth_dividends = dividend_year_5 * (1 + growth_rate) / (required_return - growth_rate)\n    \n    # Discount the growth dividends back to present value (at t=0)\n    present_value_growth_dividends_discounted = present_value_growth_dividends / (1 + required_return)**5\n    \n    # Sum the present value of the first dividend and the present value of the growing dividends to get the intrinsic value\n    intrinsic_value = present_value_dividend_year_5 + present_value_growth_dividends_discounted\n    \n    # return answer\n    return intrinsic_value\n    \n# The result can be printed out if needed\n# print(solution())\n```\nThe `solution` function calculates the intrinsic value of Firm B's stock by first determining the present value of a single dividend payout in year 5 and then using the Gordon Growth Model to calculate the present value of all future growing dividends, accounting for the stock's required rate of return."
        ]
    },
    {
        "question_id": "validation-185",
        "question": "If ABC Corporation releases three-year bonds dated 1 January 2015 that have a face value of $5,000,000, how are they most likely reported as bonds payable when issued, considering the market interest rate for bonds of similar risk and term is 3% and the bonds yield an annual rate of 2.5% on 31 December?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 5000000 # Face Value of Bond\n    I_M = 0.03 # Market Interest Rate\n    I_B = 0.025 # Bond Yield Rate\n    N = 3 # Period of Bond in Years\n    PMT = FV * I_B # Annual Payments\n    PV = 0 # Present Value of Bond\n    \n    # Compute for Present value\n    for i in range(1, N+1):\n        PV += PMT/(1+I_M)**i # Compute Present Value based on Discount Factor Formula\n    PV += FV/(1+I_M)**N # Add the Face Value discounted back to today at Market Rate\n    \n    return PV",
        "ground_truth": 4929284.716,
        "topic": "Accounting",
        "output": [
            "The value at which the bonds are reported on the balance sheet when issued depends on the difference between the market interest rate and the yield (coupon rate) of the bonds. If the market interest rate for bonds of similar risk and term is higher than the yield of the bond, the bond is issued at a discount. If it is lower, the bond is issued at a premium. Since the market interest rate (3%) is higher than the bond's annual rate (2.5%), ABC Corporation's bonds would be issued at a discount.\n\nTo calculate the present value of the bonds, we can discount each of the cash flows - the annual interest payments and the principal amount at maturity - at the market interest rate.\n\nHere's how the Python program would look like:\n\n```python\ndef calculate_present_value(face_value, market_rate, coupon_rate, years):\n    present_value = 0\n    # Calculate present value of annual coupon payments\n    for year in range(1, years + 1):\n        present_value += (face_value * coupon_rate) / ((1 + market_rate) ** year)\n    # Calculate present value of face value at maturity\n    present_value += face_value / ((1 + market_rate) ** years)\n    return present_value\n\ndef solution():\n    face_value = 5000000\n    market_rate = 0.03  # 3%\n    coupon_rate = 0.025  # 2.5%\n    years = 3  # Three-year bonds\n    \n    # Calculate present value of the bond\n    present_value = calculate_present_value(face_value, market_rate, coupon_rate, years)\n    \n    # return present value of the bonds when issued\n    return present_value\n```\n\nHowever, to keep it simple and as you have requested a structure with the answer directly defined within the `solution()` function, we will skip the custom function and just present the present value (PV) of the bonds using the formula for the present value of an annuity for the coupon payments and the present value of a lump sum for the face value:\n\n```python\ndef solution():\n    # Define variables\n    face_value = 5000000\n    market_rate = 0.03  # Market interest rate\n    coupon_rate = 0.025  # Bond yield (coupon rate)\n    years = 3  # Number of years until maturity\n\n    # Present value of the annual coupon payments\n    coupon_payment = face_value * coupon_rate\n    pv_coupons = coupon_payment * ((1 - (1 + market_rate) ** -years) / market_rate)\n    \n    # Present value of the face value at maturity\n    pv_face_value = face_value / ((1 + market_rate) ** years)\n    \n    # Calculate total present value of the bond\n    present_value = pv_coupons + pv_face_value\n    \n    # Return answer\n    return present_value\n\n# Call the function to get the answer\nprint(solution())\n```\nThis program would calculate the present value of the bond when issued on 31 December 2014, assuming the coupon payments are made once a year at the end of the year."
        ]
    },
    {
        "question_id": "validation-186",
        "question": "A financial expert is requested to calculate the VaR for a stake in Mega Healthcare Solutions Ltd. The firm's shares go for USD 26.00, with a daily volatility standing at 1.5%. Utilizing the delta-normal approach, what is the VaR at the 95% confidence level for a long position in an at-the-money put on this share with a delta of -0.5 spanning a 1-day holding period?",
        "tables": [],
        "python_solution": "def solution():\n    delta = 0.5\n    z_score = 1.645\n    volatility = 0.015\n    share_price = 26.0\n\n    Var = abs(delta) * z_score * volatility * share_price\n    return Var",
        "ground_truth": 0.321,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To calculate the Value at Risk (VaR) using the delta-normal approach, we need to apply the following formula:\n\n\\[ \\text{VaR} = - (\\text{Position Delta} \\times \\text{Price} \\times \\text{Volatility} \\times Z ) \\]\n\nwhere\n- Position Delta is the sensitivity of the option's price to a change in the price of the underlying asset.\n- Price is the current price of the underlying asset.\n- Volatility is the daily volatility of the underlying asset.\n- Z is the Z-score corresponding to the confidence level.\n\nFor a 95% confidence level, the corresponding Z-score for a one-tailed test is approximately 1.645 (since at a 95% confidence level, there's 5% in the tail).\n\nLet's now write a Python program to calculate the VaR:\n\n```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    price = 26.00  # Current price of the stock\n    daily_volatility = 0.015  # Daily volatility (1.5%)\n    delta = -0.5  # Option delta\n    confidence_level = 0.95  # 95% confidence\n    \n    # Calculate Z-score from the confidence level\n    z_score = norm.ppf(confidence_level)\n    \n    # Calculate VaR using the delta-normal approach\n    var = - (delta * price * daily_volatility * z_score)\n    \n    # return answer\n    return var\n\n# Output the Var\nprint(f\"The Value at Risk is: ${solution():.2f}\")\n```\n\nNote that we imported the `norm` function from the `scipy.stats` module to get the Z-score for the 95% confidence level. The `norm.ppf` function provides the quantile function, which is the inverse of the cumulative distribution function - this is equivalent to finding the Z-score."
        ]
    },
    {
        "question_id": "validation-187",
        "question": "What is the yearly geometric mean return of this investment over a three-year period?",
        "tables": [
            "| Year | Return(%) |\n|------|----------|\n| 2009 | 20       |\n| 2010 | -30      |\n| 2011 | 15       |"
        ],
        "python_solution": "def solution():\n    return ((1 + 0.2) * (1 - 0.3) * (1 + 0.15))**(1/3) - 1",
        "ground_truth": -0.011,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and values\n    returns = [0.20, -0.30, 0.15]\n    \n    # Calculate the product of (1 + returns)\n    product = 1\n    for r in returns:\n        product *= (1 + r)\n    \n    # Calculate the geometric mean\n    geometric_mean = product ** (1/len(returns)) - 1\n    \n    # Convert geometric mean to percentage\n    geometric_mean_percentage = geometric_mean * 100\n    \n    # return answer\n    return geometric_mean_percentage\n\n# Example usage\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-188",
        "question": "Can you determine the expected return on a stock using the Capital Asset Pricing Model, with a beta value of 0.6, given a risk-free rate of 8%, and a market return of 15%?",
        "tables": [],
        "python_solution": "def solution():\n    Rf = 8\n    Beta = 0.6\n    Market_return = 15\n    expected_return = Rf + Beta * (Market_return - Rf)\n    return expected_return",
        "ground_truth": 12.2,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Certainly! The Capital Asset Pricing Model (CAPM) determines the expected return on a stock by using the formula:\n\\[ E(R_i) = R_f + \\beta_i (E(R_m) - R_f) \\]\nwhere:\n- \\( E(R_i) \\) is the expected return on the investment,\n- \\( R_f \\) is the risk-free rate,\n- \\( \\beta_i \\) is the beta of the investment,\n- \\( E(R_m) \\) is the expected return of the market.\n\nLet's implement the CAPM in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    beta = 0.6\n    risk_free_rate = 0.08\n    market_return = 0.15\n    \n    # Do math calculation to get the expected return using the CAPM formula\n    expected_return = risk_free_rate + beta * (market_return - risk_free_rate)\n    \n    # return answer\n    return expected_return\n\n# Execute the function and print the answer\nprint(solution())\n```\n\nThis program will return the expected return on the stock as calculated by the CAPM formula."
        ]
    },
    {
        "question_id": "validation-189",
        "question": "Assuming the neutral real policy rate is set at 2.25%, the desired inflation rate is 2%, and projected growth is approximately 2.5%. If growth is predicted to be 3.5% and inflation is anticipated to reach 3%, what would be the nominal policy rate based on the Taylor rule?",
        "tables": [],
        "python_solution": "def solution():\n    neutral_real_policy_rate = 2.25\n    desired_inflation_rate = 2\n    projected_growth = 2.5\n    predicted_growth = 3.5\n    anticipated_inflation = 3\n\n    nominal_policy_rate = neutral_real_policy_rate + anticipated_inflation + 0.5 * (predicted_growth - projected_growth) + 0.5 * (anticipated_inflation - desired_inflation_rate)\n\n    return nominal_policy_rate",
        "ground_truth": 6.25,
        "topic": "Market Analysis & Economics",
        "output": [
            "Certainly! Here's the Python program that calculates the nominal policy rate based on the Taylor rule using the provided parameters:\n\n```python\ndef solution():\n    # Define variables name and value\n    neutral_real_policy_rate = 2.25\n    desired_inflation_rate = 2\n    projected_growth_rate = 3.5\n    actual_inflation_rate = 3\n\n    # Taylor rule formula: Policy Rate = Neutral Real Policy Rate + Actual Inflation + \n    # 0.5 * (Actual Inflation - Desired Inflation) + 0.5 * (Projected Growth - Potential Growth)\n    potential_growth_rate = 2.5  # Assumed to be the potential growth\n    policy_rate = (neutral_real_policy_rate + \n                   actual_inflation_rate + \n                   0.5 * (actual_inflation_rate - desired_inflation_rate) + \n                   0.5 * (projected_growth_rate - potential_growth_rate))\n\n    # return answer\n    return policy_rate\n\n# The answer would be the result of executing the function\nanswer = solution()\nprint(f\"The nominal policy rate based on the Taylor rule is: {answer}%\")\n```\n\nWhen you run this program, it will print out the nominal policy rate calculated according to the Taylor rule with the given parameters."
        ]
    },
    {
        "question_id": "validation-190",
        "question": "What is the forecaster's projected forward-looking ERP for a market using the Grinold-Kroner model based on the same details?",
        "tables": [
            "| Expected inflation | 1.9% |\n|---|---|\n| Expected growth in the P/E | -1.2% |\n| Expected income component | 1.8% |\n| Expected growth in real earnings per share | 2.7% |\n| Expected change in shares outstanding | 0.0% |\n| Current three-month government bond yield | 0.96% |\n| Long-term geometric average return of market equity index | 9.96% |\n| Long-term geometric average return of short-term government bond | 3.15% |"
        ],
        "python_solution": "def solution():\n    ERP = (1.8 - 1.2 + (1.9 + 2.7 + 0.0)) - 0.96\n    ERP_percentage = ERP * 100\n    return ERP_percentage",
        "ground_truth": 424.0,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    expected_inflation = 1.9 / 100\n    expected_growth_in_PE = -1.2 / 100\n    expected_income_component = 1.8 / 100\n    expected_growth_in_real_EPS = 2.7 / 100\n    expected_change_in_shares_outstanding = 0.0 / 100\n    current_three_month_gov_bond_yield = 0.96 / 100\n    \n    # Calculate the forward-looking equity risk premium using Grinold-Kroner model\n    equity_risk_premium = (\n        expected_inflation +\n        expected_income_component +\n        expected_growth_in_real_EPS - \n        expected_growth_in_PE - \n        expected_change_in_shares_outstanding\n    )\n    \n    # return answer\n    return equity_risk_premium\n\n# Run the solution function and print the result\nprint(solution())\n```\n\nThis program will calculate the forward-looking equity risk premium (ERP) using the Grinold-Kroner model based on the given details."
        ]
    },
    {
        "question_id": "validation-191",
        "question": "Once happy with the ultimate set of attributes, Williams chooses and operates a model on the training set that categorizes the text as either having positive sentiment (Class “1” or negative sentiment (Class “0”). He then appraises its performance by implementing error analysis. Based on Exhibit 2, what is the accuracy metric of the model in the ensuing confusion matrix?",
        "tables": [
            "|        |             | Actual Training   |           |\n|--------|-------------|:-----------------:|----------:|\n|        |             | Results           |           |\n|        |             | Class \"1\"         | Class \"0\" |\n| Predicted Results | Class \"1\" | TP=182           | FP=52     |\n|                    | Class \"0\" | FN=31            | TN=96     |"
        ],
        "python_solution": "def solution():\n    TP = 182\n    TN = 96\n    FP = 52\n    FN = 31\n\n    Accuracy = (TP + TN) / (TP + FP + TN + FN)\n    return Accuracy * 100",
        "ground_truth": 77.008,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name based on the confusion matrix values.\n    TP = 182  # True Positives\n    TN = 96   # True Negatives\n    FP = 52   # False Positives\n    FN = 31   # False Negatives\n    \n    # Calculate the accuracy of the model\n    total_predictions = TP + TN + FP + FN\n    correct_predictions = TP + TN\n    accuracy = correct_predictions / total_predictions\n    \n    # Return the calculated accuracy\n    return accuracy\n```"
        ]
    },
    {
        "question_id": "validation-192",
        "question": "In a sports competition involving 15 participants, prizes of $100, $50, and $10 will be given to the top performers. In how many different ways can this be done?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    return math.factorial(15)/(math.factorial(15-3))",
        "ground_truth": 2730.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here's a Python program to calculate the number of different ways the prizes can be given to the top performers in the sports competition:\n\n```python\ndef solution():\n    # Define variables name and value\n    participants = 15\n    first_prize_ways = participants\n    second_prize_ways = participants - 1\n    third_prize_ways = participants - 2\n    \n    # Do math calculation to get the answer\n    total_ways = first_prize_ways * second_prize_ways * third_prize_ways\n    \n    # return answer\n    return total_ways\n\n# Example usage:\n# print(solution())\n```\n\nThis program calculates the number of ways the first, second, and third prizes can be awarded and then multiplies them together to find the total number of ways to distribute the prizes among the participants."
        ]
    },
    {
        "question_id": "validation-193",
        "question": "Assuming that a broker holds an option stance in crude oil exhibiting a delta of 100000 barrels and a gamma of -50000 barrels per dollar price shift, compute the VaR for this stance utilizing the delta-gamma approach, under the presumption that the maximum crude oil price shift is $2.00 per barrel.",
        "tables": [],
        "python_solution": "def solution():\n    Delta = 100000\n    Gamma = -50000\n    VAR_ds = 2\n\n    VAR_df = Delta * -VAR_ds + (1 / 2) * Gamma * VAR_ds ** 2\n    return VAR_df",
        "ground_truth": -300000.0,
        "topic": "Risk Management",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    delta = 100000       # Delta exposure in barrels\n    gamma = -50000       # Gamma exposure in barrels per dollar\n    price_shift = 2.00   # Maximum price shift in dollars per barrel\n    \n    # Do math calculation to get the answer\n    # The delta-gamma approach for calculating VaR is given by:\n    # VaR = - (Delta * price_shift + 0.5 * Gamma * price_shift^2)\n    # Since Gamma is negative in this case, we add instead of subtract \n    # to the Delta*price_shift term, because negative times negative is positive.\n    \n    VaR = - (delta * price_shift + 0.5 * gamma * math.pow(price_shift, 2))\n    \n    # return answer\n    return VaR\n\n# Call the function and print the result\nprint(solution())\n```\nIn the solution provided above, the Delta-Gamma approach to calculate Value at Risk (VaR) has been used. Since the Gamma is given as a negative value, it's important to add the Gamma effect to calculate the VaR correctly. The formula incorporates a quadratic term (0.5 * Gamma * price_shift^2) due to the presence of gamma, which accounts for the curvature of the portfolio's value with respect to changes in the underlying price."
        ]
    },
    {
        "question_id": "validation-194",
        "question": "If a stock's present cost is $25 each, you plan to invest your $10,000 and also loan an additional $10,000 from your financial adviser to put $20,000 in the shares. If the preservation margin is 30 percent, what would be the initial price that will trigger a margin call?",
        "tables": [],
        "python_solution": "def solution():\n    initial_stock_price = 25\n    initial_equity = initial_stock_price * 0.5\n    preservation_margin = 0.30\n    P = initial_equity / (1 - preservation_margin)\n    return P",
        "ground_truth": 17.857,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    own_money = 10000\n    borrowed_money = 10000\n    total_invested = own_money + borrowed_money\n    stock_price_initial = 25\n    maintenance_margin = 0.30\n\n    # Calculate the number of shares bought \n    number_of_shares = total_invested / stock_price_initial\n\n    # Do math calculation to get the initial price that triggers a margin call\n    # Equity (E) = Market value of shares (P * Q) - Borrowed money (D)\n    # Maintenance margin (MM) = Equity (E) / Market value of shares (P * Q)\n    # Rearranging the formula to find the price (P) that triggers margin call:\n    # P = Borrowed money / (Number of shares * (1 - Maintenance margin))\n    margin_call_price = borrowed_money / (number_of_shares * (1 - maintenance_margin))\n\n    # return answer\n    return margin_call_price\n\n# Call the solution function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-195",
        "question": "What is the overall fee that Circle has garnered in the current year, considering $288 million in assets under management (AUM) from the end of the previous year, a 2% management fee (based on year-end AUM), a 20% incentive fee calculated after subtracting the management fee using a 5% soft hurdle rate and a high-water mark of $357 million, and the fund yield for the current year being 25%?",
        "tables": [],
        "python_solution": "def solution():\n    prior_year_end_AUM = 288\n    fund_return = 0.25\n    management_fee_percentage = 2/100\n    \n    end_of_year_AUM = prior_year_end_AUM * (1 + fund_return)\n    management_fee = end_of_year_AUM * management_fee_percentage\n    \n    return management_fee",
        "ground_truth": 7.2,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    previous_year_end_aum = 288_000_000  # Assets under management at the end of the previous year\n    management_fee_rate = 0.02  # 2% management fee\n    incentive_fee_rate = 0.20  # 20% incentive fee\n    hurdle_rate = 0.05  # 5% soft hurdle rate\n    high_water_mark = 357_000_000  # High-water mark\n    current_year_yield = 0.25  # Fund yield for the current year\n\n    # Do math calculation to get the answer\n\n    # Management fee (based on the previous year-end AUM)\n    management_fee = previous_year_end_aum * management_fee_rate\n\n    # Calculate the performance of the fund in the current year\n    fund_performance = previous_year_end_aum * current_year_yield\n\n    # Calculate incentive fee only if the performance is above the high-water mark and hurdle rate\n    incentive_fee = 0\n    if previous_year_end_aum < high_water_mark:  # Only consider performance above the high-water mark\n        performance_above_hwm = max(0, (previous_year_end_aum + fund_performance) - high_water_mark)\n    else:\n        performance_above_hwm = fund_performance\n\n    # Calculate returns above the hurdle rate if any\n    returns_above_hurdle = max(0, previous_year_end_aum * (current_year_yield - hurdle_rate))\n\n    # The incentive fee applies to the lesser of performance above the high-water mark and hurdle rate return\n    incentive_eligible_returns = min(performance_above_hwm, returns_above_hurdle)\n\n    # Calculate the incentive fee\n    incentive_fee = incentive_eligible_returns * incentive_fee_rate\n\n    # Total fee is the sum of management fee and incentive fee\n    total_fee = management_fee + incentive_fee\n\n    # Return answer\n    return total_fee\n\n# Call the function and print the result\nprint(f\"The overall fee is: ${solution():,.2f}\")\n```"
        ]
    },
    {
        "question_id": "validation-196",
        "question": "Imagine a portfolio that contains two components. The first component, Component X, makes up 25% of the portfolio and possesses a standard deviation of 17.9%. The second component, Component Y, makes up the rest of the portfolio at 75% and has a standard deviation of 6.2%. If the correlation between these two components is 0.5, what would the portfolio's standard deviation be?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    weight_X = 0.25\n    weight_Y = 0.75\n    standard_deviation_X = 0.179\n    standard_deviation_Y = 0.062\n    correlation_XY = 0.5\n\n    portfolio_variance = (weight_X**2 * standard_deviation_X**2) + (weight_Y**2 * standard_deviation_Y**2) + (2 * weight_X * weight_Y * correlation_XY * standard_deviation_X * standard_deviation_Y)\n    portfolio_standard_deviation = math.sqrt(portfolio_variance)\n\n    return portfolio_standard_deviation*100",
        "ground_truth": 7.903,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Here's a Python program that calculates the portfolio's standard deviation based on the given information:\n\n```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight_X = 0.25\n    weight_Y = 0.75\n    std_dev_X = 0.179\n    std_dev_Y = 0.062\n    correlation_XY = 0.5\n    \n    # Calculate the portfolio's variance using the formula for the variance of a two-asset portfolio\n    portfolio_variance = (weight_X * std_dev_X) ** 2 + (weight_Y * std_dev_Y) ** 2 + 2 * weight_X * weight_Y * correlation_XY * std_dev_X * std_dev_Y\n    \n    # Calculate the standard deviation, which is the square root of the variance\n    portfolio_std_dev = math.sqrt(portfolio_variance)\n    \n    # return answer\n    return portfolio_std_dev\n\n# calling the function and printing the value\nprint(solution())\n```\n\nThis function calculates the portfolio's standard deviation by first computing the variance based on the weights of the components, their standard deviations, and the correlation between them. Then it takes the square root of the variance to get the standard deviation."
        ]
    },
    {
        "question_id": "validation-197",
        "question": "If an investment company starts the year with a value of $160 million and follows a \"2 and 20\" fee scheme, the management fee depends on the end-of-year asset value. With a soft hurdle rate of 10% net of management fee for calculating the incentive fee, and a prior high-water mark of $198 million, how much is the total fees collected if the assets increase by 25% in the coming year?",
        "tables": [],
        "python_solution": "def solution():\n    initial_aum = 160\n    growth_rate = 0.25\n    management_fee_rate = 0.02\n    soft_hurdle_rate = 0.10\n    high_water_mark = 198\n    \n    end_year_aum = initial_aum * (1 + growth_rate)\n    \n    management_fee = end_year_aum * management_fee_rate\n    \n    net_year_end = end_year_aum - management_fee\n    \n    if net_year_end < high_water_mark:\n        total_fees = management_fee\n\n    return total_fees",
        "ground_truth": 4.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    starting_asset_value = 160e6  # The starting value of the assets\n    performance_increase = 0.25   # 25% increase of the assets\n    management_fee_rate = 0.02    # 2% management fee (2 and 20 fee structure)\n    incentive_fee_rate = 0.20     # 20% incentive fee (2 and 20 fee structure)\n    soft_hurdle_rate = 0.10       # Hurdle rate of 10%\n    high_water_mark = 198e6       # Prior high-water mark\n    \n    # Calculate the end-of-year asset value\n    end_of_year_asset_value = starting_asset_value * (1 + performance_increase)\n    \n    # Calculate the management fee (2% of the end-of-year asset value)\n    management_fee = end_of_year_asset_value * management_fee_rate\n    \n    # Calculate the net performance after the management fee\n    net_performance = end_of_year_asset_value - starting_asset_value - management_fee\n    \n    # Check if the incentive fee is applicable by comparing with the soft hurdle\n    # and the high-water mark.\n    if net_performance > (starting_asset_value * soft_hurdle_rate) and end_of_year_asset_value > high_water_mark:\n        # The incentive fee is only payable on the amount above the high-water mark\n        incentive_base = end_of_year_asset_value - high_water_mark\n        # Calculate the incentive fee (20% of the incentive base)\n        incentive_fee = incentive_base * incentive_fee_rate\n    else:\n        incentive_fee = 0\n\n    # Total fees collected is the sum of management fee and incentive fee\n    total_fees_collected = management_fee + incentive_fee\n    \n    # return answer\n    return total_fees_collected\n\n# Call the solution function and print the result\ntotal_fees = solution()\nprint(total_fees)\n```"
        ]
    },
    {
        "question_id": "validation-198",
        "question": "What is the growth rate of Real Estate #1, according to Exhibit 2?",
        "tables": [
            "|     | Year 1 | Year 2 | Year 3 | Year 4 | Year 5 | Year 6 |\n| --- | ---    | ---    | ---    | ---    | ---    | ---    |\n| NOI  | $2,775,840 | $2,859,119 | $2,944,889 | $3,033,235 | $3,124,232 | $3,217,959 |\n| DCF Assumptions |    |   |   |   |    |    |\n| Investment Hold Period |    |   | 5 years |   |    |    |\n| Going-in Cap Rate |     |   |  5.25% |   |    |    |\n| Terminal Cap Rate |    |   |  6.00% |   |    |    |\n| Discount Rate |     |   |  7.25% |   |    |    |\n| Income/Value Growth |    |   |  Constant |   |    |    |\n| Rate |     |   |   |   |    |    |"
        ],
        "python_solution": "def solution():\n    discount_rate = 7.25\n    going_in_cap_rate = 5.25\n    growth_rate = discount_rate - going_in_cap_rate\n    return growth_rate",
        "ground_truth": 2.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is a Python program that calculates the growth rate of Real Estate #1 using NOI (Net Operating Income) values from the provided table:\n\n```python\nimport numpy as np\n\ndef solution():\n    # Define variables name and value\n    # NOI values from Year 1 to Year 6\n    noi_values = np.array([2775840, 2859119, 2944889, 3033235, 3124232, 3217959])\n    \n    # Calculate growth rates year on year\n    growth_rates = (noi_values[1:] - noi_values[:-1]) / noi_values[:-1]\n\n    # Calculate the average growth rate across the years\n    average_growth_rate = np.mean(growth_rates)\n    \n    # Return average growth rate as a percentage\n    return average_growth_rate * 100\n\n# Run the function and print the result\ngrowth_rate = solution()\nprint(f'The growth rate of Real Estate #1 is {growth_rate:.2f}%')\n\n```\n\nThis program assumes that growth happened evenly across the years presented and calculates the compound annual growth rate (CAGR) by finding the year-over-year growth rates and taking their average. The resulting average growth rate is returned as a percentage.\n\nPlease note that this is a simple approach and does not take into account more complicated aspects of real estate valuation or growth rate calculation that might require more advanced financial model analysis."
        ]
    },
    {
        "question_id": "validation-199",
        "question": "Compute the standard deviation of the investment portfolio using the following figures: the percentage weight of asset X is 30%, the weight of asset Y is 70%, the standard deviation for asset X is 25%, that for asset Y is 10%, and their correlation coefficient is 0.8.",
        "tables": [],
        "python_solution": "def solution():\n    weight_X = 0.30\n    standard_deviation_X = 0.25\n    weight_Y = 0.70\n    standard_deviation_Y = 0.10\n    correlation_coefficient = 0.8\n\n    variance = weight_X**2 * standard_deviation_X**2 + weight_Y**2 * standard_deviation_Y**2 + 2 * weight_X * weight_Y * standard_deviation_X * standard_deviation_Y * correlation_coefficient\n\n    return variance**0.5",
        "ground_truth": 0.138,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\n# Import necessary package for square root function\nfrom math import sqrt\n\ndef solution():\n    # Define variables name and value\n    weight_X = 0.30\n    weight_Y = 0.70\n    stddev_X = 0.25\n    stddev_Y = 0.10\n    correlation_XY = 0.8\n    \n    # Compute the portfolio standard deviation using the formula\n    # for two assets:\n    # σ_portfolio = sqrt((weight_X * σ_X)^2 + (weight_Y * σ_Y)^2 + 2 * weight_X * weight_Y * correlation_XY * σ_X * σ_Y)\n    port_stddev = sqrt((weight_X * stddev_X)**2 + (weight_Y * stddev_Y)**2 +\n                       2 * weight_X * weight_Y * correlation_XY * stddev_X * stddev_Y)\n    \n    # return answer\n    return port_stddev\n    \n# This will print the answer calculated by the function\nprint(solution())\n```"
        ]
    }
]