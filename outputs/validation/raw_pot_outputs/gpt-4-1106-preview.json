[
    {
        "question_id": "validation-0",
        "question": "A business chose to swap a truck that it had bought three years ago for a parcel of land owned by a different enterprise. The subsequent table outlines information pertinent to both assets: The profit and loss statement for the enterprise that relinquishes the truck is most likely going to reflect a loss of:",
        "tables": [
            "|               |      Truck*     |     Land**    |\n|---------------|:---------------:|:-------------:|\n| Original cost |     $ 57,000    |    $ 18,000   |\n| Estimated life|     8 years     |               |\n|  Estimated salvage value at purchase |     $ 15,000    |               |\n| Depreciation method | Declining balance, 20% per year |               |\n| Current fair value of item |     $ 27,000    |    $ 21,000   |  \n\n\\* The last sale of a similar truck by the company occurred more than six months ago.  \n\\** The land is one of four identical parcels of land recently sold by the company."
        ],
        "python_solution": "def solution():\n    truck_value = 57000\n    depreciation_rate = 0.20\n    years = 3\n    land_value = 21000\n    \n    truck_carrying_value = truck_value * ((1 - depreciation_rate)**years)\n    loss = land_value - truck_carrying_value\n    \n    return loss",
        "ground_truth": -8184.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    original_cost_truck = 57000\n    estimated_salvage_value_truck = 15000\n    estimated_life_truck = 8\n    depreciation_rate = 0.20\n    current_fair_value_truck = 27000\n    current_fair_value_land = 21000\n\n    # Calculate depreciation for 3 years using declining balance method\n    # Year 1\n    depreciation_year1 = original_cost_truck * depreciation_rate\n    book_value_end_year1 = original_cost_truck - depreciation_year1\n\n    # Year 2\n    depreciation_year2 = book_value_end_year1 * depreciation_rate\n    book_value_end_year2 = book_value_end_year1 - depreciation_year2\n\n    # Year 3\n    depreciation_year3 = book_value_end_year2 * depreciation_rate\n    book_value_end_year3 = book_value_end_year2 - depreciation_year3\n\n    # Since the truck is exchanged for land, compare the book value to the fair value of the land to determine loss or gain\n    loss_or_gain = current_fair_value_land - book_value_end_year3\n    \n    # return answer\n    return loss_or_gain\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThis program will calculate the loss or gain from the exchange of the truck for the land by first calculating the depreciation of the truck over the 3 years using the declining balance method. It then compares the book value of the truck after 3 years to the fair value of the land to determine the loss or gain. The answer it returns is the dollar amount of that loss or gain."
        ]
    },
    {
        "question_id": "validation-1",
        "question": "Given that the spot exchange rate from the \"Kiwi\" (NZD) to sterling (GBP) is 2.0979, the Libor interest rate for the sterling is 1.6025%, and for the \"Kiwi\" it's 3.2875%, all being quoted on a 360-day year basis, what are the 180-day forward points (with a precision of four decimal places) in NZD/GBP?",
        "tables": [],
        "python_solution": "def solution():\n    spot_rate = 2.0979\n    gbp_interest_rate = 1.6025/100\n    nzd_interest_rate = 3.2875/100\n    time_in_years = 180/360\n\n    gbp_investment = 1 * (1 + gbp_interest_rate * time_in_years)\n    nzd_investment = spot_rate * (1 + nzd_interest_rate * time_in_years)\n    \n    forward_rate = nzd_investment / gbp_investment\n    \n    forward_points = (forward_rate - spot_rate) * 10000\n\n    return int(forward_points)",
        "ground_truth": 175.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    spot_rate = 2.0979\n    interest_rate_gbp = 1.6025 / 100  # Convert to decimal\n    interest_rate_nzd = 3.2875 / 100  # Convert to decimal\n    days = 180\n    year_base = 360\n\n    # According to Interest Rate Parity (IRP), the forward rate is determined by the interest rate differential\n    # between two currencies. The formula for calculating forward points is:\n    # Forward Points = Spot Rate * ((1 + Interest Rate(quote_currency) * (days/year_base)) / (1 + Interest Rate(base_currency) * (days/year_base)) - 1)\n\n    forward_points = spot_rate * (((1 + interest_rate_nzd * (days / year_base)) / (1 + interest_rate_gbp * (days / year_base))) - 1)\n    \n    # Return the answer rounded to four decimal places\n    return round(forward_points, 4)\n\n# Output the forward points\nprint(solution())\n```\n\nThis program defines the given spot exchange rate, the Libor interest rates for both currencies, using a 360-day year convention, and the duration of the forward contract (180 days). It then calculates the forward points using the Interest Rate Parity (IRP) formula: \n\n\\[ \\text{Forward Points} = \\text{Spot Rate} \\times \\left( \\frac{1 + \\text{Interest Rate of the quoted currency} \\times \\frac{\\text{Days}}{\\text{Year basis}}}{1 + \\text{Interest Rate of the base currency} \\times \\frac{\\text{Days}}{\\text{Year basis}}} - 1 \\right) \\]\n\nFinally, it returns the answer rounded to four decimal places."
        ]
    },
    {
        "question_id": "validation-2",
        "question": "The CME Foundation, which is based in the United States, has requested their Chief Investment Officer, Pauline Cortez, to conduct an analysis on the advantages of incorporating U.S real estate equities as a fixed asset class. As part of this process, Cortez must establish the relevant risk factor to use in the international capital asset pricing model (ICAPM) in order to appropriately determine the risk premium and expected return for this potential asset class. She will be using selected data provided by GloboStats as shown in Exhibit 1. Given the information in Exhibit 1 and under the assumption of perfect markets, what would be the calculated beta for U.S. real estate equities?",
        "tables": [
            "| Asset Class | Standard Deviation | Covariance with GIM | Integration with GIM | Sharpe Ratio |\n| ------------ | ------------------ | --------------------- | ------------------ | ------------- |\n| U.S. real estate | 14.0% | 0.0075 | 0.60 | n/a |\n| Global investable market | - | - | - | 0.36 |\n\nAdditional Information:  \n- Risk-free rate: 3.1%\n- Expected return for the GIM:  7.2%"
        ],
        "python_solution": "def solution():\n    cov = 0.0075\n    RPM = (7.2/100) - (3.1/100)\n    sigmaM = RPM / 0.36\n    varM = sigmaM ** 2\n    beta = cov / varM\n    return beta",
        "ground_truth": 0.578,
        "topic": "Market Analysis & Economics",
        "output": [
            "Certainly! To calculate the beta for U.S. real estate equities, we can use the provided covariance of U.S. real estate equities with the Global Investable Market (GIM) and the variance of GIM. However, the variance of GIM isn't given directly; it can be derived from the standard deviation if we had the standard deviation of the GIM. Since the standard deviation for the GIM isn't provided, we can't compute its variance and thus cannot calculate the beta using the given data.\n\nNevertheless, to establish the framework, assuming we had the standard deviation of the GIM (sigma_gim), the beta (β) can be calculated using the following formula:\n\nβ = Covariance(U.S. real estate, GIM) / Variance(GIM)\nBeta measures the sensitivity of the particular asset's returns to the returns of the market. In this calculation, the market is represented by the Global Investable Market (GIM).\n\nWe need to be able to square the standard deviation to get the variance for the GIM, or it should be provided. Without this value, we cannot perform the calculation. However, if we were to write a program structure that outlines how you would calculate beta if you had the variance, it would look something like this:\n\n```python\ndef solution():\n    # Define variables name and value\n    covariance_US_real_estate_with_GIM = 0.0075\n    # The variance of GIM would be the standard deviation squared.\n    # Since the standard deviation of GIM isn't provided, we can't calculate its variance.\n    # var_GIM = sigma_gim ** 2  # This value is unknown\n    \n    # As we don't have the standard deviation (or variance) for the GIM,\n    # the calculation for beta is incomplete.\n    # If we had the variance, we would compute it as follows:\n    # beta_US_real_estate = covariance_US_real_estate_with_GIM / var_GIM\n    \n    # Right now, since we don't have the variance of GIM, we can't return an answer\n    # So we will return None or raise an exception\n    \n    raise ValueError(\"Variance of GIM is required to calculate beta.\")\n    \n    # Once the variance of GIM is known, you can uncomment the above beta calculation line\n    # and return beta_US_real_estate instead of raising an exception.\n```\n\nSince the necessary data to compute the beta is missing, the program can't currently provide a concrete answer, so I've included a placeholder to raise an exception. If the variance for GIM were available, you would replace the `raise ValueError(...)` line with the commented calculation line and return the computed beta value."
        ]
    },
    {
        "question_id": "validation-3",
        "question": "Martinez took over a Spanish packaging firm. The Spanish venture involved Martinez purchasing 200,000 shares of a packaging firm at EUR90 per share. He resolved to fully secure the position with a six-month USD/EUR forward agreement. Given Exhibit 1, if the Spanish shares were sold after three months, what would have been the cash expenditure (in US dollars) necessary to terminate the forward agreement? (2019 mock PM)",
        "tables": [
            "| Maturity          | At Initiation    | Three Months  Later | At Maturity   |\n|-----------------  |----------------- |---------------------|---------------|\n| Spot (USD/EUR)    | 1.3935/1.3983    | 1.4106/1.4210       | 1.4189/1.4289 |\n| 3-month forward   | -8.1/-7.6        | -21.6/-21.0         |               |\n| 6-month forward   | -19.0/-18.3      |                     | -27.0/-26.2   |\n| USD Libor         | 1.266%           | 1.266%              | 1.266%        |\n| EUR Libor         | 1.814%           | 1.814%              | 1.814%        |"
        ],
        "python_solution": "def solution():\n    initial_position_eur = 200000 * 90\n    six_month_forward_rate = 1.3935 - 19 / 10000\n    three_month_forward_rate = 1.4210 - 21 / 10000\n    cash_outflow_at_settlement = initial_position_eur * (three_month_forward_rate - six_month_forward_rate)\n    dollar_libor_rate = 0.01266\n    cash_expenditure = cash_outflow_at_settlement / (1 + dollar_libor_rate * 90 / 360)\n    return int(cash_expenditure)",
        "ground_truth": 489849.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Given data\n    shares_purchased = 200000\n    share_price_eur = 90\n    spot_initiation = 1.3935\n    three_month_forward_initiation = -0.0081\n    spot_three_months_later = 1.4106\n    three_month_forward_three_months_later = -0.0216\n    \n    # Calculate the total investment in EUR\n    total_investment_eur = shares_purchased * share_price_eur\n    \n    # Calculate the forward rate at initiation\n    forward_rate_initiation = spot_initiation + three_month_forward_initiation\n    \n    # Calculate the cash outflow to enter the forward contract at initiation (in USD)\n    cash_outflow_initiation_usd = total_investment_eur * forward_rate_initiation\n    \n    # Calculate the forward rate three months later\n    forward_rate_three_months_later = spot_three_months_later + three_month_forward_three_months_later\n    \n    # Calculate the cash expenditure necessary to terminate the forward contract after three months (in USD)\n    cash_expenditure_termination_usd = total_investment_eur * forward_rate_three_months_later\n    \n    # The difference between what was initially paid and what has to be paid to terminate the contract\n    cash_expenditure_difference_usd = cash_expenditure_termination_usd - cash_outflow_initiation_usd\n    \n    return cash_expenditure_difference_usd\n\n# Call the function and print the result\nresult = solution()\nprint(f\"The cash expenditure (in US dollars) necessary to terminate the forward agreement is: {result}\")\n```\n\nThis program defines a function that calculates the cash outflow to enter a forward agreement and the cash expenditure necessary to terminate the forward agreement for a Spanish packaging firm. The inputs are the amount of shares, price per share, spot and forward rates at initiation and three months later. The program then calculates the total investment in EUR, forward rates at initiation and after three months, and returns the difference in cash expenditure in USD."
        ]
    },
    {
        "question_id": "validation-4",
        "question": "A financial risk assessor at a local financial institution is working out the yearly VaR of a collection of investment securities. The collection presently has a market worth of USD 3,700,000 with a daily fluctuation of 0.0004. Provided that there are 250 days of trading in a year and the daily returns on the collection are autonomous and adhere to the same usual distribution with a zero mean, what is the estimated 1-year VaR at the 95% assurance level?",
        "tables": [],
        "python_solution": "def solution():\n    worth = 3700000\n    volatility = 0.0004\n    days = 250\n    Z = 1.645\n    daily_std_dev = (volatility)**0.5\n    annual_VaR = worth * (days**0.5) * daily_std_dev * Z\n    return annual_VaR",
        "ground_truth": 1924720.298,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport scipy.stats as stats\n\ndef solution():\n    # Define variables name and value\n    market_value = 3700000\n    daily_volatility = 0.0004\n    trading_days = 250\n    confidence_level = 0.95\n    \n    # Calculate the standard deviation of annual returns\n    annual_std = daily_volatility * (trading_days ** 0.5)\n    \n    # Find the z-score corresponding to the confidence level\n    z_score = stats.norm.ppf(1 - confidence_level)\n    \n    # Calculate the VaR\n    VaR = market_value * z_score * annual_std\n    \n    # Since VaR is typically a positive number, we take the absolute value\n    return abs(VaR)\n```\n\nThis function calculates the VaR (Value at Risk) at the 95% confidence level for a collection of investment securities, using the provided inputs and assuming that the daily returns follow a normal distribution with zero mean.\n\nPlease note that while the question states the distribution has a zero mean, the mean does not explicitly play a role in the VaR calculation in this context as the z-score is derived from the confidence level. If the mean was not zero, it would need to be incorporated into the VaR calculation. However, in many financial models including the one used in this VaR calculation, the assumption of a zero mean is common when considering short-term returns."
        ]
    },
    {
        "question_id": "validation-5",
        "question": "For the organizations evaluated, it is projected that 40% will face bankruptcy within one year: P(failure) = 0.40. Meanwhile, 55% of these organizations are expected to succeed: P(success) = 0.55. There's an 85% likelihood that an organization will succeed if it stays afloat for a year: P(success | survival) = 0.85. Using the total probability rule, we can calculate the probability of an organization succeeding even if it eventually goes bankrupt. Thus, P(success | failure) is approximately: An examiner establishes a set of standards for analyzing troubled credits. Organizations that fail to achieve a passing score are categorized as probable to face bankruptcy within the upcoming year. The examiner arrives at the following conclusions:",
        "tables": [],
        "python_solution": "def solution():\n    non_survivor = 0.40\n    survivor = 1 - non_survivor\n    pass_test_for_survivor = 0.85\n    total_pass_test = 0.55\n\n    pass_test_for_non_survivor = (total_pass_test - pass_test_for_survivor * survivor) / non_survivor\n    return pass_test_for_non_survivor",
        "ground_truth": 0.1,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here's the Python program to calculate P(success | failure):\n\n```python\ndef solution():\n    # Given probabilities\n    p_failure = 0.40     # P(failure)\n    p_success = 0.55     # P(success)\n    p_success_given_survival = 0.85 # P(success | survival)\n    \n    # Using the total probability rule:\n    # P(success) = P(success | survival) * P(survival) + P(success | failure) * P(failure)\n    # We know P(success), P(success | survival) and P(failure), thus we can rearrange to find P(success | failure):\n    # P(success | failure) = (P(success) - P(success | survival) * (1 - P(failure))) / P(failure)\n    \n    # Calculate P(survival) as 1 - P(failure)\n    p_survival = 1 - p_failure\n    \n    # Calculate P(success | failure)\n    p_success_given_failure = (p_success - p_success_given_survival * p_survival) / p_failure\n    \n    # return answer\n    return p_success_given_failure\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe program defines the necessary probabilities given in the problem and uses the total probability rule to calculate the probability of success given failure. It returns this calculated value as the answer."
        ]
    },
    {
        "question_id": "validation-6",
        "question": "What is the three-firm Herfindahl-Hirschmann Index for the sector, given that a researcher collected the following market share data for a sector made up of five firms?",
        "tables": [
            "| Company | Market Share(%) |\n|---------|-----------------|\n| Zeta    | 35              |\n| Yusef   | 25              |\n| Xenon   | 20              |\n| Waters  | 10              |\n| Vlastos | 10              |"
        ],
        "python_solution": "def solution():\n    # three firms' market shares\n    firm1_share = 0.35\n    firm2_share = 0.25\n    firm3_share = 0.2\n    \n    # Herfindahl-Hirschmann Index\n    hhi = firm1_share**2 + firm2_share**2 + firm3_share**2\n    \n    return hhi",
        "ground_truth": 0.225,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # We are using only the first three firms' market shares for the three-firm HHI\n    zeta_market_share = 35\n    yusef_market_share = 25\n    xenon_market_share = 20\n    \n    # Do math calculation to get the answer\n    # HHI is the sum of the squares of the market shares\n    hhi = zeta_market_share ** 2 + yusef_market_share ** 2 + xenon_market_share ** 2\n    \n    # return answer\n    return hhi\n    \n# You can call the function and print its result to verify\n# print(solution())\n```\nThis program will calculate the Herfindahl-Hirschmann Index (HHI) for the sector using the market shares of the top three firms (Zeta, Yusef, and Xenon). We square each firm's market share and then sum them to get the HHI."
        ]
    },
    {
        "question_id": "validation-7",
        "question": "A two-year fixed-for-floating Libor swap stands at 1.00% and the two-year US Treasury bond yield is currently 0.63%. What is the difference in rates, also known as the swap spread?",
        "tables": [],
        "python_solution": "def solution():\n    libor_swap = 1.00\n    us_treasury_bond_yield = 0.63\n    swap_spread = libor_swap - us_treasury_bond_yield\n    return swap_spread * 100  # Result in basis points",
        "ground_truth": 37.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    libor_swap_rate = 1.00\n    treasury_bond_yield = 0.63\n    \n    # Do math calculation to get the answer\n    swap_spread = libor_swap_rate - treasury_bond_yield\n    \n    # return answer\n    return swap_spread\n\n# Note: The answer will be returned as a percentage, for more precise financial calculations\n# it might be better to use decimal (e.g. 0.01 instead of 1.00% for libor swap rate)\n```"
        ]
    },
    {
        "question_id": "validation-8",
        "question": "Using the straight-line method, what is the accumulated amortization cost at the end of 2016 for the relevant information about an intangible asset?",
        "tables": [
            "| Acquisition cost $ 600,000 | |\n|---|---|\n| Acquisition date 1 January 2013 | |\n| Expected residual value at time of acquisition $ 100,000 | |\n| The intangible asset is supposed to bring in profits for 5 years after acquisition. | |"
        ],
        "python_solution": "def solution():\n    original_cost = 600000\n    residual_value = 100000\n    useful_life = 5\n    years_passed = 4\n    accumulated_amortization = ((original_cost - residual_value) / useful_life) * years_passed\n    return accumulated_amortization",
        "ground_truth": 400000.0,
        "topic": "Accounting",
        "output": [
            "Here's the Python program to calculate the accumulated amortization cost at the end of 2016 using the straight-line method:\n\n```python\ndef solution():\n    # Define variables name and value\n    acquisition_cost = 600000\n    residual_value = 100000\n    useful_life = 5  # in years\n\n    # Calculate annual amortization expense\n    annual_amortization_expense = (acquisition_cost - residual_value) / useful_life\n    \n    # Calculate the number of years from acquisition until the end of 2016\n    years_passed = 2016 - 2013 + 1  # including the year of acquisition\n    \n    # If the number of years passed is greater than the useful life, the amortization stops at end of useful life\n    if years_passed > useful_life:\n        years_passed = useful_life\n    \n    # Calculate accumulated amortization\n    accumulated_amortization = annual_amortization_expense * years_passed\n    \n    # return answer\n    return accumulated_amortization\n    \n# This would return the accumulated amortization at the end of 2016\nsolution()\n```\n\nWhen you call `solution()`, it will return the accumulated amortization cost at the end of 2016."
        ]
    },
    {
        "question_id": "validation-9",
        "question": "Based on the regression function from 1972 to 2012, the average mean reversion was 77.5%. The correlation data over a prolonged period averages at 35%. In the case of the 30 by 30 NASDAQ correlation matrices, the correlation averaged at 27% in January 2014. Utilizing the basic s(t) - s(t-1) = alpha × [μ - s(t -1)] model, what is the correlated expectation for February 2014?",
        "tables": [],
        "python_solution": "def solution():\n    return 27.0 + 77.5 * (35.0 - 27.0) / 100",
        "ground_truth": 33.2,
        "topic": "Risk Management",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    alpha = 0.775  # mean reversion (77.5%)\n    mu = 0.35  # long-term average correlation (35%)\n    s_previous = 0.27  # correlation for January 2014 (27%)\n    \n    # Do math calculation to get the answer using the formula\n    # s(t) - s(t-1) = alpha * (mean long term correlation - s(t-1))\n    # which gives us s(t) = s(t-1) + alpha * (mu - s(t-1))\n    s_t = s_previous + alpha * (mu - s_previous)\n    \n    # return answer\n    return s_t\n    \n# Calling the function and printing the result for better understanding\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-10",
        "question": "Superior Inc. anticipates paying dividends of $0.5 per share for the upcoming two years. Dividends are predicted to increase at a 6% growth rate after that. Given a 10% rate of return, what is the worth of Superior's common equity?",
        "tables": [],
        "python_solution": "def solution():\n    D01=D02=0.5 \n    P02=0.5*(1.06)/(0.1-0.06)\n    V= (0.5)/1.1+(0.5+P02)/(1.1**2)\n    return V",
        "ground_truth": 11.818,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define initial dividend and growth information\n    dividend_per_share = 0.5\n    growth_rate = 0.06\n    required_rate_of_return = 0.1\n\n    # Calculate the present value of the first two years of dividends\n    year_1_dividend = dividend_per_share / (1 + required_rate_of_return)\n    year_2_dividend = dividend_per_share / ((1 + required_rate_of_return) ** 2)\n\n    # Calculate the terminal value at the beginning of year 3 (which is the end of year 2)\n    year_3_ongoing_value = (dividend_per_share * (1 + growth_rate)) / (required_rate_of_return - growth_rate)\n    present_value_of_year_3_ongoing_value = year_3_ongoing_value / ((1 + required_rate_of_return) ** 2)\n\n    # The total present value of the common equity\n    value_of_common_equity = year_1_dividend + year_2_dividend + present_value_of_year_3_ongoing_value\n\n    return value_of_common_equity\n\n# Call the function and print the result\nprint(solution())\n```\n\nJust run the above code in a Python environment to get the worth of Superior's common equity. The code defines the required variables and performs the necessary calculations to determine the value of the common equity using the Dividend Discount Model (DDM), specifically a two-stage DDM since it accounts for an initial period of stable dividends followed by a period of perpetual growth."
        ]
    },
    {
        "question_id": "validation-11",
        "question": "As a dominant entity in the industry, Yahoo Corp. recently conducted a market analysis and discovered that the price elasticity of demand is 1.8. If the marginal cost is $30 and the average cost is $50, what is the most probable price?",
        "tables": [],
        "python_solution": "def solution():\n    E = 1.8\n    MC = 30\n    price = MC / (1 - (1 / E))\n    return price",
        "ground_truth": 67.5,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    price_elasticity_of_demand = 1.8\n    marginal_cost = 30\n    \n    # Using the formula P = MC / (1 + (1/E))\n    # where P is the price, MC is the marginal cost, and E is the price elasticity of demand\n    # We find the price by rearranging the optimal pricing rule formula P = MC / (1 + 1/E)\n    price = marginal_cost / (1 + 1/price_elasticity_of_demand)\n    \n    # Return the probable price\n    return price\n\n# Call the solution function and print the result\nprint(solution())\n```\nIn this program, we're using the optimal pricing rule under monopolistic competition, which states that the optimal price (P) is equal to the marginal cost (MC) divided by one plus the reciprocal of the price elasticity of demand (E). This results from the inverse elasticity pricing rule for monopoly or monopolistic competition, which takes into account the price elasticity of demand when determining the most profitable price to charge for a product."
        ]
    },
    {
        "question_id": "validation-12",
        "question": "What is the annual economic profit for Chace's House Industry based on the collected data?",
        "tables": [
            "| Total revenue | $460,000 |\n|---------------|----------|\n| Value of buildings and machinery |  |\n| - At the beginning of the year | $320,000 |\n| - At the end of the year | $270,000 |\n| Cost of raw materials | $80,000 |\n| Wages paid during the year | $30,000 |\n| Normal profit for the year | $50,000 |"
        ],
        "python_solution": "def solution():\n    opportunity_costs = 80000 + 30000 + 50000\n    economic_depreciation = 320000 - 270000\n    total_revenue = 460000\n    economic_profit = total_revenue - opportunity_costs - economic_depreciation\n    return economic_profit",
        "ground_truth": 250000.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "To calculate the annual economic profit for Chace's House Industry, we need to account for all costs including the opportunity costs of capital. The economic profit is defined as:\n\nEconomic Profit = Total Revenue - Explicit Costs - Implicit Costs (Opportunity Costs)\n\nThe opportunity costs in this case would include the normal profit and the depreciation of buildings and machinery. The depreciation is the decrease in value of the buildings and machinery over the year, which is calculated as the value at the beginning of the year minus the value at the end of the year.\n\nThe explicit costs include the cost of raw materials and the wages paid during the year. So we can calculate the economic profit with these given values.\n\n```python\ndef solution():\n    # Define variables name and value\n    total_revenue = 460000\n    beginning_value_of_buildings_and_machinery = 320000\n    end_value_of_buildings_and_machinery = 270000\n    cost_of_raw_materials = 80000\n    wages_paid = 30000\n    normal_profit = 50000\n    \n    # Calculate depreciation of buildings and machinery\n    depreciation = beginning_value_of_buildings_and_machinery - end_value_of_buildings_and_machinery\n    \n    # Calculate explicit costs\n    explicit_costs = cost_of_raw_materials + wages_paid\n    \n    # Calculate opportunity costs (Normal profit + Depreciation)\n    opportunity_costs = normal_profit + depreciation\n    \n    # Calculate economic profit\n    economic_profit = total_revenue - explicit_costs - opportunity_costs\n    \n    # return answer\n    return economic_profit\n\n# You can uncomment the following line to test the function:\n# print(solution())\n```\n\nThis code block defines a function `solution()` which calculates and returns the annual economic profit for Chace's House Industry based on the data provided."
        ]
    },
    {
        "question_id": "validation-13",
        "question": "According to Exhibits 1 and 2, what is the FCFF ($ millions) of the Johnson Company for the fiscal year ending on December 31, 2012?",
        "tables": [
            "| For Year Ending 31 December | 2012 |\n| --------------------------- | ---- |\n| Revenues                   | $6,456 |\n| Earnings before interest,taxes, depreciation, and amortization (EBITDA) | 1,349 |\n| Depreciation expense | 243 |\n| Operating income     | 1,106 |\n| Interest expense     | 186 |\n| Pretax income        | 920 |\n| Income tax (32%)     | 294 |\n| Net income           | $626 |\n|                           |      |\n| Number of outstanding shares (millions) | 411 |\n| 2012 earnings per share     | $1.52 |\n| 2012 dividends paid (millions) | 148 |\n| 2012 dividends per share    | 0.36 |\n| 2012 fixed capital investment (millions) | 535 |\n|                           |      |\n| Cost of equity           | 12.0% |\n| Weighted average cost of capital (WACC) | 9.0% |",
            "| Assets                      | 2012  | 2011  |\n|-----------------------------|-------|-------|\n| Cash and cash equivalents   | $32   | $21   |\n| Accounts receivable         | 413   | 417   |\n| Inventories                 | 709   | 638   |\n| Other current assets        | 136   | 123   |\n| **Total current assets**    | $1,290| $1,199|\n|                             |       |       |\n| Current liabilities         | $2,783| $2,678|\n| Long-term debt              | 2,249 | 2,449 |\n| Common stockholders' equity | 1,072 | 594   |\n| **Total liabilities and stockholders' equity**| $6,104| $5,721|"
        ],
        "python_solution": "def solution():\n    NI = 626\n    NCC = 243\n    Int = 186\n    Tax_rate = 294/920 \n    FCInv = 535\n    WCInvNet = -25\n    FCFF = NI + NCC + Int*(1 - Tax_rate) - FCInv - WCInvNet\n    return FCFF",
        "ground_truth": 485.561,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the Free Cash Flow to the Firm (FCFF) for the fiscal year ending on December 31, 2012, we can use the following formula:\n\nFCFF = EBITDA - Taxes + Depreciation & Amortization - Fixed Capital Investment - Change in Working Capital\n\nIn this case, we'll need to compute the change in working capital, which is the difference in current assets minus the difference in current liabilities between 2012 and 2011.\n\nLet's implement this calculation in a Python program.\n\n```python\ndef solution():\n    # Define variables name and value\n    ebitda = 1349\n    income_tax = 294\n    depreciation_expense = 243\n    fixed_capital_investment = 535\n\n    # Changes in working capital\n    current_assets_2012 = 1290\n    current_assets_2011 = 1199\n    current_liabilities_2012 = 2783\n    current_liabilities_2011 = 2678\n\n    change_in_working_capital = (current_assets_2012 - current_assets_2011) - (current_liabilities_2012 - current_liabilities_2011)\n\n    # Calculate FCFF\n    fcff = ebitda - income_tax + depreciation_expense - fixed_capital_investment - change_in_working_capital\n\n    # return answer\n    return fcff\n\n# Assuming the values are in millions already based on the question context\nprint(solution())\n```\n\nNote: Since the question's context implies that the numbers are in millions already, I'm using the values directly as they are without converting them to actual dollars. If we needed to convert them, we would have to multiply each by a million."
        ]
    },
    {
        "question_id": "validation-14",
        "question": "What is the impairment loss (in C$) for the printing equipment of a Canadian corporation that prepares its financial statements according to IFRS and has seen a decrease in product demand, as of 31 December 2010?",
        "tables": [
            "| | C$ |\n| --- | --- |\n| Carrying value of equipment (net book value) | 500,000 |\n| Undiscounted expected future cash flows | 550,000 |\n| Present value of expected future cash flows | 450,000 |\n| Fair Value | 480,000 |\n| Costs to sell | 50,000 |\n| Value in use | 440,000 |"
        ],
        "python_solution": "def solution():\n    fair_value = 480000\n    cost_to_sell = 50000\n    value_in_use = 440000\n    carrying_value = 500000\n\n    recoverable_amount = max(fair_value - cost_to_sell, value_in_use)\n    impairment_loss = carrying_value - recoverable_amount\n    return impairment_loss",
        "ground_truth": 60000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    carrying_value_of_equipment = 500000\n    recoverable_amount = max(450000, 440000) # Higher of fair value less costs to sell and value in use\n    \n    # Calculate impairment loss\n    impairment_loss = carrying_value_of_equipment - recoverable_amount\n    \n    # Return answer\n    return impairment_loss\n\n# The function can be called to get the impairment loss\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-15",
        "question": "The following information pertains to a bond, what will be the bond's price?",
        "tables": [
            "| Coupon rate            | 3%                   |\n|------------------------|---------------------|\n| Interest paid          | Semiannually        |\n| Mature time            | 3 years             |\n| Required rate of return| 5%                  |\n| Par value of the bond  | 100                 |"
        ],
        "python_solution": "def solution():\n\n    N = 2 * 3\n    I_Y = 5 / 2\n    PMT = 3 / 2\n    FV = 100\n\n    PV = 0\n\n    for i in range(1, N + 1):\n        PV += PMT / ((1 + I_Y/100) ** i)\n    PV += FV / ((1 + I_Y/100) ** N)\n\n    return PV",
        "ground_truth": 94.492,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here's the Python program using the provided structure to calculate the bond's price:\n\n```python\ndef solution():\n    # Define variables name and value\n    coupon_rate = 0.03\n    interest_payment = coupon_rate / 2  # Semiannual payment\n    mature_time = 3  # Years\n    periods = mature_time * 2  # Semiannual periods\n    required_rate_of_return = 0.05 / 2  # Semiannual rate\n    par_value = 100\n    \n    # Do math calculation to get the cash flows and discount them\n    cash_flows = [interest_payment * par_value for _ in range(periods)]  # Coupon payments\n    cash_flows[-1] += par_value  # Add the par value to the last cash flow\n    \n    # Calculate present value of each cash flow\n    present_value = sum(cash_flow / ((1 + required_rate_of_return) ** period) for period, cash_flow in enumerate(cash_flows, start=1))\n\n    # return answer\n    return present_value\n\n# Example usage\n# print(solution())\n```\n\nRunning the program by calling `solution()` will calculate and return the current price of the bond given the provided details. The calculation involves discounting the expected cash flows (coupon payments and the final par value) back to their present value using the semiannual required rate of return."
        ]
    },
    {
        "question_id": "validation-16",
        "question": "In 2009, Shine Kids Ltd., which started its operations in October of that year, bought 10,000 units of a toy at a cost of ₤10 per unit in October. The toy was a hit in October. Expecting a surge in December sales, Shine purchased an additional 5,000 units in November at a cost of ₤11 per unit. During 2009, Shine sold 12,000 units at a rate of ₤15 per unit. What is Shine's cost of goods sold for 2009 using the first in, first out (FIFO) method?",
        "tables": [],
        "python_solution": "def solution():\n    October_units = 10000\n    November_units = 2000\n    October_unit_cost = 10\n    November_unit_cost = 11\n    cost_of_goods_sold = (October_units * October_unit_cost) + (November_units * November_unit_cost)\n    return cost_of_goods_sold",
        "ground_truth": 122000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Cost and quantity of the first purchase\n    cost_per_unit_october = 10\n    units_purchased_october = 10000\n    \n    # Cost and quantity of the second purchase\n    cost_per_unit_november = 11\n    units_purchased_november = 5000\n    \n    # Number of units sold\n    units_sold = 12000\n    \n    # If we use FIFO, we first sell items from the initial purchase\n    if units_sold <= units_purchased_october:\n        # All sold units are from the October purchase\n        cost_of_goods_sold = units_sold * cost_per_unit_october\n    else:\n        # Sold units include all units from October purchase and the remainder from November purchase\n        cost_of_goods_sold_october = units_purchased_october * cost_per_unit_october\n        \n        # Remaining units sold that need to be accounted for from November purchase\n        remaining_units_sold = units_sold - units_purchased_october\n        cost_of_goods_sold_november = remaining_units_sold * cost_per_unit_november\n        \n        # Total COGS\n        cost_of_goods_sold = cost_of_goods_sold_october + cost_of_goods_sold_november\n\n    # return answer\n    return cost_of_goods_sold\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-17",
        "question": "What is the anticipated portfolio return made by an investment company analyst named Maud, under two scenarios of portfolio returns in various economic conditions?",
        "tables": [
            "| Scenario              | Probability of scenario (%) | Portfolio return | Probability of return (%) |\n|-----------------------|-----------------------------|------------------|---------------------------|\n| good economic situation | 70                          | 20%             | 50                        |\n| good economic situation | 70                          | 10%             | 50                        |\n| bad economic situation  | 30                          | 5%              | 60                        |\n| bad economic situation  | 30                          | -10%            | 40                        |"
        ],
        "python_solution": "def solution():\n    good_economic_situation_return = 0.2*0.5 + 0.1*0.5\n    bad_economic_situation_return = 0.05*0.6 + -0.1*0.4\n    general_expected_return = 0.7*good_economic_situation_return + 0.3*bad_economic_situation_return\n    return general_expected_return",
        "ground_truth": 0.102,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To calculate the anticipated portfolio return, we have to average the returns across the different scenarios, weighted by the probability of each scenario and the probability of the return within each scenario.\n\nThe formula to calculate this is:\n\n\\[ \\text{Anticipated Portfolio Return} = \\sum (\\text{Probability of Scenario} \\times \\text{Probability of Return within Scenario} \\times \\text{Portfolio Return}) \\]\n\nLet's convert this formula into the requested Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    \n    # Probabilities of each scenario expressed as decimals\n    prob_good_econ = 0.7\n    prob_bad_econ = 0.3\n    \n    # Probabilities of return within each scenario expressed as decimals\n    prob_good_econ_high_return = 0.5\n    prob_good_econ_low_return = 0.5\n    prob_bad_econ_low_return = 0.6\n    prob_bad_econ_negative_return = 0.4\n    \n    # Corresponding portfolio returns\n    return_good_econ_high = 0.20\n    return_good_econ_low = 0.10\n    return_bad_econ_low = 0.05\n    return_bad_econ_negative = -0.10\n    \n    # Do math calculation to get the answer\n    anticipated_return = (\n        (prob_good_econ * prob_good_econ_high_return * return_good_econ_high) +\n        (prob_good_econ * prob_good_econ_low_return * return_good_econ_low) +\n        (prob_bad_econ * prob_bad_econ_low_return * return_bad_econ_low) +\n        (prob_bad_econ * prob_bad_econ_negative_return * return_bad_econ_negative)\n    )\n    \n    # Return answer as a percentage\n    return anticipated_return * 100\n    \n# Call the function and print the answer\nprint(f\"Anticipated portfolio return is: {solution()}%\")\n```\n\nThis program calculates the weighted average of expected returns, considering each scenario's probability and the return probability within that scenario. The result is then returned as a percentage."
        ]
    },
    {
        "question_id": "validation-18",
        "question": "Suppose a US enterprise employs LIFO for its stock accounting. At the start of 2017, the balance sheet shows inventory at $200,000, with a LIFO reserve of $30,000. By the close of 2017, the inventory stands at $250,000, with a LIFO reserve of $40,000. With a tax rate of 30%, what would the inventory be at the end of 2017 after converting from LIFO to FIFO?",
        "tables": [],
        "python_solution": "def solution():\n    LIFO_inventory = 250000\n    LIFO_reserve = 40000\n    FIFO_inventory = LIFO_inventory + LIFO_reserve\n    return FIFO_inventory",
        "ground_truth": 290000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    ending_inventory_lifo = 250000\n    beginning_lifo_reserve = 30000\n    ending_lifo_reserve = 40000\n    tax_rate = 0.30\n\n    # Calculate the FIFO inventory\n    fifo_inventory = ending_inventory_lifo + ending_lifo_reserve  # FIFO inventory before tax effect\n    increment_in_lifo_reserve = ending_lifo_reserve - beginning_lifo_reserve\n    tax_effects = increment_in_lifo_reserve * tax_rate\n    inventory_under_fifo_after_tax = fifo_inventory - tax_effects\n    \n    # return answer\n    return inventory_under_fifo_after_tax\n    \n# You can test the function with the following code\nprint(solution())\n```\nThis program defines variables to represent the given data, performs calculations to determine the FIFO inventory before and after tax effects due to the increase in the LIFO reserve, and returns the FIFO inventory after accounting for the tax impact."
        ]
    },
    {
        "question_id": "validation-19",
        "question": "What is the cost per 100 of par value for a zero-coupon bond with a maturity of 15 years, given a yearly market discount rate of 4.5% and assuming yearly compound interest?",
        "tables": [],
        "python_solution": "def solution():\n    r = 0.045\n    n = 15\n    fv = 100\n    pv = fv / ((1 + r) ** n)\n    return pv",
        "ground_truth": 51.672,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    par_value = 100  # the par value of the bond\n    years_to_maturity = 15  # the years to maturity\n    market_discount_rate = 0.045  # the yearly market discount rate\n\n    # Do math calculation to get the answer using the formula P = F / (1 + r)^n\n    # where P = present value or cost, F = future value or par value,\n    # r = discount rate, n = number of periods\n    cost = par_value / ((1 + market_discount_rate) ** years_to_maturity)\n\n    # return answer\n    return cost\n    \n# call the function and print the result\nprint(solution())\n```\nThis program will calculate the cost per 100 of par value for the specified zero-coupon bond."
        ]
    },
    {
        "question_id": "validation-20",
        "question": "A company noted a gain on redemption of $100,000 with a carrying value of $950,000, and a face value of $1 million. Kindly compute the call price:",
        "tables": [],
        "python_solution": "def solution():\n    carrying_value = 950000\n    gain_on_redemption = 100000\n    call_price = carrying_value - gain_on_redemption\n    return call_price/10000.0",
        "ground_truth": 85.0,
        "topic": "Accounting",
        "output": [
            "Here is the Python program to compute the call price:\n\n```python\ndef solution():\n    # Define variables name and value\n    gain_on_redemption = 100000\n    carrying_value = 950000\n    \n    # Do math calculation to get the answer\n    # Call price = Carrying Value + Gain on Redemption\n    call_price = carrying_value + gain_on_redemption\n    \n    # return answer\n    return call_price\n    \n# You can test the function with the following line:\n# print(solution())\n```\n\nThe program calculates the call price by adding the gain on redemption to the carrying value of the bond."
        ]
    },
    {
        "question_id": "validation-21",
        "question": "Based on the provided document, we have three spot rate ratios between USD and other currencies. Which option is most precise for the spot EUR/GBP cross-rate?",
        "tables": [
            "| Ratio   | Spot rate |\n|---------|-----------|\n| USD/EUR | 1.3860    |\n| EUR/CAD | 0.6125    |\n| USD/GBP | 1.4208    |"
        ],
        "python_solution": "def solution():\n    USD_EUR = 1.3860\n    USD_GBP = 1.4208\n    EUR_GBP = (1 / USD_EUR) * USD_GBP\n    return EUR_GBP",
        "ground_truth": 1.025,
        "topic": "Market Analysis & Economics",
        "output": [
            "Certainly! To find the spot EUR/GBP cross-rate, we have to use the provided USD/EUR and USD/GBP spot rates. The formula to obtain the EUR/GBP rate using indirect quoting is to divide the USD/GBP rate by the USD/EUR rate. Here's the Python program to compute that:\n\n```python\ndef solution():\n    # Define variables name and values\n    usd_eur_spot_rate = 1.3860\n    usd_gbp_spot_rate = 1.4208\n    \n    # Calculate the EUR/GBP cross-rate by dividing the USD/GBP rate by the USD/EUR rate\n    eur_gbp_cross_rate = usd_gbp_spot_rate / usd_eur_spot_rate\n    \n    # return answer\n    return eur_gbp_cross_rate\n\n# Example usage:\n# print(solution())\n```\nThis program will return the calculated value for the EUR/GBP cross-rate."
        ]
    },
    {
        "question_id": "validation-22",
        "question": "Based on Exhibit 1, what is the five-year spot rate for Steve, a bond trader at a financial institution? Keep in mind that par and spot rates are derived from annual-coupon sovereign bonds.",
        "tables": [
            "|Maturity   | Par Rate | Spot rate |\n|---|---|---|\n| One-Year  | 2.50%  | 2.50%  |\n| Two-Year  | 2.99%  | 3.00%  |\n| Three-Year  | 3.48%  | 3.50%  |\n| Four-Year  | 3.95%  | 4.00%  |\n| Five-Year  | 4.37%  |   |"
        ],
        "python_solution": "def solution():\n    # given spot rates and swap rate\n    spot_rates = [0.025, 0.03, 0.035, 0.04]\n    swap_rate = 0.0437\n\n    # calculate the sum of discounted swap rate payments \n    sum_discounted_payments = sum([swap_rate / ((1 + rate) ** i) for i, rate in enumerate(spot_rates, start=1)])\n\n    # calculate the 5-year spot rate solving the formula above for S5\n    S5 = ((1 + swap_rate) / (1 - sum_discounted_payments))**(1/5) - 1\n\n    # return S5 in percentage\n    return S5 * 100",
        "ground_truth": 4.453,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To find the five-year spot rate, we can use the bootstrap method. Since we have information for the first four years' spot rates, we can infer the five-year spot rate using the four-year spot rate and the five-year par rate.\n\nWe know that the present value of all cash flows (coupons and principal) must equal the bond price, which for par value bonds is typically 100%.\n\nFor a five-year bond with annual coupons at the five-year par rate (since that's the rate at which the bond would trade at par), we can set up the following equation:\n\n\\[ P = \\frac{C}{(1 + r_1)} + \\frac{C}{(1 + r_2)^2} + \\frac{C}{(1 + r_3)^3} + \\frac{C}{(1 + r_4)^4} + \\frac{C + F}{(1 + r_5)^5} \\]\n\nWhere:\n- \\( P \\) is the bond price, which equals 100 (since it's at par)\n- \\( C \\) is the coupon payment, which would be the par rate times the face value (\\( F \\), typically equal to 100)\n- \\( r_1, r_2, r_3, r_4 \\) are the known spot rates for years 1 to 4\n- \\( r_5 \\) is the unknown five-year spot rate we are solving for\n\nRearranged to solve for \\( r_5 \\), the equation becomes:\n\\[ r_5 = \\left( \\frac{C + F}{P - \\sum_{i=1}^{4} \\left( \\frac{C}{(1 + r_i)^i} \\right)} \\right)^{1/5} - 1 \\]\n\nLet us now define a Python function to calculate this:\n\n```python\ndef solution():\n    # Define known spot rates\n    spot_rates = [0.0250, 0.0300, 0.0350, 0.0400]  # 1-year to 4-year spot rates\n    # Define the par rate for the 5-year bond\n    par_rate = 0.0437\n    \n    # Assume face value of bond is 100, same for bond price since it's par\n    F = P = 100\n    # Calculate the coupon payment\n    C = par_rate * F\n    \n    # Calculate the sum of the present value of the first four years' coupons\n    present_value_sum = sum(C / ((1 + r) ** i) for i, r in enumerate(spot_rates, 1))\n    \n    # Solve for the five-year spot rate\n    r_5 = ((C + F) / (P - present_value_sum)) ** (1 / 5) - 1\n    \n    # Return answer as a percentage\n    return r_5 * 100\n\n# Call the solution function and print the result\nprint(solution())\n```\nPlease note that actual implementations may involve more complex calculations due to day count conventions, compounding frequency, market conventions, and additional factors. The code above is a simplified demonstration using hypothetical data and assuming annual coupon payments."
        ]
    },
    {
        "question_id": "validation-23",
        "question": "A risk manager specializing in market risk is looking to determine the cost of a 2-year zero-coupon bond. The current 1-year interest rate is 8.0%. There's a chance of 50% that the 1-year interest rate will reach 10.0% after one year and an equal probability of its falling to 6.0% in the same period. Suppose the yearly risk premium for duration risk is 40 bps, and the bond faces a value of EUR 1,000. What should be the zero-coupon bond's valuation?",
        "tables": [],
        "python_solution": "def solution():\n    bond_face_value = 1000\n    risk_free_rate = 0.08\n    risk_premium = 0.004\n    up_interest_rate = 0.10\n    down_interest_rate = 0.06\n    probability_up = 0.5\n    probability_down = 0.5\n\n    up_price_date1 = bond_face_value / (1 + up_interest_rate + risk_premium)\n    down_price_date1 = bond_face_value / (1 + down_interest_rate + risk_premium)\n\n    expected_price_date1 = probability_up * up_price_date1 + probability_down * down_price_date1\n    zero_coupon_bond_price = expected_price_date1 / (1 + risk_free_rate + risk_premium)\n    \n    return zero_coupon_bond_price",
        "ground_truth": 851.313,
        "topic": "Risk Management",
        "output": [
            "To find the present value of the 2-year zero-coupon bond, we need to consider the different interest rate scenarios and the risk premium. The expected interest rate for the second year can be determined by taking the average of the two possible interest rates, weighted by their probabilities. Also, we need to adjust for the risk premium.\n\nHere's how we'd write a Python program to calculate this:\n\n```python\n# Import package if needs\ndef solution():\n    # Define variables name and value\n    face_value = 1000  # EUR\n    current_rate = 0.08  # Current 1-year interest rate\n    rate_up = 0.10  # Possible interest rate after one year (up scenario)\n    rate_down = 0.06  # Possible interest rate after one year (down scenario)\n    risk_premium = 0.004  # Risk premium for duration risk (40 bps)\n    probability_up = 0.5\n    probability_down = 0.5\n\n    # Compute the expected 1-year interest rate for the second year\n    expected_rate_second_year = (rate_up * probability_up) + (rate_down * probability_down)\n\n    # Adjust for risk premium\n    expected_rate_second_year += risk_premium\n\n    # Compute the discount rates for the two years\n    discount_rate_first_year = 1 / (1 + current_rate)\n    discount_rate_second_year = 1 / ((1 + current_rate) * (1 + expected_rate_second_year))\n\n    # Calculate the present value of the bond\n    present_value = face_value * discount_rate_second_year\n\n    # return answer\n    return round(present_value, 2)  # Rounded to 2 decimal places for currency format\n    \n# Call the function to get the answer\nprint(solution())\n```\n\nYou simply need to run this function, and it will return the present value of the zero-coupon bond based on the input variables."
        ]
    },
    {
        "question_id": "validation-24",
        "question": "Assuming that the variances of the underlying populations are equal, independent samples taken from normally distributed groups display the following features: The combined estimation of the common variance is 2,678.05. What is the suitable t-test statistic to verify the assumption that the average of the two populations are the same?",
        "tables": [
            "| Sample Size | Sample Mean | Sample Standard Deviation |\n|-------------|-------------|--------------------------|\n| A 25        | 200         | 45                       |\n| B 18        | 185         | 60                       |"
        ],
        "python_solution": "def solution():\n    return (200 - 185) / (2678.05 / 25 + 2678.05 / 18)**0.5",
        "ground_truth": 0.938,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom math import sqrt\n\ndef solution():\n    # Define variables name and values\n    sample_size_a = 25\n    sample_mean_a = 200\n    sample_std_dev_a = 45\n    \n    sample_size_b = 18\n    sample_mean_b = 185\n    sample_std_dev_b = 60\n    \n    # Given combined estimate of the common variance\n    combined_variance = 2678.05\n    \n    # Calculate the standard error (SE) of the difference in sample means\n    SE = sqrt(combined_variance / sample_size_a + combined_variance / sample_size_b)\n    \n    # Calculate the t-test statistic\n    t_test_statistic = (sample_mean_a - sample_mean_b) / SE\n    \n    # Return the computed t-test statistic\n    return t_test_statistic\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis Python program calculates the t-test statistic to test the hypothesis that the two population means are the same, given an equal variance assumption and provided sample statistics. The combined variance has been directly used in the calculation instead of deriving it from the provided sample variances, as it has been given in the problem statement. The obtained t-test statistic value is used to determine if there is a significant difference between the two population means. Note that to determine the significance of the t-statistic, you would need to compare it to a critical value from a t-distribution table (not computed here)."
        ]
    },
    {
        "question_id": "validation-25",
        "question": "The following data is gleaned from the financial statements of Sugarfall Corporation. How much cash did Sugarfall Corp. pay to its suppliers?",
        "tables": [
            "| Income Statement          | Balance Sheet Changes                         |     |\n|---------------------------|-----------------------------------------------|-----|\n| Revenue                   | $56,800  Decrease in accounts receivable $1,324 |     |\n| Cost of goods sold        | $27,264  Decrease in inventory               | 501 |\n| Other operating expense   | $562 Increase in prepaid expense             | 6   |\n| Depreciation expense      | $2,500 Increase in accounts payable          | 1,063 |"
        ],
        "python_solution": "def solution():\n    cost_of_goods_sold = 27264\n    decrease_in_inventory = 501\n    increase_in_accounts_payable = 1063\n    cash_paid_to_suppliers = cost_of_goods_sold - decrease_in_inventory - increase_in_accounts_payable\n    return cash_paid_to_suppliers",
        "ground_truth": 25700.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    revenue = 56800\n    cogs = 27264  # Cost of goods sold\n    depreciation = 2500\n    decrease_in_inventory = 501\n    increase_in_accounts_payable = 1063\n\n    # Calculate purchases = COGS + Increase in inventory – Depreciation\n    purchases = cogs + decrease_in_inventory - depreciation\n\n    # Calculate cash paid to suppliers = purchases - increase in accounts payable\n    cash_paid_to_suppliers = purchases - increase_in_accounts_payable\n\n    # Return answer\n    return cash_paid_to_suppliers\n\n# Run the function and print the result\nprint(solution())\n```\n\nNote that the \"Revenue\" and \"Other operating expense\" parts from the income statement and \"Decrease in accounts receivable\" and \"Increase in prepaid expense\" from the balance sheet changes are not used in calculating the cash paid to suppliers. We focus on the \"Cost of Goods Sold,\" \"Depreciation expense,\" \"Decrease in inventory,\" and \"Increase in accounts payable\" to determine the cash payments to suppliers."
        ]
    },
    {
        "question_id": "validation-26",
        "question": "What is the compensation expense for 2011 resulting from the executive stock options provided by the firm in 2011? The firm gave its senior managers 20,000 options on its common stocks on January 1, 2011. The options have a lock-in period of 4 years and lapse after 5 years of being given. The option price on the day they were granted was $2.5 per option. The average option price for the whole year was $2.8 per option. The fair value of the company's stocks on the grant day, January 1, 2011, was $15 per share.",
        "tables": [],
        "python_solution": "def solution():\n    options = 20000\n    option_price = 2.5\n    vesting_period = 4\n\n    compensation_expense_2011 = options * option_price / vesting_period\n\n    return compensation_expense_2011",
        "ground_truth": 12500.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    number_of_options = 20000\n    option_price_on_grant_day = 2.5\n    average_option_price = 2.8\n    fair_value_on_grant_day = 15\n\n    # Calculate intrinsic value, which is the excess of market price over the option price\n    intrinsic_value_on_grant_day = fair_value_on_grant_day - option_price_on_grant_day\n\n    # Calculate the fair value of each option; assume it equals the intrinsic value\n    fair_value_of_each_option = intrinsic_value_on_grant_day\n\n    # As per accounting standards, compensation expense is based on the fair value of options at the grant date\n    # Calculate total compensation expense for 2011\n    total_compensation_expense = number_of_options * fair_value_of_each_option\n    \n    # return answer\n    return total_compensation_expense\n\n# Call the solution function and print the returned value\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-27",
        "question": "If a security has a yearly adjusted period of 7.020 and an annual convexity of 65.180 and its return to maturity falls by 25 basis points, what is the anticipated percentage change in price?",
        "tables": [],
        "python_solution": "def solution():\n    ann_mod_dur = 7.020\n    ann_converxity = 65.180\n    delta_yield = -0.0025\n\n    price_change = (-ann_mod_dur * delta_yield) + (0.5 * ann_converxity * (delta_yield ** 2))\n    return price_change * 100  # convert to percentage",
        "ground_truth": 1.775,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! To calculate the anticipated percentage change in the price of a security given its duration, convexity, and a change in yield (interest rates), we use the formula:\n\n\\[\n\\text{Percentage Change in Price} = -(\\text{Duration} \\times \\text{Change in Yield}) + \\frac{1}{2} \\text{Convexity} \\times (\\text{Change in Yield})^2\n\\]\n\nRemember to convert the change in yield (known as basis points) into its decimal form by dividing by 10,000. If the yield falls by 25 basis points, the change in yield is -0.0025.\n\n```python\n# Import package if needs\ndef solution():\n    # Define variables name and value\n    duration = 7.020  # Adjusted duration in years\n    convexity = 65.180  # Annual convexity\n    change_in_yield = -0.25 / 100  # Change in yield (25 basis points converted to decimal)\n\n    # Do math calculation to get the answer\n    percentage_change_in_price = (-duration * change_in_yield) + (0.5 * convexity * (change_in_yield ** 2))\n\n    # return answer\n    return percentage_change_in_price\n```"
        ]
    },
    {
        "question_id": "validation-28",
        "question": "What is the intrinsic value of preferred stock when the non-exchangeable and non-refundable preferred shares launched by the U.S. life assurance group are 5.80 percent at a par value of $30? The identical issue has a return rate of 5 percent.",
        "tables": [],
        "python_solution": "def solution(): \n    # Expected annual dividend equals to 5.8% × $30\n    dividend = (5.8 / 100) * 30 \n\n    # Value of preferred stock is dividend / 0.05 \n    stock_value = dividend / 0.05 \n\n    return stock_value",
        "ground_truth": 34.8,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! Here's a Python program to calculate the intrinsic value of a preferred stock based on the given par value, dividend rate, and return rate:\n\n```python\ndef solution():\n    # Define variables name and value\n    par_value = 30.00\n    dividend_rate = 5.80 / 100  # Convert percentage to decimal\n    return_rate = 5.00 / 100    # Convert percentage to decimal\n    \n    # Calculate intrinsic value using the formula intrinsic_value = dividend / return_rate\n    intrinsic_value = (par_value * dividend_rate) / return_rate\n    \n    # return answer\n    return intrinsic_value\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program defines variables for the par value, dividend rate, and return rate of the preferred stock. Then, it calculates the intrinsic value based on the formula: intrinsic value = dividend (calculated as par value * dividend rate) divided by the required rate of return. Finally, it returns the intrinsic value as the answer."
        ]
    },
    {
        "question_id": "validation-29",
        "question": "Assume that the initial value is 400 and the risk-free rate stands at 5%. The asset offers a continuous dividend of 3%. Determine the forward price for a forward contract of 6 months:",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    F0 = 400 * math.exp((0.05 - 0.03) * 0.5)\n    return F0",
        "ground_truth": 404.02,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Given variables\n    initial_value = 400\n    risk_free_rate = 0.05\n    continuous_dividend = 0.03\n    time_to_maturity = 0.5 # 6 months expressed in years\n    \n    # Calculate the forward price using the formula: F = S0 * e^((r-q)*t)\n    # where F is the forward price, S0 is the initial value, r is the risk-free rate, q is the continuous dividend rate, and t is the time to maturity\n    forward_price = initial_value * math.exp((risk_free_rate - continuous_dividend) * time_to_maturity)\n    \n    # return the answer\n    return forward_price\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-30",
        "question": "In the last 36 months, the standard deviation for the monthly returns of an investment portfolio has been 4.9%. To evaluate an assertion that the investment strategy for this portfolio yields a standard deviation of monthly returns below 5.0%, what is the test statistic's value?",
        "tables": [],
        "python_solution": "def solution():\n    n = 36\n    s = 0.049\n    sigma = 0.05\n    chi_square_statistic = ((n - 1) * s**2) / sigma**2\n    return chi_square_statistic",
        "ground_truth": 33.614,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport scipy.stats as stats\n\ndef solution():\n    # Define variables name and value\n    sample_std = 4.9\n    hypothesized_std = 5.0\n    sample_size = 36  # 36 months\n    \n    # Calculate the test statistic for one-sample z-test for standard deviation\n    # Using the formula for the test statistic: z = (sample_std - hypothesized_std) / (hypothesized_std / sqrt(n))\n    # Multiply by sample size under the square root since we are dealing with standard deviation, not variance\n    test_statistic = (sample_std - hypothesized_std) / (hypothesized_std / (sample_size ** 0.5))\n    \n    # return test_statistic\n    return test_statistic\n\n# Call the function and print the result    \nprint(solution())\n```\n\nPlease note that the test statistic in this context likely refers to the z-score calculated using the sample standard deviation (4.9%) and the hypothesized population standard deviation (5.0%). The formula used is for illustrative purposes and assumes that the sample is normally distributed and that the sample size is large enough for the z-test to be appropriate."
        ]
    },
    {
        "question_id": "validation-31",
        "question": "Using the 2007 and 2008 financial reports for Holt Corporation, which are presented in Exhibits 1 and 2 and in line with US GAAP, what is Holt's 2008 FCFE (in millions) as Jake Thompson is preparing a presentation to analyze the valuation of this company and Emerald Corp's common stock using a FCFE model? Thompson also plans to do a value estimate for Emerald through a dividend discount model for potential recommendations to his firm.",
        "tables": [
            "|                                           |                    |  2008   |                   |  2007   |\n|-------------------------------------------|--------------------|---------|-------------------|---------|\n| **As of 31 December**                     |                    |         |                   |         |\n| **Assets**                                |                    |         |                   |         |\n| Current assets                            |                    |         |                   |         |\n| Cash and cash equivalents                 |                    |   $372  |                   |  $315   |\n| Accounts receivable                       |                    |   $770  |                   |  $711   |\n| Inventories                               |                    |   $846  |                   |  $780   |\n| Total current assets                      |                    |  $1,988 |                   |  $1,806 |\n| Gross fixed assets                        |   $4,275           |         |   $3,752          |         |\n| Less: Accumulated depreciation            |   $1,176           |  $3,099 |   $906            |  $2,846 |\n| **Total assets**                          |                    |  $5,087 |                   |  $4,652 |\n| **Liabilities and shareholders' equity**  |                    |         |                   |         |\n| Current liabilities                       |                    |         |                   |         |\n| Accounts payable                          |                    |  $476   |                   |  $443   |\n| Accrued taxes and expenses                |                    |  $149   |                   |  $114   |\n| Notes payable                             |                    |  $465   |                   |  $450   |\n| Total current liabilities                 |                    |  $1,090 |                   |  $1,007 |\n| Long-term debt                            |                    |  $1,575 |                   |  $1,515 |\n| Common stock                              |                    |  $525   |                   |  $525   |\n| Retained earnings                         |                    |  $1,897 |                   |  $1,605 |\n| **Total liabilities and shareholders' equity** |              |  $5,087 |                   |  $4,652 |",
            "|   |   |\n|---|---|\n| Total revenues | $3,323 |\n| Cost  of goods  sold | 1,287 |\n| Selling, general, and administrative expenses | 858 |\n| Earnings before interest, taxes, depreciation, and amortization (EBITDA) | 1,178 |\n| Depreciation expense | 270 |\n| Operating income | 908 |\n| Interest expense | 195 |\n| Pretax income | 713 |\n| Income tax (at 32 percent) | 228 |\n| Net income | $485 |"
        ],
        "python_solution": "def solution():\n    NI = 485\n    NCC = 270\n    FCInv = 4275 - 3752\n    WCInv = (770-711) + (846-780) - (476-443) - (149-114)\n    Net_borrowing = (465-450) + (1575-1515)\n    FCFE = NI + NCC - FCInv - WCInv + Net_borrowing\n    return FCFE",
        "ground_truth": 250.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # From the income statement:\n    net_income = 485  # in millions\n\n    # From the cash flow activities:\n    # There no details on CapEx, we need to infer from the change in Gross Fixed Assets and Depreciation\n    gross_fixed_assets_2007 = 3752\n    gross_fixed_assets_2008 = 4275\n    accumulated_depreciation_2007 = 906\n    accumulated_depreciation_2008 = 1176\n    depreciation_expense_2008 = 270\n\n    # Since CapEx is not given, we assume all changes in gross fixed assets are due to CapEx\n    # and accumulated depreciation changes are due to depreciation expense.\n    capex = gross_fixed_assets_2008 - gross_fixed_assets_2007 + accumulated_depreciation_2008 - accumulated_depreciation_2007 - depreciation_expense_2008\n    \n    # Change in working capital:\n    # We can infer it from changes in current assets and liabilities (excluding cash and cash equivalents and notes payable which\n    # is a financing activity)\n    # Change in working capital = (Current assets excluding cash) - (Current liabilities excluding notes payable)\n    \n    # Current assets (excluding cash for 2007 and 2008):\n    current_assets_excluding_cash_2007 = 1806 - 315  # $1,806 - $315\n    current_assets_excluding_cash_2008 = 1988 - 372  # $1,988 - $372\n    \n    # Current liabilities (excluding notes payable for 2007 and 2008):\n    current_liabilities_excluding_notes_payable_2007 = 1007 - 450  # $1,007 - $450\n    current_liabilities_excluding_notes_payable_2008 = 1090 - 465  # $1,090 - $465\n    \n    # Calculate the change in working capital\n    change_in_working_capital = (current_assets_excluding_cash_2008 - current_assets_excluding_cash_2007) - (current_liabilities_excluding_notes_payable_2008 - current_liabilities_excluding_notes_payable_2007)\n    \n    # Calculate FCFE:\n    # FCFE = Net Income - CapEx - Change in Working Capital + Net Borrowing\n    # Net Borrowing = Long-term debt of 2008 - Long-term debt of 2007\n    long_term_debt_2007 = 1515\n    long_term_debt_2008 = 1575\n    net_borrowing = long_term_debt_2008 - long_term_debt_2007\n    \n    # Compute FCFE\n    fcfe = net_income - capex - change_in_working_capital + net_borrowing\n    \n    # return answer\n    return fcfe\n\n# Call the function and print the answer\nprint(solution())\n```\n\nThis program defines variables according to Holt Corporation's 2007 and 2008 financial reports. It then calculates the Free Cash Flow to Equity (FCFE) for 2008. The calculation is based on net income, capital expenditures (CapEx), changes in working capital, and net borrowing. Note that since the capital expenditure (CapEx) is not explicitly stated, it is inferred from the change in Gross Fixed Assets and Accumulated Depreciation, adjusting for the Depreciation Expense reported. Working capital changes are calculated by considering changes in current assets and liabilities, excluding cash, cash equivalents, and notes payable. Net Borrowing is the difference between long-term debt between years. Finally, FCFE is determined and returned by the function."
        ]
    },
    {
        "question_id": "validation-32",
        "question": "Can you determine the sustainable growth rate, please?",
        "tables": [
            "| Items                        | Times |\n| ------------------------     | ----- |\n| net profit margin            | 20%   |\n| retention rate               | 60%   |\n| asset turnover               | 0.8   |\n| financial leverage multiplier| 1.5   |"
        ],
        "python_solution": "def solution():\n    ROE = 0.2 * 0.8 * 1.5\n    sustainable_growth_rate = 0.6 * ROE\n    return sustainable_growth_rate",
        "ground_truth": 0.144,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    net_profit_margin = 0.20  # 20%\n    retention_rate = 0.60     # 60%\n    asset_turnover = 0.8      # 0.8 times\n    financial_leverage_multiplier = 1.5  # 1.5 times\n\n    # Calculating return on equity (ROE)\n    return_on_equity = net_profit_margin * asset_turnover * financial_leverage_multiplier\n    \n    # Calculate sustainable growth rate (SGR)\n    sustainable_growth_rate = return_on_equity * retention_rate\n    \n    # return answer\n    return sustainable_growth_rate\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-33",
        "question": "What is the immediate ZAR/HKD exchange rate given by a broker?",
        "tables": [
            "| Ratio | Spot rate |\n|-------|-----------|\n| CNY/HKD | 0.8422 |\n| CNY/ZAR | 0.9149 |\n| CNY/SEK | 1.0218 |"
        ],
        "python_solution": "def solution():\n    CNY_ZAR = 0.9149\n    CNY_HKD = 0.8422\n    ZAR_HKD = (1/CNY_ZAR) * CNY_HKD\n    return ZAR_HKD",
        "ground_truth": 0.921,
        "topic": "Market Analysis & Economics",
        "output": [
            "Here's a Python program that calculates the immediate ZAR/HKD exchange rate given by a broker using the cross rates from CNY to ZAR and CNY to HKD. \n\n```python\ndef solution():\n    # Define variables name and value\n    cny_to_hkd = 0.8422\n    cny_to_zar = 0.9149\n    \n    # Do math calculation to get the answer \n    # We use the reciprocal of the CNY/HKD rate to get HKD/CNY\n    # Then multiply it by CNY/ZAR to get ZAR/HKD\n    zar_to_hkd = cny_to_zar / cny_to_hkd\n    \n    # return answer\n    return zar_to_hkd\n\n# Example use:\n# print(solution())\n```\n\nNote: The `print(solution())` at the bottom is commented out and can be removed or uncommented if you want to run the function and see the output."
        ]
    },
    {
        "question_id": "validation-34",
        "question": "What weight will be applied to a four-day-old return when forecasting the conditional variance using a RiskMetrics EWMA model with a decay factor λ = 0.95 on a daily basis?",
        "tables": [],
        "python_solution": "def solution():\n    decay_factor = 0.95\n    weight_of_last_day = (1 - decay_factor)\n    weight_four_days_ago = weight_of_last_day * pow(decay_factor, 3)\n    return weight_four_days_ago",
        "ground_truth": 0.043,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define the decay factor (lambda) and the number of days (t)\n    decay_factor = 0.95\n    days_old = 4\n    \n    # Calculate the weight using the exponential decay formula for the EWMA model\n    weight = (1 - decay_factor) * (decay_factor ** (days_old - 1))\n    \n    # Return the calculated weight\n    return weight\n    \n```"
        ]
    },
    {
        "question_id": "validation-35",
        "question": "After putting $180,000 in an investment today with an interest rate of 10% that compounds on a daily basis, what will the worth of the investment be after 2 years for a shareholder?",
        "tables": [],
        "python_solution": "def solution():\n    principal = 180000\n    rate = 10 / 100\n    time = 2\n    n = 365\n\n    amount = principal * (1 + rate / n) ** (n * time)\n    \n    return int(amount)",
        "ground_truth": 219846.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here is the Python program that will calculate the future value of the investment:\n\n```python\n# Import package if needs\nimport math\n\ndef solution():\n    # Define variables name and value\n    principal = 180000\n    rate = 0.10\n    time = 2 # in years\n    n = 365 # compounding daily\n\n    # Do math calculation to get the answer\n    future_value = principal * (1 + rate / n) ** (n * time)\n    \n    # return answer\n    return round(future_value, 2)\n```\n\nThe `round(future_value, 2)` function rounds the result to two decimal places to represent currency value properly."
        ]
    },
    {
        "question_id": "validation-36",
        "question": "The inventory account of a company experienced the following transactions in June: Under the periodic FIFO inventory costing, what was the gross profit for June?",
        "tables": [
            "|   Date   |  Transaction |           Units           |    Unit cost    |\n|:--------:|:------------:|:-------------------------:|:---------------:|\n| June 1   |   Inventory  |          20 units @      |    $5.00/unit   |\n| June 12  |   Purchased  |          70 units @      |    $5.20/unit   |\n| June 16  |     Sold     |   50 units @ $6.00/unit  |                 |\n| June 26  |   Purchased  |   35 units @ $5.5/unit   |                 |\n| June 29  |     Sold     |   40 units @ $6.50/unit  |                 |"
        ],
        "python_solution": "def solution():\n    sales = (50 * 6) + (40 * 6.5)\n    COGS = (20 * 5) + (70 * 5.2)\n    gross_profit = sales - COGS\n    return gross_profit",
        "ground_truth": 96.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    sales_revenue = (50 * 6.00) + (40 * 6.50)  # Total revenue from sales\n    \n    # FIFO: first items purchased are the first ones sold\n    # First sale (50 units): 20 units from June 1 inventory + 30 units from June 12 purchase\n    cost_of_goods_sold_first_sale = (20 * 5.00) + (30 * 5.20)\n    \n    # Second sale (40 units): remaining 40 units from June 12 purchase\n    cost_of_goods_sold_second_sale = (40 * 5.20)\n    \n    # Total cost of goods sold for June\n    total_cost_of_goods_sold = cost_of_goods_sold_first_sale + cost_of_goods_sold_second_sale\n    \n    # Gross profit calculation\n    gross_profit = sales_revenue - total_cost_of_goods_sold\n    \n    # return answer\n    return gross_profit\n\n# Running the program\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-37",
        "question": "A medium-sized American utilities firm requires a return rate of 10%. Johnson and his colleagues predict that, due to a recent reorganization, the firm probably won't distribute dividends for the following three years. However, they anticipate that ABC will start paying an annual dividend of US$1.72 for each share starting from the fourth year onwards. After this, the dividend is predicted to experience a perpetual growth of 4%, though the present price suggests a growth rate of 6% for the identical timeframe. If Johnson's team employs the dividend discount model, what would be the current inherent value of Company ABC stock?",
        "tables": [],
        "python_solution": "def solution():\n    D4 = 1.72\n    r = 0.10\n    g = 0.04\n    P3 = D4/(r-g)\n    V0 = P3 / ((1+r)**3)\n    return V0",
        "ground_truth": 21.538,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the current intrinsic value of Company ABC stock using the Dividend Discount Model, we need to use the Gordon Growth Model which calculates the present value of an infinite series of future dividends that are expected to grow at a constant rate. The model is given by the formula:\n\nP = D / (r - g)\n\nWhere:\nP = Current stock price\nD = Dividend per share one year from now\nr = Required rate of return\ng = Growth rate of dividends\n\nHowever, since the firm will not distribute dividends for the following three years, we need to calculate the present value of the expected dividends starting from the fourth year. Therefore, the intrinsic value of the stock in today's terms would be the present value of the dividends expected to begin in year 4.\n\nTo calculate D (the dividend in year 4), we multiply the first expected dividend of $1.72 by the growth rate expected from year 4 onwards (4%).\n\nThe formula for the present value of a perpetuity (dividends starting in year 4) is:\n\nP = D4 / ( (1+r)^3 * (r - g) )\n\nWhere D4 is the dividend received in year 4 and calculated by D4 = D1 * (1 + g)^3 since there are no dividends for the first three years. D1 in this context is the dividend expected to be received starting from the fourth year.\n\nLet's write the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    required_return = 0.10  # 10% required rate of return\n    growth_rate = 0.04      # 4% growth rate starting from year 4\n    first_dividend = 1.72   # First dividend expected in year 4\n    \n    # Calculate dividend in year 4, considering growth from year 4 onwards\n    D4 = first_dividend * (1 + growth_rate) ** 3\n    \n    # Calculate the present value of the expected dividends starting from year 4\n    intrinsic_value = D4 / ((1 + required_return)**3 * (required_return - growth_rate))\n    \n    # Return the intrinsic value\n    return intrinsic_value\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe intrinsic value calculated with the given information will be the output when this program is run."
        ]
    },
    {
        "question_id": "validation-38",
        "question": "Assuming a payout ratio of 50% and a growth rate of 10%, and a return rate of 15%, what is the leading price-to-earnings (P/E) ratio for Tiger Corporation?",
        "tables": [],
        "python_solution": "def solution():\n    divident_payout_ratio = 0.5\n    k = 0.15\n    g = 0.1\n    P_E = divident_payout_ratio / (k - g)\n    return P_E",
        "ground_truth": 10.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define dividend payout ratio, growth rate, and required rate of return\n    payout_ratio = 0.50   # 50%\n    growth_rate = 0.10    # 10%\n    required_return = 0.15 # 15%\n\n    # Do math calculation to get the leading price-to-earnings (P/E) ratio\n    leading_pe_ratio = payout_ratio / (required_return - growth_rate)\n    \n    # Return the leading price-to-earnings (P/E) ratio\n    return leading_pe_ratio\n\n# Call the function and print the calculated leading P/E ratio\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-39",
        "question": "What is the present value (PV) of an investment that provides €300 yearly for five years, starting from this very moment, when discounted at an annual rate of 4%?",
        "tables": [],
        "python_solution": "def solution():\n    A = 300\n    r = 0.04\n    N = 5\n    PV = A*((1-(1/((1+r)**N)))/r)*(1+r)\n    return int(PV)",
        "ground_truth": 1388.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cash_flow = 300\n    rate = 0.04\n    periods = 5\n    \n    # Use the annuity present value formula (PV of ordinary annuity + PV of cash flow received immediately)\n    # PV = C * [(1 - (1 + r)^-n) / r] + C\n    # PV of ordinary annuity\n    ordinary_annuity_pv = cash_flow * ((1 - (1 + rate) ** -periods) / rate)\n    # PV of cash flow received immediately\n    immediate_cash_flow_pv = cash_flow  # As it's received immediately, it's not discounted\n    \n    # Sum of ordinary annuity PV and immediate cash flow PV\n    present_value = ordinary_annuity_pv + immediate_cash_flow_pv\n    \n    # return answer\n    return present_value\n```"
        ]
    },
    {
        "question_id": "validation-40",
        "question": "A company recently noted a $15,000 loss from selling equipment used in its production process. If the initial price of the equipment was $100,000 and the accumulated depreciation at the time of sale was $60,000, what sum did the company gain from the sale?",
        "tables": [],
        "python_solution": "def solution():\n    loss = 15000\n    initial_price = 100000\n    accumulated_depreciation = 60000\n    carrying_value = initial_price - accumulated_depreciation\n    proceeds = carrying_value - loss\n    return proceeds",
        "ground_truth": 25000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_cost = 100000\n    accumulated_depreciation = 60000\n    loss_on_sale = 15000\n    \n    # Do math calculation to get the answer\n    # Calculate the book value of the equipment at the time of sale\n    book_value = initial_cost - accumulated_depreciation\n    # Calculate the sale price by adding the loss to the book value\n    sale_price = book_value - loss_on_sale\n    \n    # return answer\n    return sale_price\n    \n# You don't need to edit the code below this line\n# It is used for testing the solution function\nif __name__ == \"__main__\":\n    answer = solution()\n    print(f\"The company gained ${answer} from the sale.\")\n```"
        ]
    },
    {
        "question_id": "validation-41",
        "question": "A business has total liabilities amounting to £35 million and total shareholders' equity of £55 million. What percentage do total liabilities constitute on a vertical common-size balance sheet?",
        "tables": [],
        "python_solution": "def solution():\n    total_liabilities = 35\n    total_equity = 55\n    total_assets = total_liabilities + total_equity\n\n    return (total_liabilities / total_assets) * 100",
        "ground_truth": 38.889,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    total_liabilities = 35e6\n    total_shareholders_equity = 55e6\n    \n    # Calculate the total assets (since total assets = total liabilities + shareholders' equity)\n    total_assets = total_liabilities + total_shareholders_equity\n    \n    # Calculate the percentage of total liabilities in a vertical common-size balance sheet\n    liabilities_percentage = (total_liabilities / total_assets) * 100\n    \n    # return answer\n    return liabilities_percentage\n\n# Call the solution function and print the result\nprint(solution())\n```\nThis program will calculate the percentage of total liabilities compared to the total assets on a vertical common-size balance sheet. It defines the values for total liabilities and total shareholders' equity, calculates the total assets, and then determines what percentage of the total assets is made up by liabilities. Finally, it prints the computed percentage."
        ]
    },
    {
        "question_id": "validation-42",
        "question": "If the Smith company recently paid a dividend of $2, with a required rate of return of 14% per annum and an expected constant growth rate of 8% per year for the dividend, what would the inherent value be for Smith's shares?",
        "tables": [],
        "python_solution": "def solution():\n    D0 = 2\n    g = 0.08\n    r = 0.14\n    D1 = D0 * (1 + g)\n    P0 = D1 / (r - g)\n    return P0",
        "ground_truth": 36.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    dividend = 2  # The dividend that was paid out\n    required_return = 0.14  # The required rate of return as a decimal\n    growth_rate = 0.08  # The expected growth rate as a decimal\n\n    # Use the Gordon growth model to calculate the stock price:\n    # P = D / (r - g) where P is price, D is dividend, r is required return, g is growth rate\n    stock_price = dividend / (required_return - growth_rate)\n    \n    # return answer\n    return stock_price\n\n# You can call the function to see the result:\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-43",
        "question": "Taking into account the details for a conventional fixed-rate bond with no options where PV0 signifies the original bond price, PV+ denotes the bond's price when the yield to maturity is raised, PV_ indicates the new price of the bond when yield to maturity is reduced, ∆Curve shows the modification in the benchmark yield curve, and ∆Yield explains the alteration in the yield to maturity, what can you estimate as the bond's approximate convexity?",
        "tables": [
            "| PV0      | PV+      | PV_      | △Curve | △Yield |\n|----------|----------|----------|--------|--------|\n| 99.41172 | 99.32213 | 99.50132 | 3 bps  | 1bp    |"
        ],
        "python_solution": "def solution():\n    PV_minus = 99.50132\n    PV_plus = 99.32213\n    PV0 = 99.41172\n    delta_yield = 0.0001\n\n    ApproxConvexity = ((PV_minus + PV_plus) - 2 * PV0) / ((delta_yield) ** 2 * PV0)\n    \n    return ApproxConvexity",
        "ground_truth": 10.059,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the bond's approximate convexity, we can use the following formula:\n\nConvexity ≈ (PV_- + PV+ - 2 * PV0) / (2 * PV0 * (∆Yield)^2)\n\nWhere:\n- PV_- is the price of the bond when the yield to maturity is decreased,\n- PV+ is the price of the bond when the yield to maturity is increased,\n- PV0 is the original price of the bond,\n- ∆Yield is the change in yield to maturity in decimal form (1 basis point = 0.01%).\n\nLet's implement the program using the given parameters.\n\n```python\ndef solution():\n    # Define variables name and value\n    PV0 = 99.41172\n    PV_plus = 99.32213\n    PV_minus = 99.50132\n    delta_yield_bps = 1  # Change in yield to maturity in basis points\n    \n    # Do math calculation to get the answer\n    # Convert basis points to decimal form by dividing by 10,000 (since 1% = 100 basis points)\n    delta_yield = delta_yield_bps / 10000\n    \n    convexity_approx = (PV_minus + PV_plus - 2 * PV0) / (2 * PV0 * (delta_yield ** 2))\n    \n    # return answer\n    return convexity_approx\n\n# Call the function and print the result\nprint(solution())\n```\n\nRunning this program will give us the approximate convexity of the bond."
        ]
    },
    {
        "question_id": "validation-44",
        "question": "According to the given table, can you compute the value added from the choice of security?",
        "tables": [
            "|                | Portfolio return | Benchmark return | Portfolio weight | Benchmark weight |\n|----------------|------------------|------------------|------------------|------------------|\n| Domestic       | 25%              | 15%              | 50               | 35               |\n| Bond           | 9%               | 5%               | 30               | 35               |\n| International  | 15%              | 18%              | 20               | 30               |"
        ],
        "python_solution": "def solution():\n    Wp = 1 # Weight of the portfolio\n    Rp = 6.6 # Return of the portfolio\n    RB = 1 # Return of the benchmark\n\n    # Value added from the choice of security\n    security_selection = Wp*(Rp-RB)\n    \n    return security_selection",
        "ground_truth": 5.6,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Here's the Python program to calculate the value added from the choice of security:\n\n```python\ndef solution():\n    # Define variables name and values from the table\n    portfolio_returns = [0.25, 0.09, 0.15]  # Convert percentages to decimals\n    benchmark_returns = [0.15, 0.05, 0.18]\n    portfolio_weights = [0.50, 0.30, 0.20]  # Convert percentages to decimals\n    benchmark_weights = [0.35, 0.35, 0.30]\n    \n    # Initialize the variable to store the value added\n    value_added = 0\n    \n    # Calculate the value added from the choice of security\n    for i in range(len(portfolio_returns)):\n        value_added += (portfolio_returns[i] - benchmark_returns[i]) * portfolio_weights[i]\n    \n    # Return the value added\n    return value_added\n\n# You can call the function and print the result if you want\n# print(solution())\n```\n\nThis program computes the value added by taking the difference between the portfolio returns and the benchmark returns multiplied by the portfolio weights for each category, and then sums them up to get the total value added."
        ]
    },
    {
        "question_id": "validation-45",
        "question": "A dealer has listed a three-month forward exchange rate in CAD/USD at 1.0123. This same dealer also provides a 6.8% quote for 3-month forward points as a percentage. What is the spot rate for CAD/USD?",
        "tables": [],
        "python_solution": "def solution():\n    forward_rate = 1.0123\n    forward_points_as_percentage = 0.068\n\n    spot_rate = forward_rate / (1 + forward_points_as_percentage)\n\n    return spot_rate",
        "ground_truth": 0.948,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    forward_rate = 1.0123\n    forward_points_percent = 6.8 / 100  # Converting percentage to a decimal\n    \n    # Do math calculation to get the answer\n    spot_rate = forward_rate / (1 + forward_points_percent)\n    \n    # return answer\n    return round(spot_rate, 4)  # Assuming rounding to four decimal places as commonly done in forex\n\n# Example usage:\n# print(solution())\n```\nThis program calculates the spot rate for CAD/USD based on the provided three-month forward rate and forward points percentage. It returns the spot rate rounded to four decimal places."
        ]
    },
    {
        "question_id": "validation-46",
        "question": "According to Exhibit 1, what was the share price of Baldwin at the end of 2011?",
        "tables": [
            "|                                         | Year Ending | December 31 |\n|-----------------------------------------|-------------|-------------|\n|                                         | 2011        | 2010        |\n| Rental income                           | 339,009     | 296,777     |\n| Other property income                   | 6,112       | 4,033       |\n| Total income                            | 345,121     | 300,810     |\n| Property operating expenses             | 19,195      | 14,273      |\n| Property taxes                          | 3,610       | 3,327       |\n| Total property expenses                 | 22,805      | 17,600      |\n| Net operating income                    | 322,316     | 283,210     |\n| Other income (gains on sale of properties) | 2,162     | 1,003       |\n| General and administrative expenses     | 21,865      | 19,899      |\n| Depreciation and amortization           | 90,409      | 78,583      |\n| Net interest expenses                   | 70,017      | 56,404      |\n| Net income                              | 142,187     | 129,327     |\n| Weighted average shares outstanding     | 121,944     | 121,863     |\n| Earnings per share                      | 1.17        | 1.06        |\n| Dividend per share                      | 0.93        | 0.85        |\n| Price/FFO, based upon year-end stock price | 11.5x    | 12.7x       |"
        ],
        "python_solution": "def solution():\n    accounting_net_income = 142187\n    depreciation_charges = 90409\n    gains_on_sale = 2162\n    shares_outstanding = 121944\n    price_FFO = 11.5\n    FFO_per_share = (accounting_net_income + depreciation_charges - gains_on_sale) / shares_outstanding\n    share_price = FFO_per_share * price_FFO\n    return share_price",
        "ground_truth": 21.731,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the share price of Baldwin at the end of 2011, we need to refer to the \"Price/FFO, based upon year-end stock price\" figure for 2011 and the \"Earnings per share\" figure. However, since the table only gives us the Price/FFO multiple and the Earnings per share, we cannot calculate the share price without the actual FFO (Funds From Operations) value. The Price/FFO multiple depends on the FFO per share, not the earnings per share (EPS).\n\nHowever, for the purpose of illustrating how you would calculate the share price if the FFO per share figure was available, I'll provide a sample Python function below, where FFO per share will be assumed to be equivalent to the Earnings per share just for the demonstration:\n\n```python\ndef solution():\n    # Define variables name and value\n    price_FFO_multiple_2011 = 11.5\n    earnings_per_share_2011 = 1.17  # Assuming this is FFO per share for demonstration purposes\n    \n    # Calculate the share price using the Price/FFO multiple\n    share_price_2011 = price_FFO_multiple_2011 * earnings_per_share_2011\n    \n    # return answer\n    return share_price_2011\n\n# The following line is just for testing the function\nprint(solution())\n```\n\nPlease note that in a real scenario, the FFO per share figure may differ from the Earnings per share figure. Therefore, the actual share price can only be calculated if the correct FFO per share figure is provided. If FFO per share is different from EPS, you need to replace `earnings_per_share_2011` with the actual `ffo_per_share_2011` in the calculation."
        ]
    },
    {
        "question_id": "validation-47",
        "question": "A researcher is studying a collection composed of 1,000 secondary quality loans and 600 top quality loans. From the secondary quality loans, 200 are delayed in their payments. From the top quality loans, 48 are delayed in their payments. If the researcher arbitrarily picks a loan from the collection and it is presently delayed in its payments, what are the odds that it is a secondary quality loan?",
        "tables": [],
        "python_solution": "def solution():\n    total_loans = 1000 + 600\n    total_late = 200 + 48\n    late_subprime = 200\n\n    probability_late = total_late / total_loans\n    probability_late_and_subprime = late_subprime / total_loans\n    probability_subprime_given_late = probability_late_and_subprime / probability_late\n\n    return probability_subprime_given_late",
        "ground_truth": 0.806,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define the number of each type of loans and the number of delayed payments for each\n    secondary_loans = 1000\n    top_quality_loans = 600\n    delayed_secondary = 200\n    delayed_top_quality = 48\n\n    # Calculate the total number of delayed loans\n    total_delayed = delayed_secondary + delayed_top_quality\n\n    # Calculate the probability of picking a delayed loan that is a secondary quality loan\n    probability_secondary_delayed = delayed_secondary / total_delayed\n    \n    # Return the answer\n    return probability_secondary_delayed\n\n# Example usage:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-48",
        "question": "A researcher is tasked with determining the VaR of a long position in a put option on the shares of Large Pharmaceuticals Corp. The shares are currently priced at USD 26.00, with a daily volatility rate of 1.5%, and the option is at-the-money with a delta of -0.5. What would be the 1-day 95% VaR of the option position, if calculated via the delta-normal method?",
        "tables": [],
        "python_solution": "def solution():\n    delta = -0.5\n    rate = 0.015\n    price = 26\n    U = 1.645\n    sd = abs(delta) * (rate * price)\n    VaR = sd * U\n    return VaR",
        "ground_truth": 0.321,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    current_price = 26.00\n    daily_volatility = 0.015\n    delta = -0.5\n    z_score = norm.ppf(0.95) # Z-score for 95% confidence\n    \n    # Calculate the daily value at risk (VaR)\n    # Since the position is long in the put option, we multiply by delta\n    var = z_score * daily_volatility * current_price * delta\n    \n    # Since VaR is typically expressed as a positive number representing a loss\n    # we take the absolute value\n    answer = abs(var)\n    \n    # return answer\n    return answer\n\n# Call the function and print the result\nprint(f\"The 1-day 95% VaR of the option position is: USD {solution():.2f}\")\n```\n\nKeep in mind that the z-score for a 95% confidence level should give the number of standard deviations away from the mean to capture 95% of all possible outcomes. In the delta-normal method, the option is treated as if it has a linear payoff profile, scaled by its delta. The VaR calculated should represent the potential loss in value for a one-day period at the 95% confidence level."
        ]
    },
    {
        "question_id": "validation-49",
        "question": "Assuming the cash flow from financing activities according to U.S. GAAP is:",
        "tables": [
            "| Net income                                      | $55,000 |\n|-------------------------------------------------|---------|\n| Depreciation                                    | $60,000 |\n| Taxes paid                                      | $25,000 |\n| Interest paid                                   | $5,000  |\n| Dividends paid                                  | $10,000 |\n| Cash received from sale of company building     | $40,000 |\n| Issuance of preferred stock                     | $45,000 |\n| Repurchase of common stock                      | $20,000 |\n| Purchase of machinery                           | $20,000 |\n| Issuance of bonds                               | $40,000 |\n| Debt retired through issuance of common stock   | $45,000 |\n| Paid off long-term bank borrowings              | $10,000 |\n| Profit on sale of building                      | $15,000 |"
        ],
        "python_solution": "def solution():\n    issuance_of_preferred_stock = 45000\n    issuance_of_bonds = 40000\n    principal_payments_on_bank_borrowings = 10000\n    repurchase_of_common_stock = 20000\n    dividends_paid = 10000\n\n    CFF = issuance_of_preferred_stock + issuance_of_bonds - principal_payments_on_bank_borrowings - repurchase_of_common_stock - dividends_paid\n\n    return CFF",
        "ground_truth": 45000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    dividends_paid = 10000\n    issuance_of_preferred_stock = 45000\n    repurchase_of_common_stock = 20000\n    issuance_of_bonds = 40000\n    debt_retired_through_issuance_of_common_stock = 45000\n    paid_off_long_term_bank_borrowings = 10000\n    \n    # Do math calculation to get the answer\n    cash_flow_financing_activities = (issuance_of_preferred_stock + issuance_of_bonds -\n                                      dividends_paid - repurchase_of_common_stock - \n                                      debt_retired_through_issuance_of_common_stock -\n                                      paid_off_long_term_bank_borrowings)\n    \n    # return answer\n    return cash_flow_financing_activities\n\n# Calling the function and printing the result for verification\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-50",
        "question": "What's the price of a bond with a face value of $1000, a coupon rate of 5%, and an annual-pay period of 3 years, assuming the spot rates are 3.6% for the first year, 3.7% for the second year, and 3.8% for the third year?",
        "tables": [],
        "python_solution": "def solution():\n    bond_value = 50 / 1.036 + 50 / (1.037 ** 2) + 1050 / (1.038 ** 3)\n    return bond_value",
        "ground_truth": 1033.61,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the price of the bond, we can discount each of the cash flows (coupon payments and the face value payment at maturity) back to today's value at the respective spot rates for each term. Each cash flow is discounted by the formula:\n\n\\[ PV = \\frac{C}{(1+r)^t} \\]\n\nwhere `PV` is the present value of the cash flow `C`, `r` is the spot rate, and `t` is the number of years until the cash flow occurs.\n\n```python\ndef solution():\n    # Define variables name and value\n    face_value = 1000\n    coupon_rate = 0.05\n    spot_rates = [0.036, 0.037, 0.038]\n    years = len(spot_rates)\n    \n    # Calculate the coupon payment\n    coupon_payment = face_value * coupon_rate\n    \n    # Calculate the present value of the bond (sum of PVs of coupons and face value)\n    bond_price = sum(coupon_payment / (1 + spot_rates[t])**(t+1) for t in range(years))\n    bond_price += face_value / (1 + spot_rates[-1])**years\n    \n    # return answer\n    return bond_price\n\n# This call is for testing the function, you can remove it or ignore it as it's not part of the solution block\nprint(round(solution(), 2))\n```\n\nWhen you call the `solution()` function, it will calculate and return the price of the bond using the given coupon rate and spot rates."
        ]
    },
    {
        "question_id": "validation-51",
        "question": "XYZ NY, a home decor shopping enterprise, provides its employees with a defined benefit pension plan. The related data is as follows: The payment given out during the year is:",
        "tables": [
            "|                                      |        |\n|--------------------------------------|--------|\n| ABC LA retirement plan information 2018 |        |\n| Current service costs                | 470    |\n| Past service costs                   | 0      |\n| Employer contributions               | 1,200  |\n| Benefit obligation at beginning of year | 45,000 |\n| Benefit obligation at end of year      | 48,395 |\n| Plan assets at beginning of year       | 40,800 |\n| Plan assets at end of year             | 44,300 |\n| Actuarial loss                         | 350    |\n| Actual return on plan assets           | 3,100  |\n| Discount rate on plan liabilities      | 7.5%   |\n| Expected rate of return on plan assets | 8.2%   |"
        ],
        "python_solution": "def solution():\n    plan_assets_end = 44300\n    plan_assets_begin = 40800\n    employer_contributions = 1200\n    actual_return_assets = 3100\n    benefit_paid = plan_assets_end - (plan_assets_begin + employer_contributions + actual_return_assets)\n    return benefit_paid",
        "ground_truth": -800.0,
        "topic": "Accounting",
        "output": [
            "It appears that there is information missing from the given scenario. To calculate the payment given out during the year for the XYZ NY defined benefit pension plan, we typically need information such as benefits paid to retirees, or data related to the change in the projected benefit obligation and the fair value of the plan assets. Without such details, we cannot determine the payment given out.\n\nHowever, assuming that the provided information related to ABC LA retirement plan has a similar structure to what is needed for XYZ NY, you might be looking to calculate the benefits paid during the year based on the change in plan assets and other provided data like service cost, contributions, actual return, etc. \n\nIn general, for the ABC LA information, the benefits paid out can be calculated as follows:\n\n```\nBenefits paid = Opening balance of plan assets + Contributions + Actual return - Closing balance of plan assets - Actuarial loss\n```\n\nHowever, this formula might be used only if it's consistent with the assumptions for XYZ NY payment calculations. Also, I'm assuming Actuarial loss needs to be subtracted as it is not an actual cash flow.\n\nLet's prepare the Python program with the provided formula and variables:\n```python\ndef solution():\n    # Define variables name and value according to ABC LA plan as an example\n    employer_contributions = 1200\n    opening_plan_assets = 40800\n    closing_plan_assets = 44300\n    actual_return_on_plan_assets = 3100\n    actuarial_loss = 350\n\n    # Do math calculation to get the answer\n    benefits_paid = (opening_plan_assets + employer_contributions + \n                     actual_return_on_plan_assets - closing_plan_assets - \n                     actuarial_loss)\n    \n    # return answer\n    return benefits_paid\n\n# Call the function and print the result if you want to test it.\nprint(solution())\n```\n\nIf you have the corresponding XYZ NY data, you can replace the variables in the code snippet with the actual data from XYZ NY to calculate the benefits paid out for that specific enterprise.\n\nPlease provide the missing data or clarify the question to receive a precise answer."
        ]
    },
    {
        "question_id": "validation-52",
        "question": "What is the percentage of return that is below $100,000 if an investment analyst detects that the market's fund returns are normally distributed with an average of $160,000 and a standard deviation of $30,000?",
        "tables": [],
        "python_solution": "def solution():\n    from scipy.stats import norm\n    mean = 160000\n    standard_deviation = 30000\n    z = (100000 - mean) / standard_deviation\n    # Return probability in percentage\n    return (1 - norm.cdf(-z))*100",
        "ground_truth": 2.275,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To solve this problem, we can use the cumulative distribution function (CDF) of the normal distribution to find out what percentage of the fund's returns fall below $100,000. Python's `scipy.stats` library has a function called `norm.cdf` that we can use for this purpose.\n\nHere is the Python program to calculate the percentage:\n\n```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    mean = 160000\n    standard_deviation = 30000\n    target_return = 100000\n    \n    # Calculate the cumulative probability for target_return\n    cumulative_probability = norm.cdf(target_return, mean, standard_deviation)\n    \n    # Convert probability to percentage\n    percentage_below_target = cumulative_probability * 100\n    \n    # return answer\n    return percentage_below_target\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nRunning this program will calculate the percentage of market fund returns that are less than $100,000 based on the provided average and standard deviation."
        ]
    },
    {
        "question_id": "validation-53",
        "question": "What is the maximum leverage ratio linked with a position financed by a 65% minimum margin requirement, if the brokerage firm XYZ has set it?",
        "tables": [],
        "python_solution": "def solution():\n    equity = 65\n    position = 100\n    leverage_ratio = position/equity\n    return leverage_ratio",
        "ground_truth": 1.538,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    minimum_margin_requirement = 0.65  # 65%\n\n    # The leverage ratio is the inverse of the margin requirement\n    leverage_ratio = 1 / minimum_margin_requirement\n\n    # return answer\n    return leverage_ratio\n\n# This function will return the maximum leverage ratio\n```"
        ]
    },
    {
        "question_id": "validation-54",
        "question": "During a high season for tourism, the need for bottled water can be depicted as: Qbw=30-2Pb (Qbw is the amount of bottled water; Pb is the price of bottled water). If bottled water costs 5, what will the price elasticity of demand be?",
        "tables": [],
        "python_solution": "def solution():\n    Q = 30 - 2*5\n    P = 5\n    elasticity = -2 * (P/Q)\n    return elasticity",
        "ground_truth": -0.5,
        "topic": "Market Analysis & Economics",
        "output": [
            "To calculate the price elasticity of demand, we use the formula:\n\\[ \\text{Price Elasticity of Demand (PED)} = \\frac{\\% \\text{ change in quantity demanded}}{\\% \\text{ change in price}} \\]\n\nWhen given a linear demand function such as \\( Qbw = 30 - 2Pb \\), we can find the price elasticity of demand using the derivative of the demand function with respect to the price, and then multiplying it by the price-quantity ratio at that point:\n\n\\[ PED = \\left( \\frac{dQbw}{dPb} \\right) \\times \\left( \\frac{Pb}{Qbw} \\right) \\]\n\nThe derivative of \\( Qbw \\) with respect to \\( Pb \\) is the coefficient in front of \\( Pb \\), which is -2 in this case.\n\nGiven that \\( Pb = 5 \\), we can substitute into the demand equation to find \\( Qbw \\):\n\n\\[ Qbw = 30 - 2 \\times 5 \\]\n\nNow we can generate the Python program to calculate the price elasticity of demand:\n\n```python\ndef solution():\n    # Define variables name and value\n    Pb = 5 # Price of bottled water\n    \n    # Calculate quantity of bottled water using the demand function\n    Qbw = 30 - 2 * Pb\n    \n    # Calculate the derivative of Qbw with respect to Pb\n    dQbw_dPb = -2\n    \n    # Calculate the price elasticity of demand\n    PED = (dQbw_dPb) * (Pb / Qbw)\n    \n    # return answer\n    return PED\n\n# Call the function to test\nprint(solution())\n```\n\nThis Python program defines the price of bottled water, calculates the quantity demanded using the demand function, and then calculates the price elasticity of demand using the given formulas. The answer returned will be the price elasticity of demand at the price of 5."
        ]
    },
    {
        "question_id": "validation-55",
        "question": "A business plans to issue new ordinary shares with flotation costs of 5.0% per share. They anticipate a dividend of $0.32 the following year and foresee a dividend growth rate of 10% indefinitely. Assuming the shares are released at a price of $14.69, what is the firm's cost (%) of external equity?",
        "tables": [],
        "python_solution": "def solution():\n    D1 = 0.32\n    P0 = 14.69\n    f = 0.05\n    g = 0.1\n    cost_of_external_equity = ((D1/(P0*(1-f)))+g)*100\n    return cost_of_external_equity",
        "ground_truth": 12.293,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "Here is a program that calculates the firm's cost of external equity based on the given parameters:\n\n```python\ndef solution():\n    # Given variables\n    flotation_costs_percent = 5.0 / 100  # Flotation costs of 5%\n    dividend_next_year = 0.32  # Dividend the following year\n    growth_rate = 10 / 100  # Dividend growth rate of 10%\n    issue_price = 14.69  # Share price\n    \n    # Adjusted price after considering flotation costs\n    net_issue_price = issue_price * (1 - flotation_costs_percent)\n    \n    # Calculate cost of external equity using the dividend discount model (DDM)\n    cost_of_external_equity = (dividend_next_year / net_issue_price) + growth_rate\n    \n    # Convert to percentage\n    cost_of_external_equity_percent = cost_of_external_equity * 100\n    \n    # Return answer\n    return cost_of_external_equity_percent\n\n# Example usage:\n# print(solution())\n```\n\nWhen you call `solution()`, it will return the firm's cost of external equity as a percentage."
        ]
    },
    {
        "question_id": "validation-56",
        "question": "Robinson is considering adding a new ETF investment to the portfolio. He intends to hold the ETF for nine months. Excluding the effect of compounding, what is the anticipated overall holding period cost of the nine-month investment in the ETF, given that the ETF has these trading expenses and management charges: Annual management fee of 0.32%, Round-trip trading fees of 0.20%, and a Bid–offer spread of 0.10% on buy and sell, as Robinson requests Jones to calculate?",
        "tables": [],
        "python_solution": "def solution():\n    annual_management_fee = 0.32\n    round_trip_trading_fees = 0.20\n    bid_offer_spread = 0.10\n    holding_period = 9 / 12\n\n    total_expected_holding_period_cost = (holding_period * annual_management_fee) + round_trip_trading_fees + bid_offer_spread\n    return total_expected_holding_period_cost",
        "ground_truth": 0.54,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    annual_management_fee = 0.32 / 100 # converting percentage to decimal\n    round_trip_trading_fees = 0.20 / 100 # converting percentage to decimal\n    bid_offer_spread = 0.10 / 100 # converting percentage to decimal\n    \n    # ETF holding period is 9 months, therefore, prorate the annual fee for 9 months\n    holding_period_months = 9\n    \n    # Do math calculation to get the answer\n    # Prorate the annual management fee for the 9-month period\n    prorated_management_fee = (annual_management_fee / 12) * holding_period_months\n    \n    # Add round-trip trading fees (since this occurs regardless of holding period)\n    total_trading_fees = round_trip_trading_fees\n    \n    # Add bid-offer spread costs (applied on buy and on sell, thus multiplied by 2)\n    total_bid_offer_spread = 2 * bid_offer_spread\n\n    # Sum all costs to get the total cost\n    overall_holding_period_cost = prorated_management_fee + total_trading_fees + total_bid_offer_spread\n    \n    # return answer\n    return overall_holding_period_cost\n    \n# Calling the function to obtain the result\nprint(solution())\n```\n\nIn the above program, we have defined the fees and spreads as percentages and converted them to decimals for calculation. We have prorated the management fee for the 9-month holding period. We have added the one-time round-trip trading fees and accounted for the bid-offer spread which applies on both buying and selling by multiplying it by 2. The sum of these expenses gives us the overall holding period cost of the investment."
        ]
    },
    {
        "question_id": "validation-57",
        "question": "An investment firm implements a \"2 and 20\" fee arrangement, the current value of assets is $515, the management fee is determined by the value of assets at end of the year, a 5% hurdle rate is established prior to the collection of the incentive fee, and the present high-water mark is $540. After a period of one year, the value of the investment firm is $602.5. What is the investor's net return?",
        "tables": [],
        "python_solution": "def solution():\n    AUM_end_of_year = 602.5\n    high_water_mark = 540\n    management_fee_rate = 0.02\n    previous_assets_value = 515\n    incentive_fee_rate = 0.2\n    hurdle_rate = 0.05\n    \n    management_fee = AUM_end_of_year * management_fee_rate\n    incentive_fee = (AUM_end_of_year - high_water_mark * (1 + hurdle_rate)) * incentive_fee_rate\n    total_fee = management_fee + incentive_fee\n    net_return = (AUM_end_of_year - total_fee) / previous_assets_value - 1\n    return net_return * 100  # it's usually more intuitive to express return rate in percentage.",
        "ground_truth": 13.272,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_value = 515  # initial value of assets\n    end_value = 602.5  # value of assets at the end of the year\n    high_water_mark = 540  # high-water mark\n    hurdle_rate = 0.05  # 5% hurdle rate\n    management_fee_rate = 0.02  # 2% management fee\n    incentive_fee_rate = 0.20  # 20% incentive fee\n\n    # Calculate management fee\n    management_fee = end_value * management_fee_rate\n\n    # Calculate incentive fee\n    incentive_fee = 0  # default to 0 if no incentive fee applies\n    if end_value > high_water_mark:\n        profit = end_value - high_water_mark\n        if profit > (high_water_mark * hurdle_rate):\n            incentive_fee = (profit - (high_water_mark * hurdle_rate)) * incentive_fee_rate\n\n    # Total fees\n    total_fees = management_fee + incentive_fee\n\n    # Calculate net return\n    net_return = end_value - initial_value - total_fees\n    \n    # return net_return\n    return net_return\n    \n# Call the function and print the result\nprint(solution())\n```\n\nWhen you run the python function `solution()`, it will output the net return for the investor after accounting for the management fee and any applicable incentive fee."
        ]
    },
    {
        "question_id": "validation-58",
        "question": "Assuming the application of U.S. GAAP unless specified differently, an analyst collected data from a corporation as follows: The bonds were released at par value and are convertible into 300,000 ordinary shares. All securities have been in circulation for the complete year. What is the diluted earnings per share for this corporation?",
        "tables": [
            "| Shares of common stock | 1,000,000 |\n|:----------------------:|:---------:|\n| Net income for the year | $1,500,000 |\n| Par value of convertible bonds with a 4% coupon rate | $10,000,000 |\n| Par value of cumulative preferred stock with a 7% dividend rate | $2,000,000 |\n| Tax rate | 30% |"
        ],
        "python_solution": "def solution():\n    # given data\n    net_income = 1500000\n    preferred_stock_dividends = 140000\n    outstanding_shares = 1000000\n    bond_interest = 400000\n    bond_conversion_shares = 300000\n\n    # calculate amount available for common shareholders\n    amount_for_common_shareholders = net_income - preferred_stock_dividends\n\n    # calculate the interest add back to net income\n    add_back_to_income = bond_interest * 0.7  # tax rate is 30%, hence considering 70%\n\n    # calculate diluted earnings\n    diluted_earnings = amount_for_common_shareholders + add_back_to_income\n\n    # calculate diluted EPS\n    diluted_eps = diluted_earnings / (outstanding_shares + bond_conversion_shares)\n\n    return diluted_eps",
        "ground_truth": 1.262,
        "topic": "Accounting",
        "output": [
            "To calculate the diluted earnings per share (EPS), we need to adjust the net income for the interest on convertible bonds (after tax) and calculate the new number of shares outstanding if the bonds were converted into common stock.\n\nHere's the Python program that performs these calculations:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_income = 1500000\n    par_value_bonds = 10000000\n    coupon_rate = 0.04\n    tax_rate = 0.30\n    shares_of_common_stock = 1000000\n    shares_convertible_from_bonds = 300000\n\n    # Calculate the interest on convertible bonds (after tax)\n    interest_on_bonds = par_value_bonds * coupon_rate\n    after_tax_savings = interest_on_bonds * (1 - tax_rate)\n    \n    # Adjust net income for after tax savings on the convertible bonds\n    adjusted_net_income = net_income + after_tax_savings\n    \n    # Calculate new number of shares if the bonds were converted\n    new_shares_outstanding = shares_of_common_stock + shares_convertible_from_bonds\n    \n    # Calculate diluted EPS\n    diluted_eps = adjusted_net_income / new_shares_outstanding\n    \n    # return answer\n    return diluted_eps\n\n# Call the function and print the result\nprint(solution())\n```\n\nRun this program to get the diluted EPS for the corporation. Remember that if there was any other potential dilutive securities such as options or warrants, those would have to be included in the calculation of diluted EPS as well, but in this given scenario, it's not mentioned, so we will not include them in our calculation."
        ]
    },
    {
        "question_id": "validation-59",
        "question": "A year-long investment of 10,000 ordinary stocks from a corporation yielded a return of 15.5%. Just before selling the stocks at $24 each, the investor obtained a dividend of $2,500. What was the cost per stock that the investor initially paid a year ago?",
        "tables": [],
        "python_solution": "def solution():\n    initial_investment = 10000\n    return_rate = 15.5/100\n    stock_price_per_share = 24\n    dividend = 2500\n    \n    total_investment = initial_investment * (1 + return_rate)\n\n    total_earnings = (stock_price_per_share * initial_investment) + dividend\n\n    initial_price_per_share = total_earnings / total_investment\n    \n    return initial_price_per_share",
        "ground_truth": 20.996,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Given values\n    total_dividend = 2500       # The total dividend received by the investor\n    selling_price_per_stock = 24 # The selling price per stock\n    total_stocks = 10000        # The total number of stocks\n    return_percentage = 15.5    # The return percentage\n\n    # Total amount received from selling the stocks\n    total_selling_amount = selling_price_per_stock * total_stocks\n\n    # Total return including the dividends\n    total_return_including_dividends = total_selling_amount + total_dividend\n\n    # Total return in percentage terms\n    total_return_in_money = (total_return_including_dividends \n                             - (total_return_including_dividends / (1 + return_percentage / 100)))\n\n    # Initial cost of the investment\n    initial_cost = total_return_including_dividends - total_return_in_money\n\n    # Cost per stock\n    cost_per_stock = initial_cost / total_stocks\n\n    # return cost_per_stock\n    return round(cost_per_stock, 2)  # Rounding the result to 2 decimal places for currency format\n\n# Calling the function to get the result\nprint(solution())\n```\n\nThis program will calculate the initial cost per stock that the investor paid a year ago based on the given dividends, selling price per stock, total stocks, and the return percentage."
        ]
    },
    {
        "question_id": "validation-60",
        "question": "Smith demonstrates to Harmonica the total return of a recent transaction performed by the Zenith Fund. Smith explains that the Zenith Fund entered a fully collateralized long position in nearby soybean futures contracts at the quoted futures price of 865.0 (US cents/bushel). Three months afterward, the whole futures position was rolled when the short-term futures price was 877.0 and the long-term futures price was 883.0. What is the Zenith Fund’s three-month total return on the soybean futures transaction, factoring in that the collateral earned an annualized rate of 0.60% during the three-month period between when the initial long position was established and the rolling of the contract?",
        "tables": [],
        "python_solution": "def solution():\n    previous_price = 865.0\n    current_price_short_term = 877.0\n    current_price_long_term = 883.0\n    collateral_rate = 0.60\n    months = 3\n    \n    # Calculating each return\n    price_return = (current_price_short_term - previous_price) / previous_price\n    roll_return = (current_price_short_term - current_price_long_term) / current_price_short_term\n    collateral_return = (months/12) * (collateral_rate/100)\n    \n    # Calculating total return\n    total_return = price_return + roll_return + collateral_return\n    \n    return total_return * 100",
        "ground_truth": 0.853,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_futures_price = 865.0  # initial futures price in US cents/bushel\n    roll_futures_price = 877.0  # futures price at roll in US cents/bushel\n    long_term_futures_price = 883.0  # not required for this calculation\n    annualized_collateral_rate = 0.006  # annualized rate earned by collateral\n    months = 3  # three-month period\n    \n    # Do math calculation to get the price return and collateral return\n    price_return = (roll_futures_price - initial_futures_price) / initial_futures_price\n    \n    # Convert annualized collateral rate to the three-month period equivalent\n    period_collateral_rate = annualized_collateral_rate * (months / 12.0)\n    \n    # Compute total return by summing price return and collateral return\n    total_return = price_return + period_collateral_rate\n    \n    # return answer\n    return total_return\n```"
        ]
    },
    {
        "question_id": "validation-61",
        "question": "If an evaluator gathers the following DCF specifications to estimate the worth of a real estate with constant rate of increase in income and value through DCF technique: The initial capitalization rate is 5.5%, the ending capitalization rate is 6%, and the discount rate is 7.25%. What is the growth rate of the property in question?",
        "tables": [],
        "python_solution": "def solution():\n    discount_rate = 7.25\n    capitalization_rate = 5.5\n    \n    growth_rate = discount_rate - capitalization_rate\n    return growth_rate",
        "ground_truth": 1.75,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To find the growth rate of the property in question using the given DCF specifications (Discounted Cash Flow), we'll use the Gordon Growth Model because we are given a constant growth rate and the model assumes constant growth.\n\nThe formula for the Gordon Growth Model, which relates the price of the property (P0), the next period's net operating income (NOI1), the capitalization rate (Cap rate), and the growth rate (g), is:\n\n**NOI1 = NOI0 * (1 + g)**\n\nWhere:\n- NOI1 is the net operating income for the next period.\n- NOI0 is the current net operating income.\n- g is the growth rate we want to find.\n\nFor the valuation model, we also use the relationship between the price at the beginning (P0) and the price at the end (Pn) taking into account the growth. Assuming the property grows at a rate \"g\", the price would be:\n\n**Pn = P0 * (1 + g)^n**\n\nThe relationship between the initial capitalization rate (Cap Rate0), the ending capitalization rate (Cap RateN), discount rate, and growth rate is given by the following formula:\n\n**Cap RateN = Discount Rate - Growth Rate**\n\nSo we need to solve the above equation to find the growth rate \"g\". We can rearrange it to:\n\n**Growth Rate = Discount Rate - Cap RateN**\n\nLet's do the calculation in Python:\n\n```python\ndef solution():\n    # Define variables name and value\n    discount_rate = 0.0725\n    ending_cap_rate = 0.06\n\n    # Calculate the growth rate\n    growth_rate = discount_rate - ending_cap_rate\n    \n    # Return the growth rate\n    return growth_rate\n\n# Call the function and print the result\nprint(solution())\n```\n\nExecuting this function should give us the growth rate of the property. Let's run it and see what the result is."
        ]
    },
    {
        "question_id": "validation-62",
        "question": "Utilizing the units-of-production approach, what would be the depreciation expense in the initial year for a machine purchased in Jan. 2015, as per the corresponding data provided?",
        "tables": [
            "|                           |                  |\n|---------------------------|------------------|\n|Cost of the equipment      |$5,000,000        |\n|Estimated residual value   |$500,000          |\n|Expected useful life       |9 years           |\n|Total productive capacity  |950,000 units     |\n|Production in FY2015       |150,000 units     |\n|Expected production for the next 8 years |100,000 units each year|"
        ],
        "python_solution": "def solution():\n    purchase_price = 5000000\n    salvage_value = 500000\n    total_units = 950000\n    units_produced = 150000\n\n    depreciation_expense = (purchase_price - salvage_value) * (units_produced / total_units)\n    return depreciation_expense",
        "ground_truth": 710526.316,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cost_of_equipment = 5000000\n    estimated_residual_value = 500000\n    total_productive_capacity = 950000\n    production_in_FY2015 = 150000\n    \n    # Do math calculation to get the answer\n    # Calculate depreciation rate per unit\n    depreciation_per_unit = (cost_of_equipment - estimated_residual_value) / total_productive_capacity\n    \n    # Calculate depreciation expense for the first year\n    depreciation_expense_FY2015 = depreciation_per_unit * production_in_FY2015\n    \n    # return answer\n    return depreciation_expense_FY2015\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-63",
        "question": "A specialist compiled the financial information for a Real Estate Investment Trust. Using the income statement, what was the Real Estate Investment Trust's share price at the end of 2017 according to the Price / FFO multiple?",
        "tables": [
            "| Income Statement (in US$ million, except per share data) | 2017 Year End |\n|-----------------------------------------------------|-------------|\n| Total rental income                                 | 450         |\n| Total property expenses                             | 228         |\n| Net operating income                                | 222         |\n| Other expenses (losses on sale of properties)       | 22          |\n| General and administrative expenses                 | 28          |\n| Depreciation and amortization                       | 45          |\n| Net interest expenses                               | 35          |\n| Net income                                          | 92          |\n| Weighted average shares outstanding (million)       | 118         |\n| Earnings per share                                  | 0.78        |\n| Price/FFO, based upon year-end stock price          | 13x         |"
        ],
        "python_solution": "def solution():\n    multiple = 13\n    net_income = 92\n    depreciation_and_amortization = 45\n    loss_from_property_disposal = 22\n    shares_outstanding = 118\n    FFO = net_income + depreciation_and_amortization + loss_from_property_disposal\n    FFO_per_share = FFO / shares_outstanding\n    stock_price = multiple * FFO_per_share\n    return stock_price",
        "ground_truth": 17.517,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the share price at the end of 2017 based on the Price/FFO (Funds From Operations) multiple, we need to first determine the FFO. FFO is a measure common in the analysis of real estate investment trusts (REITs). It commences with net income, then adds back items such as depreciation and amortization, as these are not cash expenses and can reduce the net income reported by REITs and gives a distorted picture of the REIT's actual performance. \n\nThe formula for FFO is:\nFFO = Net Income + Depreciation + Amortization - Gains on Sales of Property\n\nThen we will determine the FFO per share:\nFFO per Share = FFO / Weighted Average Shares Outstanding\n\nAnd finally, we can calculate the share price using the Price/FFO multiple:\nShare Price at Year-End = FFO per Share * Price/FFO Multiple\n\nHere is a Python program to perform these calculations:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_income = 92  # in US$ million\n    depreciation_and_amortization = 45  # in US$ million\n    losses_on_sale_of_properties = 22  # in US$ million\n    weighted_average_shares_outstanding = 118  # in million\n    price_ffo_multiple = 13  # Price/FFO multiple\n    \n    # Calculate the FFO\n    ffo = net_income + depreciation_and_amortization + losses_on_sale_of_properties\n    \n    # Calculate FFO per share\n    ffo_per_share = ffo / weighted_average_shares_outstanding\n    \n    # Calculate Share Price at Year-End\n    share_price_at_year_end = ffo_per_share * price_ffo_multiple\n    \n    # return answer\n    return share_price_at_year_end\n\n# Uncomment the line below to run the function and get the result\n# print(solution())\n```\n\nOnce you run this program, it will return the share price at the end of 2017 for this Real Estate Investment Trust using the given financial information."
        ]
    },
    {
        "question_id": "validation-64",
        "question": "Omega Petroleum Corp. is a monopolistic entity experiencing extremely high entry barriers. Its marginal cost is $40 and its average cost is $70. After recent market research, the price elasticity of demand was discovered to be 1.5. What price is the corporation likely to set?",
        "tables": [],
        "python_solution": "def solution():\n    MC = 40\n    ED = 1.5\n    P = MC / (1 - 1/ED)\n    return P",
        "ground_truth": 120.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "Given the following details:\n- Marginal Cost (MC) = $40\n- Average Cost (AC) = $70\n- Price Elasticity of Demand (ED) = 1.5\n\nWe will use the formula for a monopolistic firm's optimal pricing based on elasticity:\n\\[ Price (P) = \\frac{{ED}}{{ED - 1}} \\times MC \\]\n\nHere’s how you can write the program to calculate the price:\n```python\ndef solution():\n    # Define variables name and value\n    marginal_cost = 40\n    elasticity_demand = 1.5\n    \n    # Do math calculation to get the answer\n    price = (elasticity_demand / (elasticity_demand - 1)) * marginal_cost\n    \n    # return answer\n    return price\n\n# Use the function\nprint(solution())\n```\n\nWhen we run this program, it will calculate the price that Omega Petroleum Corp. is likely to set."
        ]
    },
    {
        "question_id": "validation-65",
        "question": "A two-year floating-rate bond pays 6-month LPR plus 80 basis points. The bond is valued at 97 for every 100 of face value. The present 6-month LPR is 1.00%. Presume a 30/360 day count standard and equally divided periods. What is the discount margin for the bond in basis points (bps)?",
        "tables": [],
        "python_solution": "def solution():\n    PV = 97\n    Index = 0.01\n    QM = 0.0080\n    FV = 100\n    m = 2\n    r = 0.0168\n    DM = (r * 2 - Index)\n    return DM * 10000",
        "ground_truth": 236.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    bond_price = 97\n    face_value = 100\n    floating_rate = 1.00\n    spread = 0.80\n    periods_per_year = 2  # 6-month periods in a year\n    years_to_maturity = 2\n    total_periods = periods_per_year * years_to_maturity\n\n    # Initial guess for yield (effective semi-annual rate)\n    yield_guess = (floating_rate + spread) / periods_per_year\n    price_guess = 0\n    increment = 0.1\n\n    # Iteratively calculate the bond price with different yields until the calculated price matches the bond price\n    while abs(price_guess - bond_price) > 0.0001:\n        price_guess = 0\n\n        for i in range(1, total_periods + 1):\n            # Calculate the payment for each period\n            cash_flow = face_value * (floating_rate + spread + yield_guess) / 100 / periods_per_year\n            # If it's the last period, add the face value to the payment\n            if i == total_periods:\n                cash_flow += face_value\n\n            # Calculate the present value of the payment\n            price_guess += cash_flow / ((1 + yield_guess) ** i)\n\n        # Adjust the yield guess based on whether the calculated price is too high or too low\n        if price_guess < bond_price:\n            yield_guess += increment\n        else:\n            yield_guess -= increment\n            increment /= 10  # Lower the increment to fine-tune the guess\n\n    # Once the loop is near convergence, the yield guess is approximately equal to the discount margin\n    discount_margin = (yield_guess * periods_per_year - floating_rate) * 100  # Convert to basis points\n\n    # return answer\n    return round(discount_margin, 1)  # Return the result rounded to one decimal place\n\n# print the solution\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-66",
        "question": "According to previous studies, Smith has chosen the following independent variables to forecast the initial returns of an IPO: Underwriter rank = 1–10, with 10 being the highest rank; Pre-offer price adjustment (Represented as a decimal) = (Offer price – Initial filing price)/Initial filing price; Offer size ($ millions) = Shares sold x Offer price; Fraction retained (Represented as a decimal) = Portion of total company shares kept by insiders Smith's Regression Results Dependent Variable: IPO Initial Return (Represented in Decimal Form, i.e., 1% = 0.01) The forthcoming IPO has these characteristics: underwriter rank = 6; pre-offer price adjustment = 0.04; offer size = $40 million; fraction retained = 0.70. Based on Smith’s regression analysis, what is the anticipated initial return for the forthcoming IPO?",
        "tables": [
            "| Variable           | Coefficient (bj) | Standard Error | t-Statistic |\n|--------------------|------------------|----------------|-------------|\n| Intercept          | 0.0477           | 0.0019         | 25.11       |\n| Underwriter rank   | 0.0150           | 0.0049         | 3.06        |\n| Pre-offer          | 0.4350           | 0.0202         | 21.53       |\n| price adjustment   |                  |                |             |\n| Offer size         | -0.0009          | 0.0011         | -0.82       |\n| Fraction retained  | 0.0500           | 0.0260         | 1.92        |"
        ],
        "python_solution": "def solution():\n    underwriter_rank = 6\n    pre_offer_price_adjustment = 0.04\n    offer_size = 40 \n    fraction_retained = 0.70\n\n    IR = 0.0477 + (0.0150 * underwriter_rank) + (0.435 * pre_offer_price_adjustment) - (0.0009 * offer_size) + (0.05 * fraction_retained)\n    return IR",
        "ground_truth": 0.154,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Below is the Python program that calculates the anticipated initial return for the forthcoming IPO based on the provided regression results and the characteristics of the IPO.\n\n```python\ndef solution():\n    # Define coefficients\n    coef_intercept = 0.0477\n    coef_underwriter_rank = 0.0150\n    coef_pre_offer = 0.4350\n    coef_offer_size = -0.0009\n    coef_fraction_retained = 0.0500\n    \n    # IPO characteristics\n    underwriter_rank = 6\n    pre_offer_price_adjustment = 0.04\n    offer_size = 40  # in $ millions\n    fraction_retained = 0.70\n    \n    # Calculate the anticipated initial return\n    initial_return = (\n        coef_intercept +\n        (coef_underwriter_rank * underwriter_rank) +\n        (coef_pre_offer * pre_offer_price_adjustment) +\n        (coef_offer_size * offer_size) +\n        (coef_fraction_retained * fraction_retained)\n    )\n    \n    # return answer\n    return initial_return\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThis program takes the values of the coefficients for the regression, the characteristics of the IPO, performs the linear regression calculation, and returns the anticipated initial return."
        ]
    },
    {
        "question_id": "validation-67",
        "question": "Without accounting for the compound effects, what is the projected total cost for the holding period when investing in the ETF for nine months, given that the ETF has these trading costs and management fees: an annual management fee of 0.40%, round-trip trading commissions of 0.55%, and a bid-offer spread of 0.20% on buying and selling?",
        "tables": [],
        "python_solution": "def solution():\n    annual_management_fee = 0.40\n    round_trip_commission = 0.55\n    bid_offer_spread = 0.20\n    holding_period = 9 / 12\n    total_cost_percentage = (holding_period * annual_management_fee) + round_trip_commission + bid_offer_spread\n    return total_cost_percentage",
        "ground_truth": 1.05,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    holding_period_years = 9 / 12  # convert months to years\n    annual_management_fee_rate = 0.004  # annual management fee of 0.40%\n    round_trip_commission_rate = 0.0055  # round-trip trading commissions of 0.55%\n    bid_offer_spread_rate = 0.002  # bid-offer spread of 0.20%\n    \n    # Since we are not accounting for the compound effects, we just multiply fees by the holding period in terms of years\n    # Assuming the round-trip commission and the bid-offer spread occur only once each during the holding period\n    total_management_fee = annual_management_fee_rate * holding_period_years\n    total_trading_costs = round_trip_commission_rate + bid_offer_spread_rate\n    \n    # Do math calculation to get the answer\n    total_cost = total_management_fee + total_trading_costs\n    \n    # return total cost presuming initial investment amount of 1 (as percentage of the ETF investment)\n    return total_cost\n\n# Call the function and print the result\nprint(f\"Total Cost (as a percentage of investment): {solution() * 100}%\")\n```\n\nThis Python function `solution` calculates the total cost as a percentage of the investment in an ETF for a nine-month holding period without accounting for compound effects. The costs include an annual management fee, round-trip trading commissions, and a bid-offer spread. The result should be the projected total cost in terms of percentage. The final print statement provides a human-readable format of the result by multiplying by 100 to convert it from a decimal to a percentage form."
        ]
    },
    {
        "question_id": "validation-68",
        "question": "What is the holding period return for the three-year timeframe, given the following annual rates of return for a mutual fund as reported by a researcher?",
        "tables": [
            "| Year | Return(%) |\n|------|-----------|\n| 2008 | 14        |\n| 2009 | -10       |\n| 2010 | -2        |"
        ],
        "python_solution": "def solution():\n    return (1+0.14)*(1-0.10)*(1-0.02)-1",
        "ground_truth": 0.005,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    return_2008 = 0.14\n    return_2009 = -0.10\n    return_2010 = -0.02\n    \n    # The holding period return for multiple periods is calculated by\n    # multiplying the returns for each period and subtracting 1.\n    # (1 + r1) * (1 + r2) * ... * (1 + rn) - 1\n    \n    # Do math calculation to get the answer\n    holding_period_return = (1 + return_2008) * (1 + return_2009) * (1 + return_2010) - 1\n    \n    # Convert to a percentage by multiplying by 100\n    holding_period_return_percent = holding_period_return * 100\n    \n    # return answer\n    return holding_period_return_percent\n\n# you can test the function with the following print statement\n# print(solution())\n```\n\nThis solution formula calculates the total return over the three-year period taking compounding into account."
        ]
    },
    {
        "question_id": "validation-69",
        "question": "What is the gross domestic product for country B in 2015, according to the provided data?",
        "tables": [
            "| Account Item | Amount($ trillions) |\n|---------------|---------------------|\n| Consumption | 20.0 |\n| Capital consumption allowance | 1.9 |\n| Government spending | 4.2 |\n| Imports | 2.2 |\n| Gross private domestic investment | 6.0 |\n| Exports | 1.8 |"
        ],
        "python_solution": "def solution():\n    Consumption = 20\n    Gross_private_domestic_investment = 6\n    Government_Spending = 4.2\n    Exports = 1.8\n    Imports = 2.2\n    GDP = Consumption + Gross_private_domestic_investment + Government_Spending + Exports - Imports\n    return GDP",
        "ground_truth": 29.8,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    consumption = 20.0\n    capital_consumption_allowance = 1.9\n    government_spending = 4.2\n    imports = 2.2\n    gross_private_domestic_investment = 6.0\n    exports = 1.8\n    \n    # GDP calculation using the expenditure approach\n    gdp = (consumption + \n           gross_private_domestic_investment + \n           government_spending + \n           (exports - imports) + \n           capital_consumption_allowance)\n    \n    # return answer\n    return gdp\n\n# Call the solution function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-70",
        "question": "A portfolio consisting of two shares has the following properties: What is the standard deviation of the returns from this portfolio?",
        "tables": [
            "|                   | Stock 1 | Stock 2 |\n|-------------------|---------|---------|\n| Expected return   | 7%      | 10%     |\n| Standard deviation| 12%     | 25%     |\n| Portfolio weights | 0.30    | 0.70    |\n| Correlation       | 0.20    | 0.20    |"
        ],
        "python_solution": "def solution():\n    # weights \n    w1 = 0.3\n    w2 = 0.7\n\n    # standard deviations \n    sigma1 = 12\n    sigma2 = 25\n\n    # correlation coefficient \n    rho = 0.2\n\n    # covariance \n    Cov = rho * sigma1 * sigma2\n    \n    # portfolio variance \n    variance = (w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2*w1*w2*Cov)\n    \n    # portfolio standard deviation \n    std_dev = variance**0.5\n\n    # converting back to percentage \n    std_dev_percent = std_dev / 100.0\n    \n    return std_dev_percent",
        "ground_truth": 0.186,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight1 = 0.30\n    weight2 = 0.70\n    std_dev1 = 0.12\n    std_dev2 = 0.25\n    correlation = 0.20\n    \n    # Calculate the portfolio variance\n    portfolio_variance = (weight1 * std_dev1) ** 2 + (weight2 * std_dev2) ** 2 + 2 * weight1 * weight2 * correlation * std_dev1 * std_dev2\n    \n    # Calculate the portfolio standard deviation\n    portfolio_std_dev = math.sqrt(portfolio_variance)\n    \n    # return answer\n    return portfolio_std_dev\n\n# Example usage:\n# portfolio_std_dev = solution()\n# print(\"The standard deviation of the portfolio returns is:\", portfolio_std_dev)\n```"
        ]
    },
    {
        "question_id": "validation-71",
        "question": "The Senior VP of RN fund requests Samuel to estimate the value of intangibles for XYZ Corp. Samuel observes that XYZ Corp's intangibles primarily comprise patents and other intangible assets. Consequently, Samuel forecasts the following data for the next year. Applying the excess earnings method, what is the value of the intangibles?",
        "tables": [
            "| TMT Intangibles Valuation Data | |\n| --- | --- |\n| Working capital balance | $ 22,000,000 |\n| Fair value of fixed assets | $ 57,000,000 |\n| Normalized income to the company | $89,000,000 |\n| Required return on working capital | 6% |\n| Required return on fixed assets | 9% |\n| Required return on intangible assets | 25% |\n| Future growth rate | 7% |"
        ],
        "python_solution": "def solution():\n    working_capital_return = 0.06*22000000\n    fixed_assets_return = 0.09*57000000\n    intangible_assets_return = 89000000 - working_capital_return - fixed_assets_return\n    intangible_assets_value = intangible_assets_return / (0.25 - 0.07)\n    return intangible_assets_value/1000000",
        "ground_truth": 458.611,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables from the provided data\n    working_capital_balance = 22000000\n    fair_value_fixed_assets = 57000000\n    normalized_income_company = 89000000\n    required_return_working_capital = 0.06\n    required_return_fixed_assets = 0.09\n    required_return_intangible_assets = 0.25\n    future_growth_rate = 0.07\n    \n    # Calculate the earnings attributable to working capital and fixed assets\n    earnings_working_capital = working_capital_balance * required_return_working_capital\n    earnings_fixed_assets = fair_value_fixed_assets * required_return_fixed_assets\n    \n    # Calculate the excess earnings\n    excess_earnings = normalized_income_company - (earnings_working_capital + earnings_fixed_assets)\n    \n    # Calculate the value of intangibles using the excess earnings method\n    value_of_intangibles = excess_earnings / (required_return_intangible_assets - future_growth_rate)\n    \n    # Return answer\n    return value_of_intangibles\n\n# Call the function to ensure it runs without errors\nprint(solution())\n```\n\nThe given `solution` function calculates the value of intangible assets using the excess earnings method. This method calculates the earnings that exceed the required return on tangible assets (working capital and fixed assets). The intangible assets value is then found by capitalizing these excess earnings by the difference between the required return on intangible assets and the future growth rate."
        ]
    },
    {
        "question_id": "validation-72",
        "question": "Considering the provided financial statement information, can you determine the cash conversion cycle (net operating cycle) for this particular business? What is the cash conversion cycle (net operating cycle) of this specific business?",
        "tables": [
            "|                                            | In Millions ($) |\n|--------------------------------------------|----------------:|\n| Credit sales                               |          40,000 |\n| Cost of goods sold                         |          30,000 |\n| Accounts receivable                        |           3,000 |\n| Inventory-Beginning balance                |           1,500 |\n| Inventory- Ending balance                  |           2,000 |\n| Accounts payable                           |           4,000 |"
        ],
        "python_solution": "def solution():\n    inventory_days = ((2000 + 1500)/2)/(30000/365)\n    receivables_days = 3000/(40000/365)\n    operating_cycle = inventory_days + receivables_days\n    purchases = 30000 + 2000 - 1500\n    payables_days = 4000/(purchases/365)\n    net_operating_cycle = operating_cycle - payables_days\n    return net_operating_cycle",
        "ground_truth": 0.798,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "To calculate the cash conversion cycle (CCC), we need to determine three components: Days Sales Outstanding (DSO), Days Inventory Outstanding (DIO), and Days Payable Outstanding (DPO). \n\nThe CCC is calculated as follows:\nCCC = DSO + DIO - DPO\n\nWhere:\n- DSO (Days Sales Outstanding) = (Average Accounts Receivable / Credit Sales) * 365\n- DIO (Days Inventory Outstanding) = (Average Inventory / Cost of Goods Sold) * 365\n- DPO (Days Payable Outstanding) = (Average Accounts Payable / Cost of Goods Sold) * 365\n\nTo calculate average inventory and average accounts receivable, we will use the following:\n- Average Inventory = (Inventory-Beginning balance + Inventory-Ending balance) / 2\n- Average Accounts Receivable = Accounts receivable (as no beginning balance is given)\n\nNow we'll use these formulas to calculate the CCC based on the information provided.\n\n```python\ndef solution():\n    # Define variables name and value\n    credit_sales = 40000\n    cost_of_goods_sold = 30000\n    accounts_receivable = 3000\n    inventory_beginning = 1500\n    inventory_ending = 2000\n    accounts_payable = 4000\n    \n    # Calculate averages\n    average_inventory = (inventory_beginning + inventory_ending) / 2\n    \n    # Calculate components of the cash conversion cycle\n    days_sales_outstanding = (accounts_receivable / credit_sales) * 365\n    days_inventory_outstanding = (average_inventory / cost_of_goods_sold) * 365\n    days_payable_outstanding = (accounts_payable / cost_of_goods_sold) * 365\n    \n    # Calculate cash conversion cycle\n    cash_conversion_cycle = days_sales_outstanding + days_inventory_outstanding - days_payable_outstanding\n    \n    # return answer\n    return cash_conversion_cycle\n\n# Call the function and print the result\nprint(f\"The Cash Conversion Cycle is: {solution()} days\")\n```\n\nRun the program, and it will calculate the Cash Conversion Cycle for the business based on the financial statement information provided."
        ]
    },
    {
        "question_id": "validation-73",
        "question": "In 2013, the U.S.-based tech firm Johnson Enterprises, adhering to U.S. GAAP, invested $5 million in research and $3 million in the creation of a financial software. The company aimed to possess the software copyright for 20 years, with a salvage value of $10,000. What would be the book value of the software copyright at the close of 2014?",
        "tables": [],
        "python_solution": "def solution():\n    research_cost = 5e6\n    development_cost = 3e6\n    total_cost = research_cost + development_cost\n    book_value = total_cost - total_cost\n    return book_value",
        "ground_truth": 0.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_investment = 3000000 # Amount spent on creating financial software\n    useful_life = 20 # Useful life in years\n    salvage_value = 10000 # Salvage value\n    years_elapsed = 2 # By the end of 2014, two years have passed since the investment\n\n    # Do math calculation to get the answer\n    # Calculate annual depreciation expense\n    annual_depreciation = (initial_investment - salvage_value) / useful_life\n    # Calculate the book value at the end of 2014\n    book_value_end_of_2014 = initial_investment - (annual_depreciation * years_elapsed)\n\n    # return answer\n    return book_value_end_of_2014\n\n# To get the exact book value, we can simply call the function\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-74",
        "question": "For a discrete uniform distribution with outcomes for M as: [7, 8, 9, 10], what is the variance of this distribution?",
        "tables": [],
        "python_solution": "def solution():\n    M = [7, 8, 9, 10]\n    expected_value = sum(M) / len(M)\n    variance = sum((x - expected_value) ** 2 for x in M) / len(M)\n    return variance",
        "ground_truth": 1.25,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    outcomes = [7, 8, 9, 10]\n    n = len(outcomes)\n    \n    # Calculate the mean of the outcomes\n    mean = sum(outcomes) / n\n    \n    # Calculate the variance using the formula for discrete uniform distribution\n    variance = ((max(outcomes) - min(outcomes) + 1) ** 2 - 1) / 12\n    \n    # return answer\n    return variance\n\n# Example usage:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-75",
        "question": "In 2017, ABC Corporation had sales of $600,000 and an average accounts receivables of $50,000. What was the 2017 receivables collection period for this company?",
        "tables": [],
        "python_solution": "def solution():\n    revenue = 600000\n    avg_account_receivable = 50000\n    receivables_turnover = revenue / avg_account_receivable\n    receivables_collection_period = 365 / receivables_turnover\n    return receivables_collection_period",
        "ground_truth": 30.417,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    revenue = 600000\n    avg_account_receivable = 50000\n    \n    # Do math calculation to get the answer\n    receivables_turnover = revenue / avg_account_receivable\n    collection_period = 365 / receivables_turnover\n    \n    # return answer\n    return collection_period\n    \n# Program can be tested using\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-76",
        "question": "When a trader buys an annual coupon bond with a 6% coupon rate and exactly 20 years left until it reaches maturity at a price that's equivalent to par value. The trader's investment duration is eight years. The approximate modified duration of the bond is 11.470 years. What is the duration gap at the moment of procurement?",
        "tables": [],
        "python_solution": "def solution():\n    modified_duration = 11.470\n    yield_to_maturity = 0.06\n    investment_horizon = 8\n    macaulay_duration = modified_duration * (1 + yield_to_maturity)\n    duration_gap = macaulay_duration - investment_horizon\n    return duration_gap",
        "ground_truth": 4.158,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    investment_duration = 8\n    bond_duration = 11.470  # Modified Duration of the bond\n    \n    # Calculate the duration gap\n    duration_gap = bond_duration - investment_duration\n    \n    # return answer\n    return duration_gap\n\n# Example of calling the function\nprint(solution())  # Should print the duration gap\n```"
        ]
    },
    {
        "question_id": "validation-77",
        "question": "What is the overall return for the hedge position of Platte River Foods?",
        "tables": [
            "| | | Initial | | Risk- | Contract Price | | |\n|---|---|---|---|---|---|---|---|\n| Price Return | | Roll Return | Collateral Required | Free Rate | Position Size | Current | Longer Term |\n| 4% | | 1.50% | 20% | 1% | $1,500,000 | $750 | $500 |"
        ],
        "python_solution": "def solution():\n    price_return = 4.0\n    roll_return = 1.5\n    collateral_return = 0.2\n    total_return = price_return + roll_return + collateral_return\n    return total_return",
        "ground_truth": 5.7,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    price_return = 0.04      # 4% price return\n    roll_return = 0.015      # 1.50% roll return\n    free_rate = 0.01         # 1% risk-free rate\n    collateral_required = 0.20  # 20% collateral required\n    position_size = 1500000  # $1,500,000 position size\n    contract_price_current = 750  # $750 current contract price\n    contract_price_longer_term = 500  # $500 longer term contract price\n    \n    # Calculate the collateral amount\n    collateral_amount = position_size * collateral_required\n\n    # Calculate the interest earned on the collateral\n    interest_earned_on_collateral = collateral_amount * free_rate\n    \n    # Calculate the total return from price return, roll return, and interest earned\n    total_return = (price_return * position_size) + (roll_return * position_size) + interest_earned_on_collateral\n    \n    # Calculate the overall return as a percentage of the position size\n    overall_return = total_return / position_size\n    \n    # return answer\n    return overall_return\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis Python program defines the necessary input values and performs the required calculations to find the overall return for the hedge position of Platte River Foods as a decimal, which can be converted to a percentage by multiplying by 100 if needed. Note that the calculation assumes the interest is earned on the collateral amount not for the whole year but for the period that corresponds to the holding period of the position, which is not provided in the information given. If the holding period is different, adjustments to the interest earned calculation would be necessary."
        ]
    },
    {
        "question_id": "validation-78",
        "question": "XYZ NY, a home decor purchasing firm, provides a defined benefit pension scheme for its workers. With reference to the details provided in the subsequent table, presuming that there are no write-offs of past service expenses or actuarial losses and if the actuarial loss is disregarded, can you figure out the recurrent pension expenses which would be presented in I/S as per US GAAP?",
        "tables": [
            "|                    |      |\n|--------------------|------|\n| ABC LA retirement plan information 2018  |      |\n| Current service costs    |  320 |\n| Past service costs   |  150 |\n| Employer contributions  |  1,200 |\n| Benefit obligation at beginning of year |  45,000 |\n| Benefit obligation at end of year   |  48,395 |\n| Plan assets at beginning of year   |  40,800 |\n| Plan assets at end of year |  44,300 |\n| Actuarial loss   |  350 |\n| Actual return on plan assets   |  3,100 |\n| Discount rate on plan liabilities   |  7.5% |\n| Expected rate of return on plan assets   |  8.2% |"
        ],
        "python_solution": "def solution():\n    current_service_cost = 320\n    interest_expense = (45000 + 150) * 0.075\n    expected_return = 40800 * 0.082\n    periodic_pension_cost = current_service_cost + interest_expense - expected_return\n    return periodic_pension_cost",
        "ground_truth": 360.65,
        "topic": "Accounting",
        "output": [
            "Based on the information provided and under US Generally Accepted Accounting Principles (GAAP), the pension expense that would be presented in the income statement (I/S) can be calculated by adding the current service cost, the interest cost on the benefit obligation, and then subtracting the expected return on plan assets. \n\nThe interest cost on the benefit obligation can be calculated by multiplying the discount rate with the benefit obligation at the beginning of the year. The expected return on plan assets is determined by multiplying the expected rate of return with the plan assets at the beginning of the year. Additionally, since actuarial losses are not considered (expensed) in the current period, we will ignore the actuarial loss provided in the table.\n\nLet's go ahead and create the Python program:\n\n```python\ndef solution():\n    # Define variables from the provided table\n    current_service_cost = 320\n    benefit_obligation_beginning_of_year = 45000\n    plan_assets_beginning_of_year = 40800\n    discount_rate = 0.075  # This is 7.5%\n    expected_rate_of_return_on_plan_assets = 0.082  # This is 8.2%\n    \n    # Calculate the interest cost on the benefit obligation\n    interest_cost = benefit_obligation_beginning_of_year * discount_rate\n    \n    # Calculate the expected return on plan assets\n    expected_return = plan_assets_beginning_of_year * expected_rate_of_return_on_plan_assets\n    \n    # Calculate total pension expense to be reported in I/S\n    pension_expense = current_service_cost + interest_cost - expected_return\n    \n    # Return the pension expense\n    return pension_expense\n    \n# Call the function and print the result\nprint(f\"Pension Expense: {solution()}\")\n```\n\nThe function `solution` calculates the recurrent pension expense according to the provided details, excluding the actuarial loss as specified. The `print` statement outside the function calls the function and displays the result; however, typically you would just want to return the value if you were using this in a larger application."
        ]
    },
    {
        "question_id": "validation-79",
        "question": "What is the per unit marginal revenue attributed to marketing 250 units instead of 200 units, based on the assessment of the marketing leader from a manufacturer of niche equipment from Switzerland that posits a total income of CHF500,000 from 200 units and CHF600,000 from selling 250 units?",
        "tables": [],
        "python_solution": "def solution():\n    delta_TR = 600000 - 500000\n    delta_Q = 250 - 200\n    MR = delta_TR / delta_Q\n    return MR",
        "ground_truth": 2000.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    revenue_200_units = 500000\n    revenue_250_units = 600000\n    units_initial = 200\n    units_final = 250\n\n    # Do math calculation to get the answer\n    total_additional_revenue = revenue_250_units - revenue_200_units\n    additional_units = units_final - units_initial\n    marginal_revenue_per_unit = total_additional_revenue / additional_units\n    \n    # return answer\n    return marginal_revenue_per_unit\n\n# This function can be called to get the answer\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-80",
        "question": "Bradley took over a Spanish packaging firm. The Spanish venture included Bradley purchasing 200,000 shares at a rate of EUR90 each from a packaging company. He elected to entirely hedge the position with a six month USD/EUR forward contract. Further details of the euro hedge at the beginning and three months later are displayed in Exhibit 1. Using the information in Exhibit 1, if the Spanish shares were sold after three months, what is the mark-to-market value (in US dollars) that the manager would report?",
        "tables": [
            "| Maturity         | At Initiation | Three Months Later | At Maturity |\n|------------------|--------------|---------------------|------------|\n| Spot (USD/EUR)   | 1.3935/1.3983 | 1.4106/1.4210      | 1.4189/1.4289 |\n| 3-month forward  | -8.1/-7.6      | -21.6/-21.0           |          |\n| 6-month forward  | -19.0/-18.3   | -27.0/-26.2           |          |\n| USD Libor       | 1.266%        | 1.266%               | 1.266%   |\n| EUR Libor       | 1.814%        | 1.814%               | 1.814%   |"
        ],
        "python_solution": "def solution():\n    num_shares = 200000\n    price_per_share_eur = 90\n    total_value_eur = num_shares * price_per_share_eur\n    \n    init_forward_rate = 1.3935 - 19/10000\n    settling_forward_rate = 1.4210 - 21/10000\n    \n    diff_rate = init_forward_rate - settling_forward_rate\n    \n    notional_value_usd = diff_rate * total_value_eur\n    \n    libor = 1.266 / 100\n    investment_period = 90\n    \n    mark_to_market_usd = notional_value_usd / (1 + libor * investment_period / 360)\n    \n    return mark_to_market_usd",
        "ground_truth": -489849.626,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    shares_purchased = 200000\n    purchase_rate_eur = 90\n    initial_forward_points = -19.0/10000  # Converted from -19.0 to pips\n    three_months_forward_points = -27.0/10000  # Converted from -27.0 to pips\n    spot_rate_at_initiation = 1.3935\n    spot_rate_three_months_later = 1.4106\n    \n    # Total cost in EUR for purchasing the shares\n    total_cost_eur = shares_purchased * purchase_rate_eur\n    \n    # Initial hedged rate\n    initial_hedged_rate = spot_rate_at_initiation + initial_forward_points\n    \n    # Hedging cost at initiation in USD\n    initial_hedged_cost_usd = total_cost_eur * initial_hedged_rate\n    \n    # Three months later hedged rate\n    three_months_hedged_rate = spot_rate_three_months_later + three_months_forward_points\n    \n    # Mark-to-market value for the hedge three months later in USD\n    mtm_value_usd = total_cost_eur * three_months_hedged_rate\n    \n    # Difference in the hedging cost from initiation to three months later\n    mark_to_market = mtm_value_usd - initial_hedged_cost_usd\n    \n    # return the mark-to-market value (in US dollars)\n    return mark_to_market\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe above program will calculate the mark-to-market value of the hedge by determining the difference in the hedging cost in US dollars from the initiation of the hedge to its value three months later."
        ]
    },
    {
        "question_id": "validation-81",
        "question": "The existing yearly spot rates are presented as follows: 1 year at 2%, 2 years at 2.5%, 3 years at 3.5%, and 4 years at 5.5%. Can you tell me the forward rate for two years starting from two years from now?",
        "tables": [],
        "python_solution": "def solution():\n    # Given Spot rates\n    s1, s2, s3, s4 = 0.02, 0.025, 0.035, 0.055\n\n    # Formula for two years forward rate\n    forward_rate = (((1 + s4)**4 / (1 + s2)**2) ** (1/2)) - 1\n    \n    # Convert to percentage\n    forward_rate *= 100\n\n    return forward_rate",
        "ground_truth": 8.588,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! Below is a Python program to calculate the forward rate for two years starting from two years from now, based on the given spot rates.\n\n```python\ndef solution():\n    # Define spot rates given for different years\n    spot_rates = {\n        1: 0.02,  # 2% for 1 year\n        2: 0.025, # 2.5% for 2 years\n        3: 0.035, # 3.5% for 3 years\n        4: 0.055  # 5.5% for 4 years\n    }\n\n    # Calculate the forward rate using the formula:\n    # (1 + s_n)^n * (1 + f_m)^m = (1 + s_{n+m})^{n+m}\n    # where s_n is n-year spot rate, f_m is m-year forward rate starting from n years\n    # We need to solve for f_2 when n = 2 and m = 2\n    # (1 + s_2)^2 * (1 + f_2)^2 = (1 + s_4)^4\n\n    # Extracting the spot rates\n    s2 = spot_rates[2]\n    s4 = spot_rates[4]\n\n    # Calculate the left hand side of the equation (1 + s2)^2\n    lhs = (1 + s2)**2\n\n    # Calculate the right hand side of the equation (1 + s4)^4 and then divide by (1 + s2)^2 to isolate (1 + f2)^2 on the right\n    rhs = (1 + s4)**4 / lhs\n\n    # Isolate f2 (subtract 1 from both sides and then take the square root)\n    f2 = (rhs)**(1/2) - 1\n\n    # Return the forward rate as a percentage\n    forward_rate = f2 * 100\n\n    return forward_rate\n\n# Run the solution function and print the result\nprint(solution())\n```\n\nThe program defines the given spot rates in a dictionary, uses the formula relating spot and forward rates to calculate the forward rate for two years starting two years from now, and returns the calculated forward rate as a percentage."
        ]
    },
    {
        "question_id": "validation-82",
        "question": "Assuming the same series of spot rates, what is the cost of a 3-year bond that provides an annual interest payment at a 10% coupon rate?",
        "tables": [
            "| Time-to- Maturity | Spot Rates |\n| --- | --- |\n| 1 year | 8.0% |\n| 2 years | 9.0% |\n| 3 years | 9.5% |"
        ],
        "python_solution": "def solution():\n    Z1, Z2, Z3, PMT, FV = 0.08, 0.09, 0.095, 10, 100\n    PV1 = PMT / (1 + Z1)\n    PV2 = PMT / (1 + Z2)**2\n    PV3 = (PMT + FV) / (1 + Z3)**3\n    PV = PV1 + PV2 + PV3\n    return PV",
        "ground_truth": 101.458,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    face_value = 100  # Assuming face value of the bond is $100\n    coupon_rate = 0.10\n    spot_rates = [0.08, 0.09, 0.095]\n    \n    # Calculate the present value of the coupon payments\n    coupons_pv = sum((face_value * coupon_rate) / (1 + spot_rates[i])** (i+1) for i in range(3))\n    \n    # Calculate the present value of the face value (principal repayment at maturity)\n    face_value_pv = face_value / (1 + spot_rates[-1])**3\n    \n    # Summing the present values to get the cost of the bond\n    bond_price = coupons_pv + face_value_pv\n    \n    # return answer\n    return bond_price\n\n# Example usage:\n# print(solution())\n```\n\nThis function calculates the present value of the future coupon payments based on the given spot rates and sums this with the present value of the face value to determine the price of the bond. It assumes a face value of $100, which is a standard assumption if the face value is not provided. Adjust the face value accordingly if it differs."
        ]
    },
    {
        "question_id": "validation-83",
        "question": "The unit contribution margin for an item is $20. A business's fixed production costs up to 300,000 units amounts to $500,000. At which production levels (in units) is the degree of operating leverage (DOL) likely to be the least?",
        "tables": [],
        "python_solution": "def solution():\n    contribution_margin = 20\n    fixed_costs = 500000\n    production_levels = [100000, 200000, 300000]\n    DOLs = []\n\n    for quantity in production_levels:\n        DOL = quantity * contribution_margin / (quantity * contribution_margin - fixed_costs)\n        DOLs.append(DOL)\n\n    minimum_DOL = min(DOLs)\n\n    for i in range(len(DOLs)):\n        if DOLs[i] == minimum_DOL:\n            return production_levels[i]",
        "ground_truth": 300000.0,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "Here is a Python program to calculate at which production levels the degree of operating leverage (DOL) is likely to be the least:\n\n```python\ndef solution():\n    # Define variables name and value\n    unit_contribution_margin = 20\n    fixed_costs = 500000\n    \n    # Degree of operating leverage (DOL) formula at a certain quantity (Q):\n    # DOL = Q * unit_contribution_margin / (Q * unit_contribution_margin - fixed_costs)\n    # Since the fixed costs are constant, as Q * unit_contribution_margin grows larger, \n    # the DOL will become closer to 1 (and thus be at its least value).\n    \n    # As production increases, DOL approaches its minimum value when the denominator (Q * unit_contribution_margin - fixed_costs)\n    # becomes large relative to the fixed costs. In other words, as Q increases significantly beyond the break-even point,\n    # the DOL is minimized. \n    \n    # The minimum DOL value theoretically approaches 1 as production volume goes to infinity\n    # Since we cannot return infinity, we should return a very large number indicating that with higher production levels, DOL is minimized.\n    # We can use a placeholder like \"infinity\" or a very large number to show that it occurs at very high production levels beyond the fixed costs coverage point.\n\n    # The question asks for a practical number, we calculate the break-even point first where total revenue equals total costs.\n    break_even_units = fixed_costs / unit_contribution_margin\n    \n    # Any quantity significantly higher than the break-even point would result in a lower DOL,\n    # so we return a number significantly higher than the break-even point.\n    minimum_dol_units = break_even_units * 10  # example multiplier to simulate 'significantly higher'\n\n    return minimum_dol_units\n\n# Call the solution function and print the result for verification\nprint(solution())\n```\n\nThis program returns a significantly higher number than the break-even point to demonstrate that the DOL is at its least at very high production levels."
        ]
    },
    {
        "question_id": "validation-84",
        "question": "If the periodic inventory system and FIFO method were utilized, in 2013, Corporation Z commenced operations and acquired 2,000 units of inventory, each unit purchased at $50 and sold at $70, with only 1500 units actually sold. In 2014, it acquired another 1,000 units, each unit was purchased at $60 and sold at $75, however only 500 units were sold. What is the ending inventory balance for Corporation Z in 2014?",
        "tables": [],
        "python_solution": "def solution():\n    inventory_in_2014 = 1000\n    cost_per_unit_in_2014 = 60\n    ending_inventory_balance = inventory_in_2014 * cost_per_unit_in_2014\n    return ending_inventory_balance",
        "ground_truth": 60000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n\n    # For 2013\n    beginning_inventory_2013 = 2000\n    purchase_cost_2013 = 50\n    units_sold_2013 = 1500\n\n    # For 2014\n    purchases_2014 = 1000\n    purchase_cost_2014 = 60\n    units_sold_2014 = 500\n\n    # Do math calculation to get the answer\n\n    # Calculate ending inventory for 2013\n    # Since FIFO is used, the remaining inventory will be from the beginning inventory\n    ending_inventory_units_2013 = beginning_inventory_2013 - units_sold_2013\n    ending_inventory_value_2013 = ending_inventory_units_2013 * purchase_cost_2013\n\n    # Calculate ending inventory for 2014\n    # Since FIFO is used, we have to consider the remaining inventory of 2013 first\n    # before accounting for new inventory of 2014.\n    \n    # Calculate the total units available for sale in 2014\n    total_units_2014 = ending_inventory_units_2013 + purchases_2014\n\n    # Calculate the ending inventory units for 2014\n    ending_inventory_units_2014 = total_units_2014 - units_sold_2014\n\n    # Since the ending inventory units is more than the beginning inventory units of 2013\n    # ending inventory of 2014 will consist of all units from 2013 plus some units from 2014.\n    ending_inventory_units_from_2013 = min(ending_inventory_units_2014, ending_inventory_units_2013)\n    ending_inventory_units_from_2014 = ending_inventory_units_2014 - ending_inventory_units_from_2013\n\n    # Calculate the ending inventory value for 2014\n    ending_inventory_value_2014 = (\n        ending_inventory_units_from_2013 * purchase_cost_2013 +\n        ending_inventory_units_from_2014 * purchase_cost_2014\n    )\n\n    # return answer\n    return ending_inventory_value_2014\n\n# Running the function to get the answer\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-85",
        "question": "Johnson's second investment recommendation is to acquire a futures contract for a 10-year Treasury note. The base 2%, semi-annual 10-year Treasury note has a dirty price of 104.17. There have been 30 days since the last coupon payment of the 10-year Treasury note. The futures contract will terminate in 90 days. The quoted price for the futures contract is 129. The current yearly risk-free rate for three months stands at 1.65%. The conversion factor is 0.7025. Smith asks Johnson to compute the quoted futures contract price equilibrium using the carry arbitrage model. What is the equilibrium quoted 10-year Treasury note futures contract price?",
        "tables": [],
        "python_solution": "def solution():\n    B0 = 104.00\n    AI0 = 0.17\n    AIT = (120/180 * 0.02/2)\n    FVCI = 0\n    CF = 0.7025\n    Ft = (B0 + AI0 + AIT) / (1 - FVCI)\n    F_eq = Ft / CF\n    return F_eq",
        "ground_truth": 148.294,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\nfrom math import exp\n\ndef solution():\n    # Given values\n    dirty_price = 104.17       # Dirty price of the base note\n    coupon_payment = 2         # Semi-annual coupon payment (which means annual payment is 4)\n    days_since_last_coupon = 30\n    days_to_future_termination = 90\n    quoted_future_price = 129  # Quoted price of the future contract\n    risk_free_rate = 0.0165    # Yearly risk-free rate for three months\n    conversion_factor = 0.7025 # Conversion factor\n\n    # Calculate the accrued interest for the 30 days since the last coupon payment\n    # Assume each year has 360 days for calculation simplicity\n    accrued_interest = (coupon_payment / 2) * (days_since_last_coupon / 360)\n\n    # Calculate the clean price\n    clean_price = dirty_price - accrued_interest\n\n    # Compute the full price (including accrued interest at delivery) after 90 days\n    full_price_at_delivery = clean_price + (coupon_payment / 2) * ((days_since_last_coupon + days_to_future_termination) / 360)\n\n    # Adjust for present value to find out the cost to carry\n    cost_to_carry = full_price_at_delivery * exp(-risk_free_rate * (days_to_future_termination / 360))\n\n    # Calculate the quoted futures price equilibrium\n    quoted_futures_price_equilibrium = (cost_to_carry / conversion_factor)\n\n    # Return the answer for the equilibrium quoted futures price\n    return quoted_futures_price_equilibrium\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-86",
        "question": "According to the table providing necessary details about four bonds in an investment collection, what is the price value of a basis point for this collection?",
        "tables": [
            "| Par Value | Bond Price | Coupon | Modified Duration | Effective Duration | Convexity |\n| --------- | ---------- | ------ | ----------------- | ------------------ | --------- |\n| $25million | 105 | 8% | 7.9 | 8 | 122 |\n| $25million | 100 | 7% | 8.5 | 8.5 | 154 |\n| $20million | 95 | 5% | 6.3 | 2 | 87 |\n| $30million | 87 | 0% | 10.2 | 10.2 | 32 |"
        ],
        "python_solution": "def solution():\n    bond_weights = [0.25, 0.25, 0.2, 0.3]\n    bond_prices = [105, 100, 95, 87]\n    bond_durations = [8, 8.5, 2, 10.2]\n\n    portfolio_price = sum([bond_weights[i] * bond_prices[i] for i in range(len(bond_weights))])\n   \n    portfolio_duration = sum([bond_weights[i] * bond_prices[i] * bond_durations[i] for i in range(len(bond_weights))]) / portfolio_price\n\n    price_value_basis_point = portfolio_duration * 0.0001 * portfolio_price * 1000000\n\n    return price_value_basis_point",
        "ground_truth": 72672.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To calculate the price value of a basis point (PVBP) for a collection of bonds, you can use the following formula:\n\nPVBP = (Bond Price * Modified Duration * 0.0001)\n\nThe \"0.0001\" factor in the formula represents a basis point, which is 1/100 of a percent (0.01%).\n\nNow let's calculate PVBP for each bond and sum them to find the total PVBP for the entire collection.\n\n```python\ndef solution():\n    # Define variables name and value\n    bonds = [\n        {'par_value': 25e6, 'price': 105, 'modified_duration': 7.9},\n        {'par_value': 25e6, 'price': 100, 'modified_duration': 8.5},\n        {'par_value': 20e6, 'price': 95, 'modified_duration': 6.3},\n        {'par_value': 30e6, 'price': 87, 'modified_duration': 10.2},\n    ]\n    \n    # Calculate PVBP for each bond\n    pvpb_collection = sum([bond['par_value'] * bond['price'] * bond['modified_duration'] * 0.0001 for bond in bonds])\n    \n    # return answer\n    return pvpb_collection\n\n# This will print the total PVBP of the bond collection\nprint(solution())\n```\n\nRunning the `solution()` function will return the total price value of a basis point for the bond collection."
        ]
    },
    {
        "question_id": "validation-87",
        "question": "Firm XYZ has an outstanding zero-coupon bond with 1 year left until it matures. The bond, which is the company's only debt, has a face value of USD 2,000,000 and a recovery rate of 0% in the event of a default. It is currently trading at 75% of its face value. If we assume that the excess spread solely reflects credit risk and the continuously-compounded risk-free rate is 3% yearly, and using risk-neutral binomial tree methodology, what is the approximately risk-neutral 1-year probability of default for Firm XYZ?",
        "tables": [],
        "python_solution": "def solution():\n    from math import exp\n    face_value = 2000000\n    bond_price = 0.75 * face_value\n    risk_free_rate = 0.03\n    expected_payoff = bond_price * exp(risk_free_rate)\n\n    PD = 1 - (expected_payoff / face_value)\n    \n    return PD * 100",
        "ground_truth": 22.716,
        "topic": "Risk Management",
        "output": [
            "To calculate the risk-neutral probability of default, we need to compare the risk-free payoff of the bond, assuming there's no risk of default, with its actual market price, which reflects the risk of default. We can use the given continuously-compounded risk-free rate to calculate the risk-free price and then solve for the risk-neutral probability of default.\n\nBelow is the Python program that performs these calculations:\n\n```python\nimport math\n\ndef solution():\n    # Define variables\n    face_value = 2000000\n    market_value_percent = 0.75\n    risk_free_rate = 0.03  # continuously-compounded\n    \n    # Calculate current market value of the bond\n    current_market_value = face_value * market_value_percent\n    \n    # Calculate the risk-free value of the bond in 1 year (its face value discounted at the risk-free rate)\n    risk_free_value = face_value * math.exp(-risk_free_rate)\n    \n    # Since recovery value is 0, we can calculate the risk-neutral probability of default (p) using the following formula:\n    # current_market_value = (1 - p) * risk_free_value, then solve for p:\n    probability_of_default = 1 - (current_market_value / risk_free_value)\n    \n    # return answer\n    return probability_of_default\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program will provide the risk-neutral 1-year probability of default for Firm XYZ given the inputs for the current market price, the face value of the bond, and the risk-free rate."
        ]
    },
    {
        "question_id": "validation-88",
        "question": "What will be the subsequent book value per share if the corporation buys back 1 million shares at the current market rate, based on the data collected by the researcher about the corporation?",
        "tables": [
            "| Number of shares outstanding | 10 million   |\n|-----------------------------|--------------|\n| Earnings per share          | $2.00        |\n| P/E                         | 20           |\n| Book value per share        | $30          |"
        ],
        "python_solution": "def solution():\n    market_price_per_share = 40\n    shares_to_buy_back = 1e6\n    equity_reduction = market_price_per_share * shares_to_buy_back\n    book_value_equity_before_buyback = 300e6\n    book_value_equity_after_buyback = book_value_equity_before_buyback - equity_reduction\n    no_of_shares_after_buyback = 9e6\n    book_value_per_share_after_buyback = book_value_equity_after_buyback / no_of_shares_after_buyback\n    return book_value_per_share_after_buyback",
        "ground_truth": 28.889,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    number_of_shares_outstanding = 10 * 10**6  # 10 million shares\n    earnings_per_share = 2.00\n    pe_ratio = 20\n    book_value_per_share = 30.00\n    shares_to_buy_back = 1 * 10**6\n    \n    # Find the market price per share using P/E ratio\n    market_price_per_share = earnings_per_share * pe_ratio\n    \n    # Calculate total equity using book value per share times number of shares outstanding\n    total_equity = book_value_per_share * number_of_shares_outstanding\n    \n    # Calculate the total cost of the buyback\n    total_buyback_cost = market_price_per_share * shares_to_buy_back\n    \n    # Deduct the buyback cost from the total equity to get new equity value\n    new_total_equity = total_equity - total_buyback_cost\n    \n    # Calculate the new number of shares outstanding after the buyback\n    new_number_of_shares_outstanding = number_of_shares_outstanding - shares_to_buy_back\n    \n    # Calculate the new book value per share\n    new_book_value_per_share = new_total_equity / new_number_of_shares_outstanding\n    \n    # return answer\n    return round(new_book_value_per_share, 2)\n```"
        ]
    },
    {
        "question_id": "validation-89",
        "question": "Recently, Mr. Lee purchased a property in Shanghai and made a down payment of ¥ 5,000,000. He took out a loan for the remaining balance of ¥5,000,000 from the bank which he will repay monthly over a period of 10 years. Given that the yearly discount rate is 5.8%, what will the initial mortgage repayment be at the end of this month?",
        "tables": [],
        "python_solution": "def solution():\n    N = 10 * 12\n    I_Y = 5.8 / 12 / 100\n    PV = 5000000\n    FV = 0\n    PMT = -PV * (I_Y * ((1 + I_Y)**N)) / ((1+I_Y)**N - 1)\n    return abs(PMT)",
        "ground_truth": 55009.405,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom math import pow\n\ndef solution():\n    # Define variables name and value\n    principal = 5000000  # Remaining balance\n    annual_rate = 0.058  # Yearly discount rate\n    years = 10  # Loan period in years\n \n    # Convert annual rate to monthly and calculate total number of payments\n    monthly_rate = annual_rate / 12\n    total_payments = years * 12\n    \n    # Do math calculation to get the answer\n    # Monthly mortgage payment calculation based on the formula for an annuity\n    # P = (r*PV) / (1 - (1 + r)^-n)\n    # Where:\n    # P = monthly payment\n    # r = monthly interest rate\n    # PV = present value (loan amount)\n    # n = total number of payments\n    monthly_payment = (monthly_rate * principal) / (1 - pow((1 + monthly_rate), -total_payments))\n    \n    # return answer\n    return monthly_payment\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThis program calculates the initial monthly mortgage payment, taking into account the principal, annual discount rate, and loan period in years, and returns the monthly payment amount."
        ]
    },
    {
        "question_id": "validation-90",
        "question": "An organization released a floating-rate note that has a coupon rate equivalent to the three-month MRR + 65 basis points. The interest payments are scheduled for 31 March, 30 June, 30 September, and 31 December. The three-month MRR for 31 March and 30 June stand at 1.55% and 1.35% respectively. What is the coupon rate for the interest remittance done on 30 June?",
        "tables": [],
        "python_solution": "def solution():\n    MRR_March  = 1.55\n    basis_points = 0.65\n    coupon_rate_June = MRR_March + basis_points\n    return coupon_rate_June",
        "ground_truth": 2.2,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "\n```python\ndef solution():\n    # MRR (Market Reference Rate) for 30 June\n    mrr_June = 1.35\n    # Basis points to be added\n    basis_points = 0.65\n    \n    # Convert basis points to percentage\n    basis_points_as_percent = basis_points / 100\n    \n    # Calculate coupon rate by adding MRR with basis points\n    coupon_rate_June = mrr_June + basis_points_as_percent\n    \n    return coupon_rate_June\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-91",
        "question": "What would be the expected standard deviation of the portfolio constructed by a fund manager if the correlation of returns between the two securities is 0.40?",
        "tables": [
            "| Security | Security Weight(%) | Expected Standard Deviation(%) |\n|----------|-------------------|-------------------------------|\n| 1        | 30                | 20                            |\n| 2        | 70                | 12                            |"
        ],
        "python_solution": "def solution():\n    w1 = 0.3\n    w2 = 0.7\n    sigma1 = 20 / 100    # converting the percentage to a decimal\n    sigma2 = 12 / 100    # converting the percentage to a decimal\n    rho12 = 0.40         # correlation of returns between two securities\n\n    sigma_port = ((w1 ** 2 * sigma1 ** 2) + (w2 ** 2 * sigma2 ** 2) + (2 * w1 * w2 * rho12 * sigma1 * sigma2)) ** 0.5\n\n    return sigma_port * 100    # converting the decimal to a percentage",
        "ground_truth": 12.119,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight1 = 0.30  # 30%\n    weight2 = 0.70  # 70%\n    std_dev1 = 0.20  # 20%\n    std_dev2 = 0.12  # 12%\n    correlation = 0.40  # correlation coefficient\n\n    # Do math calculation to get the answer\n    # Portfolio standard deviation calculation using the formula:\n    # sqrt(w1^2 * std1^2 + w2^2 * std2^2 + 2 * w1 * w2 * correlation * std1 * std2)\n    portfolio_std_dev = math.sqrt(\n        (weight1 ** 2) * (std_dev1 ** 2) +\n        (weight2 ** 2) * (std_dev2 ** 2) +\n        (2 * weight1 * weight2 * correlation * std_dev1 * std_dev2)\n    )\n    \n    # return answer\n    return portfolio_std_dev\n\n# Call the function and print the result\nprint(f\"The expected standard deviation of the portfolio: {solution()}\")\n```"
        ]
    },
    {
        "question_id": "validation-92",
        "question": "Three months ago, a supervisor initiated a receive-fixed and pay-equity swap. The annualized fixed interest is 3% and the equity index was at 100 at the time of the swap. The expiry of the swap is one year with a quarterly reset, and the nominal amount is valued at $100 million. The present spot rates are as stated: At what equity index level would this equity swap value stand at zero?",
        "tables": [
            "| Years to maturity | Present Value Factor |\n|-------------------|----------------------|\n| 0.25              | 0.997506             |\n| 0.5               | 0.992556             |\n| 0.75              | 0.985222             |\n| 1                 | 0.975610             |"
        ],
        "python_solution": "def solution():\n    fixed_rate = 0.03\n    nominal_amount = 100000000\n    current_spot_rates = [0.997506, 0.992556, 0.985222]\n    number_of_days = 90\n    denominator = 360\n\n    value_fixed_leg = fixed_rate * (number_of_days / denominator) * nominal_amount * sum(current_spot_rates) + (nominal_amount * current_spot_rates[-1])\n\n    equity_index_price = value_fixed_leg / nominal_amount * 100\n    return equity_index_price",
        "ground_truth": 100.754,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To find the equity index level at which the equity swap value stands at zero, we consider the fixed interest payments against the return from the equity index. The present value of the fixed payments should equal the present value of equity returns at the swap's zero value.\n\nThe fixed payments are made quarterly on the nominal amount. We can calculate the present value of these payments using the present value factors provided.\n\nHere is the Python program that calculates the required equity index level:\n\n```python\ndef solution():\n    # Given values\n    fixed_interest_annual = 0.03  # annualized fixed interest\n    nominal_amount = 100000000  # $100 million\n    pv_factors = [0.997506, 0.992556, 0.985222, 0.975610]  # Present value factors for 0.25, 0.5, 0.75, and 1 year\n    equity_index_start = 100  # Initial equity index\n    reset_frequency = 4  # Quarterly reset\n\n    # Calculate the quarterly fixed payment\n    quarterly_fixed_payment = (fixed_interest_annual / reset_frequency) * nominal_amount\n\n    # Calculate the present value of the fixed payments\n    fixed_payments_pv = sum(quarterly_fixed_payment * pv for pv in pv_factors)\n\n    # Since we want the swap value to stand at zero, the present value of the equity returns should equal the fixed payments_pv\n    # Assume equity returns is the product of some unknown multiplier * equity_index_start * nominal amount. We will assume return after one period\n    # Since present value of fixed payments must equal present value of equity payments, we can equate them and solve for the future equity index (equity_index_end).\n    # present value of fixed = present_value_of_equity = equity_index_end / equity_index_start * nominal_amount * pv_factors[-1]\n    equity_index_end = fixed_payments_pv / (nominal_amount * pv_factors[-1]) * equity_index_start\n\n    # Return the result\n    return equity_index_end\n\n# Call the function and print the result\nprint(solution())\n```\n\nWhen you run this code, it will return the equity index level where the value of the equity swap would be zero."
        ]
    },
    {
        "question_id": "validation-93",
        "question": "A financier looking to calculate the enterprise value multiple (EV/EBITDA) of a business has collected the relevant information, what is the business's EV/EBITDA multiple?",
        "tables": [
            "| Market value of debt | $10 million |\n|----------------------|-------------|\n| Market capitalization| $45 million |\n| Cash and short-term investments | $2.5 million |\n| EBITDA | $15 million |\n| Firm's marginal tax rate | 40% |"
        ],
        "python_solution": "def solution():\n    market_value_common_preferred_stock = 45\n    market_value_debt = 10\n    cash_short_term_investments = 2.5\n    EBITDA = 15\n    enterprise_value = market_value_common_preferred_stock + market_value_debt - cash_short_term_investments\n    EV_EBITDA = enterprise_value / EBITDA\n    return EV_EBITDA",
        "ground_truth": 3.5,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    market_value_of_debt = 10e6  # $10 million\n    market_capitalization = 45e6  # $45 million\n    cash_and_short_term_investments = 2.5e6  # $2.5 million\n    ebitda = 15e6  # $15 million\n    marginal_tax_rate = 0.4  # 40%\n    \n    # Calculate Enterprise Value (EV)\n    enterprise_value = market_value_of_debt + market_capitalization - cash_and_short_term_investments\n    \n    # Calculate EV/EBITDA ratio\n    ev_ebitda = enterprise_value / ebitda\n\n    # return answer\n    return ev_ebitda\n    \n# This will call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-94",
        "question": "What is the present value (PV) of $5,000 that will be received three years from now, applying a 5% discount rate, compounded monthly?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 5000\n    r = 0.05\n    m = 12\n    N = 3\n    PV = FV * (1 + r/m) ** (-m*N)\n    return PV",
        "ground_truth": 4304.881,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Import package if needed\ndef solution():\n    # Define variables name and value\n    future_value = 5000\n    annual_discount_rate = 0.05\n    periods_per_year = 12\n    total_periods = periods_per_year * 3 # 3 years\n    \n    # Do math calculation to get the answer\n    monthly_discount_rate = (1 + annual_discount_rate) ** (1/periods_per_year) - 1\n    present_value = future_value / ((1 + monthly_discount_rate) ** total_periods)\n    \n    # return answer\n    return present_value\n\n# Note: Depending on the precision required, you might want to format the answer,\n# for instance, using round(present_value, 2) to get a rounded value with two decimals.\n```"
        ]
    },
    {
        "question_id": "validation-95",
        "question": "The chief financial officer of a manufacturing firm based in the UK, Susan Sullivan, gathers the exchange rates from Dealer B as given in Exhibit 1. The company will receive EUR 5,000,000 from a different client in three months. Half a year ago, the firm traded EUR 5,000,000 for GBP using a forward contract of nine months at an inclusive price of GBP/EUR 0.7400. Considering Exhibits 1 and 2, what would be the mark-to-market gain for Sullivan's forward position if the position is marked to the market by gathering the GBP/EUR forward rates displayed in Exhibit 2?",
        "tables": [
            "| Currency Pair (Price/Base) | Bid    | Offer  | Midpoint |\n|----------------------------|--------|--------|----------|\n| JPY/GBP                    | 187.39 | 187.43 | 187.41   |\n| MXN/USD                    | 17.147 | 17.330 | 17.239   |\n| GBP/EUR                    | 0.7342 | 0.7344 | 0.7343   |\n| USD/EUR                    | 1.1572 | 1.1576 | 1.1574   |\n| USD/GBP                    | 1.5762 | 1.5766 | 1.5764   |",
            "|          |                        |\n|----------|------------------------|\n|Exhibit 2. GBP/EUR Forward Rates||\n| Maturity   | Forward Points  |\n| One month  | 4.40/4.55       |\n| Three months| 14.0/15.0      |\n| Six months  | 29.0/30.0       |\n|          | the GBP 90- day Libor = 0.5800%|"
        ],
        "python_solution": "def solution():\n    spot_rate = 0.7344\n    forward_points = 15/10000\n    three_month_forward_rate = spot_rate + forward_points\n    contract_rate = 0.7400\n    eur_amount = 5000000\n    libor_rate = 58/100\n\n    net_cash_flow = eur_amount * (contract_rate - three_month_forward_rate)\n    mark_to_market_gain = net_cash_flow / ((1 + libor_rate/100)**(3/12))\n\n    return mark_to_market_gain",
        "ground_truth": 20470.382,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Given values\n    contract_size_eur = 5000000\n    original_forward_rate = 0.7400\n    current_spot_rate = 0.7343\n    three_month_forward_points = 0.000145  # Midpoint of 14.0/15.0 is 14.5, which is 0.000145 in decimal\n    \n    # The current forward rate for a three-month forward contract\n    current_forward_rate = current_spot_rate + three_month_forward_points\n    \n    # The value of the original forward contract\n    original_contract_value_gbp = contract_size_eur * original_forward_rate\n    \n    # The value of the current forward contract\n    current_contract_value_gbp = contract_size_eur * current_forward_rate\n    \n    # Mark-to-market gain of the forward position\n    mark_to_market_gain = current_contract_value_gbp - original_contract_value_gbp\n    \n    return mark_to_market_gain\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis Python program calculates the mark-to-market gain of Sullivan's forward position based on the given GBP/EUR forward rates."
        ]
    },
    {
        "question_id": "validation-96",
        "question": "What is the share value of REIT B using valuation Method 4, according to Exhibits 1 and 2?",
        "tables": [
            "| Property subsector          | REIT A Office | REIT B Storage | REIT C Health Care |\n|-----------------------------|---------------|----------------|--------------------|\n| Estimated 12 months cash net operating income (NOI) | $ 350,000    | $ 267,000        | $ 425,000            |\n| Funds from operations (FFO)   | $ 316,965    | $ 290,612        | $ 368,007            |\n| Cash and equivalents         | $ 308,700    | $ 230,850        | $ 341,000            |\n| Accounts receivable         | $ 205,800    | $ 282,150        | $ 279,000            |\n| Debt and other liabilities   | $ 2,014,000  | $ 2,013,500    | $ 2,010,000          |\n| Non-cash rents             | $ 25,991     | $ 24,702        | $ 29,808             |\n| Recurring maintenance-type capital  expenditures | $ 63,769     | $ 60,852        | $ 80,961             |\n| Shares  outstanding        | 56,100       | 67,900          | 72,300              |"
        ],
        "python_solution": "def solution():\n    FFO = 316965\n    non_cash_rents = 25991\n    recurring_maintenance_capex = 63769\n    shares_outstanding = 56100\n    P_AFFO_multiple = 18.3\n\n    AFFO = FFO - non_cash_rents - recurring_maintenance_capex\n    AFFO_per_share = AFFO / shares_outstanding\n    share_value = AFFO_per_share * P_AFFO_multiple\n\n    return share_value",
        "ground_truth": 74.115,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the share value of REIT B using valuation Method 4 (adjusted funds from operations (AFFO) per share), we will subtract the recurring maintenance-type capital expenditures from the funds from operations (FFO) and then divide by the shares outstanding.\n\nAdjusted Funds from Operations (AFFO) for REIT B can be computed as follows:\n\\[ AFFO = FFO - Recurring Maintenance-Type Capital Expenditures \\]\n\nThe AFFO per share is then calculated by dividing the AFFO by the number of shares outstanding.\n\n```python\ndef solution():\n    # Define variables name and value\n    FFO_REIT_B = 290612     # Funds from operations for REIT B\n    recurring_cap_ex_REIT_B = 60852  # Recurring maintenance-type capital expenditures for REIT B\n    shares_outstanding_REIT_B = 67900 # Shares outstanding for REIT B\n    \n    # Calculate Adjusted Funds from Operations (AFFO) for REIT B\n    AFFO_REIT_B = FFO_REIT_B - recurring_cap_ex_REIT_B\n    \n    # Calculate AFFO per share for REIT B\n    AFFO_per_share_REIT_B = AFFO_REIT_B / shares_outstanding_REIT_B\n    \n    # return answer\n    return AFFO_per_share_REIT_B\n\n# Example usage:\nprint(solution())\n```\n\nExecuting the above snippet will return the value of the share for REIT B based on the AFFO per share using the given input data."
        ]
    },
    {
        "question_id": "validation-97",
        "question": "Firms A and B start the year with the same book value of equity and identical tax rate. They have identical operations throughout the year and record all operations similarly except for one. Both firms purchase a printer worth £300,000 with a three-year useful life and no salvage value on 1st January of the new year. Firm A capitalizes the printer and it undergoes straight-line depreciation, while Firm B expenses the printer. The following year-end data is collected for Firm A. Based on this information, what would Firm B’s return on equity be using year-end equity with the ending shareholders’ equity being £10,000,000, a tax rate of 25%, £0.00 in dividends, and a net income of £750,000?",
        "tables": [],
        "python_solution": "def solution():\n    A_net_income = 750000\n    A_equity = 10000000\n    B_net_income = A_net_income - 150000 # B company has larger expense, hence the lower net income\n    B_equity = A_equity - 150000 # B company has lower net income, hence the lower equity\n    B_ROE = B_net_income / B_equity\n    return B_ROE * 100",
        "ground_truth": 6.091,
        "topic": "Accounting",
        "output": [
            "To calculate Firm B's return on equity (ROE), we first need to adjust its net income to reflect expensing the printer instead of capitalizing and depreciating it.\n\nFirm A capitalizes the printer, so it depreciates it straight-line over three years: \n\nDepreciation expense per year for Firm A = £300,000 / 3 = £100,000\n\nFirm B expenses the printer, so:\n\nAdditional expense for Firm B in the first year = £300,000\n\nSince depreciation reduces taxable income and thus taxes paid, Firm B would pay more tax because it didn't capitalize the printer. \n\nTax savings for Firm A due to depreciation = Depreciation expense * Tax rate\n                                               = £100,000 * 25%\n\nAdjusted net income for Firm B:\nAdjusted net income = Reported net income + Depreciation expense - (Depreciation * Tax rate) - Additional expense for expensing the printer + (Additional expense * Tax rate)\n\nThen we can calculate the ROE for Firm B:\nROE_B = (Adjusted net income) / Ending shareholders' equity\n\nFinally, we will reflect these calculations in the Python program:\n\n```python\ndef solution():\n    # Define variables\n    printer_cost = 300000\n    useful_life = 3\n    tax_rate = 0.25\n    ending_equity = 10000000\n    net_income = 750000\n    dividends = 0.00\n    \n    # Depreciation for Firm A\n    depreciation_expense = printer_cost / useful_life\n    \n    # Tax savings for Firm A due to depreciation\n    tax_savings = depreciation_expense * tax_rate\n    \n    # Adjusted net income for Firm B\n    adjusted_net_income = net_income + depreciation_expense - tax_savings - printer_cost + (printer_cost * tax_rate)\n    \n    # ROE for Firm B\n    roe_b = (adjusted_net_income / ending_equity) * 100\n    \n    # Return answer\n    return roe_b\n\n# Remember to call the function to get the actual output\nprint(solution())\n```\n\nThis program will calculate and return the ROE for Firm B."
        ]
    },
    {
        "question_id": "validation-98",
        "question": "As an arbitrage trader, Bob wishes to determine the continuous implied dividend yield of a stock. He is studying the over-the-counter price of a five-year European put and call on this particular stock. The data he has includes: S = $85, K = $90, r = 5%, c = $10, p = $15. What would be the implied dividend yield of the stock?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    \n    S = 85  # The stock is currently trading at\n    K = 90  # The strike price of the option\n    r = 5/100  # Interest rate\n    c = 10  # Price of a call option\n    p = 15  # Price of a put option\n    tau = 5  # time to maturity (in years)\n\n    S_tau = c - p + K * math.exp(-r * tau)  # From put-call parity\n    y = -1/tau * math.log(S_tau / S)  # Dividend yield\n\n    return y*100  # convert it to percentage and return",
        "ground_truth": 5.337,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Given variables: \n    S = 85  # Spot price of the stock\n    K = 90  # Strike price of the options\n    r = 0.05  # Risk-free interest rate (expressed as a decimal)\n    c = 10  # Call option price\n    p = 15  # Put option price\n    T = 5  # Time to maturity in years\n\n    # Using put-call parity for European options:\n    # c + Ke^(-rT) = p + Se^(-qT)\n    # where q is the continuous dividend yield, solve for q:\n    \n    q = - (math.log((p-c+K*math.exp(-r*T))/S))/T\n    \n    # return answer rounded to a percentage with two decimals\n    return round(q*100, 2)\n\n# The function can now be called to get the answer\nprint(solution())  # This print is for testing and should be removed if the solution function is used in a deployment.\n```"
        ]
    },
    {
        "question_id": "validation-99",
        "question": "The Novartis Company noted a notable rise in its profitability, which led to a material increase in its credit score. Consequently, the market demanded a 100 basis point tighter spread to Gilts on Novartis's 8-year bond. In case the bond's altered duration is 6.0 and its convexity is 55.0, what would be the effect of this change on the return?",
        "tables": [],
        "python_solution": "def solution():\n    modified_duration = 6.0\n    delta_spread = -0.01\n    convexity = 55.0\n\n    return_impact = -(modified_duration * delta_spread) + 0.5 * convexity * (delta_spread**2)\n    return return_impact*100",
        "ground_truth": 6.275,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! We can calculate the change in bond return considering both the duration effect and the convexity effect due to a change in yield spreads. Here is the Python program that performs this calculation:\n\n```python\ndef solution():\n    # Define variables name and value\n    spread_change_basis_points = -100\n    duration = 6.0\n    convexity = 55.0\n\n    # Convert basis points to decimal\n    spread_change_decimal = spread_change_basis_points / 10000\n    \n    # Using duration and convexity to approximate the change in bond price (%)\n    # Duration effect for change in yield\n    duration_effect = -duration * spread_change_decimal  \n    # Convexity effect for change in yield\n    convexity_effect = 0.5 * convexity * (spread_change_decimal ** 2)\n    \n    # Total percentage change in price\n    total_price_change = duration_effect + convexity_effect\n    \n    # return answer\n    return total_price_change\n\n# Call the function and print the result to verify the output.\nprint(solution())\n```\n\nYou can run the above Python program, and it will calculate the expected change in return on Novartis's bond given a 100 basis point tightening in the spread to Gilts."
        ]
    },
    {
        "question_id": "validation-100",
        "question": "A company debt security provides a coupon rate of 5% and only has 3 years left until it matures. The interest is given yearly. The benchmark spot curve currently lists a series of rates. Right now, the bond is trading at a Z-spread of 234 basis points. What's the bond's worth?",
        "tables": [
            "| Time-to-Maturity | Spot Rate |\n|------------------|-----------|\n| 1 year           | 4.86%     |\n| 2 years          | 4.95%     |\n| 3 years          | 5.65%     |"
        ],
        "python_solution": "def solution():\n    PMT = 5\n    FV = 100\n    S1 = 0.0486\n    S2 = 0.0495\n    S3 = 0.0565\n    Z = 0.0234\n\n    PV1 = PMT / ((1 + S1 + Z)**1)\n    PV2 = PMT / ((1 + S2 + Z)**2)\n    PV3 = (PMT + FV) / ((1 + S3 + Z)**3)\n\n    return PV1 + PV2 + PV3",
        "ground_truth": 92.383,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Coupon rate and face value for the debt security\n    coupon_rate = 0.05\n    face_value = 100  # assuming a face value of 100\n\n    # Remaining time until maturity in years\n    time_to_maturity = 3\n    \n    # Spot rates for each year\n    spot_rates = [0.0486, 0.0495, 0.0565]\n    \n    # Z-spread added to each spot rate\n    z_spread = 0.0234  # 234 basis points\n\n    # Initialize bond price\n    bond_price = 0.0\n\n    # Calculate the present value of the coupon payments and the face value\n    for year in range(1, time_to_maturity + 1):\n        adjusted_rate = spot_rates[year - 1] + z_spread\n        # Present value of coupon payments\n        bond_price += (coupon_rate * face_value) / ((1 + adjusted_rate) ** year)\n\n    # Add the present value of the nominal at maturity\n    bond_price += face_value / ((1 + spot_rates[-1] + z_spread) ** time_to_maturity)\n\n    # return bond's worth\n    return bond_price\n\n# Call the function and print the result\nprint(f\"The bond's worth is: {solution():.2f}\")\n```\n\nThe program defines the variables required to calculate the bond's worth, such as the coupon rate, face value, time to maturity, spot rates, and Z-spread. It then calculates the present value of each coupon payment and the face value at maturity, adjusting the spot rates by the Z-spread. Finally, it sums these present values to arrive at the bond's present worth and prints the result."
        ]
    },
    {
        "question_id": "validation-101",
        "question": "What is the expected return for XYZ Company if its stock has a beta of 0.65, the risk-free rate of return is 3% and the expected market return is 9%?",
        "tables": [],
        "python_solution": "def solution():\n    beta = 0.65\n    risk_free_rate = 0.03\n    expected_market_return = 0.09\n\n    expected_return = risk_free_rate + beta * (expected_market_return - risk_free_rate)\n    return expected_return",
        "ground_truth": 0.069,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    beta = 0.65\n    risk_free_rate = 0.03\n    market_return = 0.09\n    \n    # Calculate the expected return using the Capital Asset Pricing Model (CAPM)\n    expected_return = risk_free_rate + beta * (market_return - risk_free_rate)\n    \n    # return answer\n    return expected_return\n\n# You can call the function to see the result\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-102",
        "question": "A researcher collects the following data on a bond: Roughly modified duration 10.3829 and roughly modified convexity 141.217. What is the projected percentage price alteration for the bond should the yield to maturity fall by 50 bps?",
        "tables": [],
        "python_solution": "def solution():\n    MD = 10.3829\n    Convexity = 141.217\n    Delta_Yield= -0.005\n    Percentage_change_in_bond_price = ((-MD*Delta_Yield)+(0.5*Convexity*(Delta_Yield)**2))  \n    return Percentage_change_in_bond_price*100",
        "ground_truth": 5.368,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    dm = 10.3829  # Roughly modified duration\n    conv = 141.217  # Roughly modified convexity\n    delta_y = 0.0050  # Yield change in decimal (50 bps)\n\n    # The approximate formula for the percentage price change is:\n    # Percentage price change ≈ -Dm * Δy + 0.5 * Convexity * (Δy)^2\n    # Do math calculation to get the answer\n    percentage_price_change = (-dm * delta_y) + (0.5 * conv * (delta_y ** 2))\n    \n    # return answer\n    return percentage_price_change\n\n# You can call the function to see the result\nprint(solution())\n```\nThis Python function calculates the projected percentage price change for a bond given the duration, convexity, and a change in yield."
        ]
    },
    {
        "question_id": "validation-103",
        "question": "Currently, Serene Vacation Corp has 1.2 million common shares of stock outstanding with a beta of 2.2. They also have $10 million face value of bonds with five years left to maturity and an 8% coupon with semiannual payments, priced to yield 13.65%. If Serene issues up to $2.5 million of new bonds, they will be priced at par and will have a yield of 13.65%; but if they issue bonds beyond $2.5 million, the entire issuance is expected to yield 16%. Serene has found out it can issue new common stock at $10 a share. The current risk-free interest rate is 3%, and the expected market return is 10%. Serene's marginal tax rate is 30%. If Serene secures $7.5 million of new funding while keeping the same debt-to-equity ratio, what will its weighted average cost of capital be?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 10000000\n    PMT = 400000\n    N = 10\n    I_YR = 6.825/100\n    PV = FV / ((1 + I_YR)**N)\n    Equity = 1.2 * 1000000 * 10\n    to_be_raised = 7.5 * 1000000\n    bonds = to_be_raised * 0.4\n    rd = 0.16\n    t = 0.3\n    re = 0.03 + 2.2 * (0.10 - 0.03)\n    rdnt = rd * (1 - t)\n    WACC = 0.4 * rdnt + 0.6 * re\n    return WACC*100",
        "ground_truth": 15.52,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\nimport numpy_financial as npf\n\ndef solution():\n    # Variables provided in the problem\n    shares_outstanding = 1.2e6\n    beta = 2.2\n    face_value_bonds = 10e6\n    years_to_maturity = 5\n    coupon_rate = 0.08\n    bond_yield_to_maturity = 0.1365\n    new_bonds_yield = 0.1365 if face_value_bonds <= 2.5e6 else 0.16\n    stock_price = 10\n    risk_free_rate = 0.03\n    market_return = 0.10\n    tax_rate = 0.30\n    new_funding = 7.5e6\n\n    # Capital Asset Pricing Model (CAPM) for cost of equity\n    cost_of_equity = risk_free_rate + beta * (market_return - risk_free_rate)\n\n    # Cost of debt from existing bonds (using yield to maturity)\n    coupon_payment = face_value_bonds * coupon_rate / 2\n    number_of_periods = years_to_maturity * 2\n    market_value_of_bonds = npf.pv(rate=bond_yield_to_maturity/2, nper=number_of_periods, pmt=coupon_payment, fv=face_value_bonds)\n    cost_of_debt_before_tax = coupon_rate / market_value_of_bonds * face_value_bonds\n    cost_of_debt = cost_of_debt_before_tax * (1 - tax_rate)\n\n    # We calculate the portion of new financing that would come from equity and debt\n    equity_ratio = shares_outstanding * stock_price / (shares_outstanding * stock_price + face_value_bonds)\n    debt_ratio = 1 - equity_ratio\n\n    # New equity raised\n    new_equity_funding = new_funding * equity_ratio\n    new_shares_issued = new_equity_funding / stock_price\n\n    # New debt cost (if exceeding $2.5M, yield is 16% on the entire issuance, else 13.65%)\n    if new_funding * debt_ratio > 2.5e6:\n        new_debt_yield = 0.16\n    else:\n        new_debt_yield = new_bonds_yield\n\n    # Use the after-tax cost for the new bonds\n    new_cost_of_debt = new_debt_yield * (1 - tax_rate)\n\n    # Weighted average cost of capital (WACC) calculation\n    new_total_equity = (shares_outstanding + new_shares_issued) * stock_price\n    new_total_debt = face_value_bonds + new_funding * debt_ratio\n    total_value = new_total_equity + new_total_debt\n\n    # WACC = E/V * Ke + D/V * Kd * (1-T)\n    WACC = (new_total_equity / total_value) * cost_of_equity + (new_total_debt / total_value) * new_cost_of_debt\n\n    # Return the answer\n    return round(WACC, 4)\n```\n\nThis program calculates the weighted average cost of capital (WACC) for Serene Vacation Corp after it secures $7.5 million of new funding while keeping the same debt-to-equity ratio. The cost of equity is calculated using the Capital Asset Pricing Model (CAPM). The cost of debt is adjusted for the tax rate. Then, those costs are blended in proportion to the new total equity and total debt to find the WACC."
        ]
    },
    {
        "question_id": "validation-104",
        "question": "The time-to-maturity for Bond D is 3 years and it has a coupon rate of 8%. The annual payments of interest can be seen. Given the depicted spot rates, what would be the price of Bond D using these spot rates?",
        "tables": [
            "| Time-to-Maturity | Spot rates |\n|-----------------|------------|\n| 1-year            | 7%             |\n| 2-year            | 8%             |\n| 3-year            | 9%             |"
        ],
        "python_solution": "def solution():\n    PMT = 8\n    Par = 100\n    S1 = 0.07\n    S2 = 0.08\n    S3 = 0.09\n    PV = PMT/(1+S1) + PMT/((1+S2)**2) + (PMT+Par)/((1+S3)**3)\n    return PV",
        "ground_truth": 97.731,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    face_value = 1000  # typically bonds have a face value of $1000\n    coupon_rate = 0.08  # 8% annual coupon rate\n    spot_rates = {1: 0.07, 2: 0.08, 3: 0.09}  # Spot rates for 1, 2, and 3 years\n    \n    # Calculate the present value of the coupon payments and the face value of the bond\n    total_present_value = 0\n    for year in range(1, 4):  # Years 1 to 3\n        coupon_payment = face_value * coupon_rate\n        discount_factor = 1 / (1 + spot_rates[year]) ** year\n        present_value = coupon_payment * discount_factor\n        total_present_value += present_value\n\n    # Calculate the present value of the face value redeemed at the end of year 3\n    present_value_face_value = face_value / (1 + spot_rates[3]) ** 3\n    total_present_value += present_value_face_value\n\n    # The price of the bond is the total present value of all cash flows\n    price_of_bond = total_present_value\n    \n    # return answer\n    return round(price_of_bond, 2)  # Rounding to two decimal places for currency representation\n\n# Call the solution function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-105",
        "question": "Working at the Equity investment company, Jessica, a CFA, noted that Clearwater Primary School had spent ¥360 million to acquire a 50 percent stake in Snowflake Early Learning Center on 31 December 2018. The surplus of the acquisition cost over the net assets' fair value of Snowflake was due to previously unregistered licenses. These licenses were estimated to possess an economic lifespan of five years. The value of Snowflake's assets and liabilities, excluding licenses, were equivalent to their documented book value. Clearwater and Snowflake's summarized income statements for the year ending 31 December 2018, and Balance Sheet are presented in the subsequent table: Assuming that both companies' 2019 figures mirror those of 2018 and Clearwater has command over Snowflake, what would be Clearwater’s consolidated depreciation and amortization expense for 2019?",
        "tables": [
            "|                          | Golden | Frost |\n|--------------------------|--------|-------|\n| Revenue                  | 380    | 460   |\n| Cost of goods sold       | (320)  | (210) |\n| Administrative expenses  | (110)  | (65)  |\n| Depreciation & amortization expense | (106)  | (85)  |\n| Interest expense         | (36)  | (18)   |\n| Income before            | 308    | 82    |\n| Income tax expense       | (125)  | (29)  |\n| Net income               | 183    | 53    |",
            "|                             | Golden | Frost |\n|-----------------------------|--------|-------|\n| Cash                        | 80     | 60    |\n| Account receivable          | 110    | 90    |\n| Inventory                   | 210    | 130   |\n| Total current assets        | 400    | 280   |\n| PP&E                        | 1220   | 770   |\n| Investment in Frost         | 360    | N/A   |\n| Total assets                | 1,980  | 1,050 |\n| Current liabilities         | 130    | 95    |\n| Long-term debt              | 520    | 390   |\n| Total liabilities           | 650    | 485   |\n| Common stock                | 810    | 500   |\n| Retained earnings           | 520    | 65    |\n| Total equity                | 1,330  | 565   |"
        ],
        "python_solution": "def solution():\n    unrecorded_licenses_value = 155\n    lifetime_of_unrecorded_licenses = 5\n    depreciation_of_unrecorded_licenses = unrecorded_licenses_value / lifetime_of_unrecorded_licenses\n    depreciation_and_amortization_of_Clearwater = 106\n    depreciation_and_amortization_of_Snowflake = 85\n    consolidated_depreciation_and_amortization = depreciation_and_amortization_of_Clearwater + depreciation_and_amortization_of_Snowflake + depreciation_of_unrecorded_licenses\n    return consolidated_depreciation_and_amortization",
        "ground_truth": 222.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    golden_depreciation = 106\n    investment_in_frost = 360\n    frost_net_assets = (1050 - 485)  # Total assets - Total liabilities\n    purchased_percentage = 0.5\n    economic_lifespan = 5\n\n    # The excess of purchase over book value is attributed to the licenses\n    excess_purchase_over_book = investment_in_frost - (purchased_percentage * frost_net_assets)\n\n    # Annual amortization expense for licenses\n    annual_amortization_expense = excess_purchase_over_book / economic_lifespan\n\n    # Frost's depreciation & amortization\n    frost_depreciation = 85\n\n    # Clearwater's (Golden) share of Frost's depreciation & amortization\n    golden_share_frost_depreciation = purchased_percentage * frost_depreciation\n\n    # Combined depreciation and amortization for Golden\n    total_depreciation_amortization = golden_depreciation + golden_share_frost_depreciation + annual_amortization_expense\n    \n    # Return answer\n    return total_depreciation_amortization\n\n# Call the function and print result for checking\nprint(solution())\n```\n\nIn the above program, we have assumed that the `frost_net_assets` calculation excludes the investment in Frost because we are focusing on Snowflake (which is referred to as Frost in the table), and Snowflake cannot invest in itself. The `investment_in_frost` is considered to be Clearwater's (Golden in the table) investment in Snowflake. We calculate the excess purchase over book value to find the value attributed to the licenses, which we then amortize over their economic lifespan to add to the depreciation & amortization expense."
        ]
    },
    {
        "question_id": "validation-106",
        "question": "The table below provides details about a zero-coupon bond. Using this table, can you identify the key rate '01 for a shift of 10 years?",
        "tables": [
            "|                  | Value  |\n|------------------|--------|\n| Initial Value    | 87.1876|\n| 2-year shift for 1bp    | 87.3212|\n| 5-year shift for 1bp    | 87.2545|\n| 10-year shift for 1bp   | 87.1454|\n| 30-year shift for 1bp   | 87.3454|"
        ],
        "python_solution": "def solution():\n    ten_year_shift_for_1_bp = 87.1454\n    initial_value = 87.1876\n    key_rate_01_for_10_year_shift = -(ten_year_shift_for_1_bp - initial_value)\n    return key_rate_01_for_10_year_shift",
        "ground_truth": 0.042,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define the initial value of the bond\n    initial_value = 87.1876\n    \n    # Key rate '01 for a shift of 10 years is the change in the bond's value for a 1 basis point shift in the 10-year interest rate.\n    # The value of the bond after a 10-year shift for 1 basis point\n    value_after_10yr_shift = 87.1454\n    \n    # Calculate the key rate '01, which is the difference between the initial value and the value after the shift,\n    # divided by the shift size (which is 1 basis point, or 0.01%)\n    key_rate_01_10yr = (initial_value - value_after_10yr_shift) / 0.01\n    \n    # return answer\n    return key_rate_01_10yr\n\n# You can call the function and print the result if you want to test\n# result = solution()\n# print(result)\n```"
        ]
    },
    {
        "question_id": "validation-107",
        "question": "A financial expert predicts that 20% of high-risk bonds will go bankrupt. When he uses a bankruptcy prediction model, he finds that 70% of these bonds will be deemed as \"good\", suggesting a lower risk of failure. Of the bonds that went bankrupt, only 50% were rated as \"good\". Use Bayes' formula to estimate the likelihood of going bankrupt bearing a \"good\" rating. (Hint, let P(A) be the likelihood of bankruptcy, P(B) be the probability of a \"good\" rating, P(B | A) be the probability of a \"good\" rating given bankruptcy, and P(A | B) be the likelihood of bankruptcy given a \"good\" rating.)",
        "tables": [],
        "python_solution": "def solution():\n    P_A = 0.20 # probability of failure\n    P_B = 0.70 # probability of a \"good\" rating\n    P_B_A = 0.50 # probability of a \"good\" rating given failure\n\n    P_A_B = (P_B_A * P_A) / P_B # probability of failure given a \"good\" rating\n\n    return P_A_B",
        "ground_truth": 0.143,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    P_A = 0.20  # Probability of bankruptcy\n    P_B_given_A = 0.50  # Probability of a \"good\" rating given bankruptcy\n    P_B = 0.70  # Probability of a \"good\" rating\n    \n    # Do math calculation to get the answer using Bayes' theorem\n    # P(A|B) = (P(B|A) * P(A)) / P(B)\n    P_A_given_B = (P_B_given_A * P_A) / P_B\n    \n    # return answer\n    return P_A_given_B\n\n# You can call the function to verify the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-108",
        "question": "If a customer needs £100,000 a year from now and the declared yearly rate is 2.50% compounded on a weekly basis, what amount should be deposited today?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 100000\n    r = 0.025\n    m = 52\n    N = 1\n    PV = FV * (1 + r/m) ** (-m*N)\n    return int(PV)",
        "ground_truth": 97531.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Import package if necessary\nimport math\n\ndef solution():\n    # Define variables name and value\n    future_value = 100000\n    annual_interest_rate = 0.025\n    compoundings_per_year = 52  # weekly compounding\n    \n    # Calculate the number of compound periods\n    total_periods = compoundings_per_year\n    \n    # Calculate the effective periodic rate\n    periodic_rate = (1 + annual_interest_rate)**(1/compoundings_per_year) - 1\n    \n    # Calculate the present value of the future amount\n    present_value = future_value / ((1 + periodic_rate)**total_periods)\n    \n    # return answer\n    return round(present_value, 2)\n\n# Example call to the function:\nprint(solution())\n```\n\nThe `solution()` function calculates the amount that needs to be deposited today, given a future value, an annual interest rate, and weekly compounding periods. The `round(present_value, 2)` statement rounds the answer to two decimal places."
        ]
    },
    {
        "question_id": "validation-109",
        "question": "Based on Exhibit 1 and Zhang's beliefs about recurring costs, what is the trailing P/E she calculated for Cratt Ltd?",
        "tables": [
            "|      | 31 December 2017 | 31 December 2016 |\n|------|------------------|------------------|\n| EPS  | $1.03            | $0.89            |\n| Core EPS* | $1.31       | $1.01            |",
            "\n|                                                                                               |\n|------------------------------------------------------------------------------------------------|\n| Core EPS is a non-GAAP measure that excludes acquisition charges of                           |\n| $0.18 and $0.12 in 2017 and 2016, respectively, as well as $0.10 in 2017                      |\n| related to the settlement of a lawsuit.                                                       |\n"
        ],
        "python_solution": "def solution():\n    stock_price = 11.31\n    recurring_eps = 1.03 + 0.10\n    trailing_pe = stock_price / recurring_eps\n    return trailing_pe",
        "ground_truth": 10.009,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! However, to calculate the trailing P/E (Price to Earnings) ratio we need to know the current market price of Cratt Ltd's stock. This value is not provided in the table.\n\nThe trailing P/E ratio is calculated by taking the current market price of a company’s stock and dividing it by the company’s trailing 12-month earnings per share (EPS). If Zhang is using the core EPS to calculate the P/E ratio, then we would use the core EPS for the most recent year, which is 2017 in this case.\n\nSince the current market price of Cratt Ltd's stock is not provided, I will demonstrate the calculation below with a placeholder for the current stock price. You would need to replace 'current_stock_price' with the actual stock price to get the correct trailing P/E ratio.\n\n```python\ndef solution():\n    # Define variables name and value\n    current_stock_price = 0  # Placeholder for current stock price, you need to replace it with the actual value\n\n    # Earnings Per Share (EPS) for the year 2017\n    eps_2017 = 1.31  # Core EPS for 2017\n\n    # Do math calculation to get the trailing P/E\n    if eps_2017 == 0:\n        return \"EPS is zero, P/E cannot be calculated.\"\n    \n    trailing_pe = current_stock_price / eps_2017\n\n    # return trailing P/E ratio\n    return trailing_pe\n\n# Placeholder function call\n# You need to update the 'current_stock_price' variable in the function to the actual current stock price before running the function.\nprint(solution())\n```\n\nPlease note that the `current_stock_price` must be replaced with the actual stock price of Cratt Ltd's stock. If you provide the current stock price, I can update the program to calculate the actual trailing P/E ratio."
        ]
    },
    {
        "question_id": "validation-110",
        "question": "Given the 2017 and 2018 financial reports provided by the firm, how does Jacques assess the Free Cash Flow to Equity (FCFE) of PZ Inc. for 2018, measured in millions?",
        "tables": [
            "\n|   |   | 2018 |   | 2017 |\n|---|---|------|---|------|\n|   |   |      |   |      |\n| Assets  |   |      |   |      |\n| Current assets |   |      |   |      |\n| Accounts receivable |   | 800  |   | 750  |\n| Inventories |   | 850  |   | 720  |\n| Gross fixed assets |   | 5000 |   | 4250 |\n| Accounts payable |   | $400  |   | $300 |\n| Accrued taxes and expenses  |  | 120  |   | 90  |\n| Notes payable  |  | 550  |   | 500  |\n| Long-term debt  |  | 1,500  |   | 1,400  |\n| Income Statement for the Year Ended 31 December 2018 |   |      |   |      |\n| EBITDA  |  |    |   | 2000 |\n| Depreciation expense  |   |    |   | 400 |\n| EBIT  |  |    |   | 1600 |\n| Interest expense  |  |    |   | 350 |\n| Pretax income  |  |    |   | 1250 |\n| Income tax (at 30 percent)  |  |    |   | 375 |\n| Net income  |   |    |   | $875 |\n"
        ],
        "python_solution": "def solution():\n    NI = 875 \n    NCC = 400 \n    FCInv = 750 \n    WCInv = 50 \n    Net_borrowing = 150 \n\n    FCFE = NI + NCC - FCInv - WCInv + Net_borrowing\n    return FCFE",
        "ground_truth": 625.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the Free Cash Flow to Equity (FCFE) for PZ Inc. for 2018, we would take the Net Income and add back non-cash charges, like Depreciation, then we adjust for changes in Working Capital, add cash from new debt borrowed and then subtract cash used to repay debt. However, we must be careful because the question doesn't provide us with all the typical information needed to calculate FCFE directly (such as CapEx or changes in net working capital).\n\nThe formula to calculate FCFE when we don't necessarily have CapEx or changes in net working capital is:\n\nFCFE = Net Income + Depreciation (non-cash charge) - ΔAccounts Receivable - ΔInventories + ΔAccounts Payable + (New Debt - Debt Repayment)\n\nNote that Δ (delta) means the change of a variable from 2017 to 2018.\n\nFrom the given information, we can use the Net Income of 2018, which would presumably be the same as that of 2017 since it's not provided for 2018. We'll also consider changes in Accounts Receivable, Inventories, and Accounts Payable from 2017 to 2018. We're also given the total long-term debt for both years, but no specific information about new debt or debt repayment. So we'll infer the change in long-term debt as (New Debt - Debt Repayment).\n\nNow let's write the Python program:\n\n```python\ndef solution():\n    # Define variables name and value\n    net_income = 875  # same as 2017 because 2018 is not provided\n    \n    # We need to calculate changes in receivables, inventories, and payables\n    change_in_receivables = 800 - 750\n    change_in_inventories = 850 - 720\n    change_in_payables = 400 - 300\n    \n    # Assuming depreciation remained the same as it was for 2017\n    depreciation_expense = 400\n    \n    # Calculate change in long-term debt\n    change_in_long_term_debt = 1500 - 1400\n    \n    # Net borrowing (since Notes Payable also represents debt, its change should be included)\n    change_in_notes_payable = 550 - 500\n    \n    # New Debt - Debt Repayment: Sum of long-term debt and notes payable changes\n    new_debt_net = change_in_long_term_debt + change_in_notes_payable\n    \n    # Do math calculation to get the answer\n    fcfe = (net_income + \n            depreciation_expense -\n            change_in_receivables -\n            change_in_inventories + \n            change_in_payables + \n            new_debt_net)\n    \n    # Return answer in millions (assuming all figures are already in millions)\n    return fcfe\n\n# Call the function to get the result\nprint(solution())\n```\n\nMake sure you run this Python function in an environment where Python is installed to get the result."
        ]
    },
    {
        "question_id": "validation-111",
        "question": "The investment manager, Allen, recently took on a new client named Peter. Peter has two primary assets: human capital ($1,200,000) and financial capital ($600,000). He wishes for his total portfolio to have a 30% allocation to stocks. Assuming that human capital is considered to be 25% similar to stocks, what should be the appropriate equity allocation for Peter's financial capital?",
        "tables": [],
        "python_solution": "def solution():\n    human_capital = 1200000\n    financial_capital = 600000\n    stock_allocation_goal = 0.3\n    human_capital_stock_pct = 0.25\n\n    total_portfolio = human_capital + financial_capital\n    target_stock_percentage = total_portfolio * stock_allocation_goal\n\n    human_capital_stock_alloc = human_capital * human_capital_stock_pct\n\n    financial_capital_stock_alloc = target_stock_percentage - human_capital_stock_alloc\n\n    return financial_capital_stock_alloc",
        "ground_truth": 240000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    human_capital = 1200000\n    financial_capital = 600000\n    total_portfolio = human_capital + financial_capital\n    desired_stock_allocation = 0.30\n    similarity_to_stocks = 0.25\n    \n    # Human capital considered as stock-like investment\n    human_capital_stock_like = human_capital * similarity_to_stocks\n    \n    # Calculate total stock value needed across the entire portfolio\n    total_stock_needed = total_portfolio * desired_stock_allocation\n    \n    # Subtract stock-like portion of human capital from total stock needed to find financial capital allocation\n    financial_capital_stock_allocation = total_stock_needed - human_capital_stock_like\n    \n    # Calculate the percentage of the financial capital that should be allocated to stocks\n    percentage_of_financial_capital_in_stocks = financial_capital_stock_allocation / financial_capital\n    \n    # return answer\n    return round(percentage_of_financial_capital_in_stocks, 2)\n    \n# Function Call\nprint(solution())\n```\n\nThe program defines variables for human capital, financial capital, the total portfolio, and the desired allocation to stocks. It then calculates the part of human capital that is like stocks and subtracts that from the desired stock allocation across the whole portfolio to determine the needed equity allocation for Peter's financial capital. Finally, it calculates the percentage allocation to stocks for the financial capital and rounds the result to two decimal places."
        ]
    },
    {
        "question_id": "validation-112",
        "question": "If a corporation switches from last-in, first-out (LIFO) to first-in, first-out (FIFO), how much higher would the net income (in $ thousands) for 2014 be, considering that the corporate tax rate for the current and all previous years has been 30% according to the data collected by a data analyst?",
        "tables": [
            "| ($ thousands)             |       | 2014 | 2013 |\n|---------------------------|-------|------|------|\n| Sales                     |       | 2125 | 2003 |\n| End of year inventories (LIFO) |       | 312  | 280  |\n| LIFO reserve              |       | 82   | 64   |\n| Net profit margin         |       | 4.9% | 4.0% |"
        ],
        "python_solution": "def solution():\n    net_profit_margin = 0.049\n    sales = 2125\n    tax_rate = 0.3\n    lifo_reserve_2014 = 82\n    lifo_reserve_2013 = 64\n\n    net_income_lifo = net_profit_margin * sales\n    change_in_lifo_reserve = lifo_reserve_2014 - lifo_reserve_2013\n    net_income_fifo = net_income_lifo + change_in_lifo_reserve * (1 - tax_rate)\n\n    increase_in_net_income = net_income_fifo - net_income_lifo\n\n    return increase_in_net_income",
        "ground_truth": 12.6,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Increase in LIFO reserve from 2013 to 2014\n    change_in_lifo_reserve = 82 - 64\n    \n    # corporate tax rate\n    tax_rate = 0.30\n    \n    # Do math calculation to get the answer\n    # Calculate the tax effect of the LIFO reserve change\n    tax_effect = change_in_lifo_reserve * (1 - tax_rate)\n    \n    # The net income will be higher by the after-tax increase in LIFO reserve\n    higher_net_income = tax_effect\n    \n    # return answer\n    return higher_net_income\n\n# Execute the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-113",
        "question": "If the 1-year spot rate is 1.02%, the 2-year spot rate is 1.65% and the 3-year spot rate stands at 2.15%, how would you compute the 1-year implied forward rate two years in the future?",
        "tables": [],
        "python_solution": "def solution():\n    S2 = 1.65 / 100\n    S3 = 2.15 / 100\n    f21 = ((1+S3)**3 / (1+S2)**2) - 1\n    return f21 * 100",
        "ground_truth": 3.157,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Spot rates are given in percentage, converting them to decimal for calculation\n    spot_rate_1yr = 1.02 / 100\n    spot_rate_2yr = 1.65 / 100\n    spot_rate_3yr = 2.15 / 100\n    \n    # Do math calculation to get the answer\n    # Using the formula: (1 + spot_rate_nyr)**n = (1 + spot_rate_(n-1)yr)**(n-1) * (1 + forward_rate_1yr_n-1)\n    # Solving for the 1-year forward rate two years from now:\n    forward_rate_1yr_2yr = ((1 + spot_rate_3yr)**3 / (1 + spot_rate_2yr)**2) - 1\n    \n    # Converting the result back to percentage\n    forward_rate_1yr_2yr_percentage = forward_rate_1yr_2yr * 100\n    \n    # return answer\n    return forward_rate_1yr_2yr_percentage\n\n# Calling the function and printing the result\nprint(solution())\n```\n\nThis program calculates the 1-year implied forward rate for the period starting two years from now based on the given spot rates. The forward rate is derived from the relationship between spot rates and future rates, and is expressed as a percentage."
        ]
    },
    {
        "question_id": "validation-114",
        "question": "Based on the BSM model, what is the value of the put option for company XYZ's stock, currently trading at $48.6? Presume that the volatility is 30%, the continuously compounded risk-free rate stands at 0.3%, we assume X is equal to 45, T equals 0.25, N(d1) is 0.6352 and N(d2) is 0.5486.",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    X = 45 # Strike Price\n    S = 48.6 # Stock Price\n    T = 0.25 # Time to maturity in years\n    r = 0.003 # Risk-free interest rate\n    Nd1 = 0.6352 # Value of cumulative standard normal distribution at d1\n    Nd2 = 0.5486 # Value of cumulative standard normal distribution at d2\n    Nd1_neg = 1 - Nd1 \n    Nd2_neg = 1 - Nd2 \n    \n    put_option_price = math.exp(-r * T) * X * Nd2_neg - S * Nd1_neg\n    \n    return put_option_price",
        "ground_truth": 2.568,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the value of the put option using the Black-Scholes-Merton (BSM) model, we need to apply the formula for a European put option, which is:\n\nP = Xe^(-rT)N(-d2) - SN(-d1)\n\nWhere:\n\n- P is the put option price.\n- S is the current stock price.\n- X is the strike price.\n- T is the time to expiration in years.\n- r is the continuously compounded risk-free interest rate.\n- N(d1) and N(d2) are the cumulative normal distribution functions for d1 and d2, respectively.\n- e is the base of the natural logarithm.\n\nThe values for N(-d1) and N(-d2) are simply (1 - N(d1)) and (1 - N(d2)), respectively, since N(-d) = 1 - N(d) for a standard normal distribution. Let's implement this calculation in Python:\n\n```python\nimport math\n\ndef solution():\n    # Given variables\n    S = 48.6               # Current stock price\n    X = 45                 # Strike price\n    T = 0.25               # Time to expiration in years\n    r = 0.003              # Continuously compounded risk-free rate\n    N_d1 = 0.6352          # N(d1)\n    N_d2 = 0.5486          # N(d2)\n    \n    # Calculate N(-d1) and N(-d2)\n    N_minus_d1 = 1 - N_d1\n    N_minus_d2 = 1 - N_d2\n    \n    # Calculate the put option price using the BSM formula\n    put_price = (X * math.exp(-r * T) * N_minus_d2) - (S * N_minus_d1)\n    \n    # Return the put option price\n    return put_price\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-115",
        "question": "What is the sample standard deviation from the following 10 measurements taken from a roughly normal group?",
        "tables": [
            "| Observation | 1  | 2   | 3 | 4   | 5  | 6  | 7  | 8 | 9 | 10  |\n|-------------|----|-----|---|-----|----|----|----|---|---|-----|\n| Value       | -3 | -11 | 3 | -18 | 18 | 20 | -6 | 9 | 2 | -16 |"
        ],
        "python_solution": "def solution():\n    import math\n    measurements = [-3, -11, 3, -18, 18, 20, -6, 9, 2, -16]\n    mean = sum(measurements) / len(measurements)\n    variance = sum((xi - mean) ** 2 for xi in measurements) / (len(measurements) - 1)\n    return math.sqrt(variance)",
        "ground_truth": 13.181,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "Here's a Python program that will calculate the sample standard deviation of the given measurements.\n\n```python\nimport math\n\ndef solution():\n    # Define variables name and values\n    values = [-3, -11, 3, -18, 18, 20, -6, 9, 2, -16]\n    n = len(values)  # Number of observations\n    \n    # Calculate the mean (average) of the values\n    mean = sum(values) / n\n    \n    # Calculate the variance\n    variance = sum((x - mean) ** 2 for x in values) / (n - 1)\n    \n    # Calculate the standard deviation (square root of variance)\n    std_deviation = math.sqrt(variance)\n    \n    # Return the answer\n    return std_deviation\n\n# For output purpose only, in practice you may call solution() and use its returned value\nprint(solution())\n```\n\nThe `solution` function calculates the sample standard deviation by first finding the mean of the sample. It then sums the squared differences between each value and the mean, divides by the number of observations minus one to get the sample variance, and finally takes the square root to find the sample standard deviation."
        ]
    },
    {
        "question_id": "validation-116",
        "question": "The reference weights and yields for each of the five stocks in the Olympia index are presented below. The Kurok Fund employs the Olympia Index as its benchmark, and the fund's portfolio weights are also outlined in the chart. What is the value added (active return) for the Kurok Fund?",
        "tables": [
            "| Stock | Portfolio Weight (%) | Benchmark Weight (%) | 2016 Return (%) |\n|-------|---------------------|----------------------|-----------------|\n| 1     | 30                  | 24                   | 14              |\n| 2     | 30                  | 20                   | 15              |\n| 3     | 20                  | 20                   | 12              |\n| 4     | 10                  | 18                   | 8               |\n| 5     | 10                  | 18                   | 10              |"
        ],
        "python_solution": "def solution():\n    portfolio_weights = [0.30, 0.30, 0.20, 0.10, 0.10]\n    portfolio_returns = [14, 15, 12, 8, 10]\n    benchmark_weights = [0.24, 0.20, 0.20, 0.18, 0.18]\n    benchmark_returns = [14, 15, 12, 8, 10]\n\n    portfolio_return = sum([weight * return_val for weight, return_val in zip(portfolio_weights, portfolio_returns)])\n    benchmark_return = sum([weight * return_val for weight, return_val in zip(benchmark_weights, benchmark_returns)])\n\n    active_return = portfolio_return - benchmark_return\n    \n    return active_return/100",
        "ground_truth": 0.009,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    stocks = [\n        {\"portfolio_weight\": 0.30, \"benchmark_weight\": 0.24, \"return\": 0.14},\n        {\"portfolio_weight\": 0.30, \"benchmark_weight\": 0.20, \"return\": 0.15},\n        {\"portfolio_weight\": 0.20, \"benchmark_weight\": 0.20, \"return\": 0.12},\n        {\"portfolio_weight\": 0.10, \"benchmark_weight\": 0.18, \"return\": 0.08},\n        {\"portfolio_weight\": 0.10, \"benchmark_weight\": 0.18, \"return\": 0.10},\n    ]\n    \n    # Calculate portfolio and benchmark returns\n    portfolio_return = sum(stock[\"portfolio_weight\"] * stock[\"return\"] for stock in stocks)\n    benchmark_return = sum(stock[\"benchmark_weight\"] * stock[\"return\"] for stock in stocks)\n    \n    # Calculate active return\n    active_return = portfolio_return - benchmark_return\n    \n    # return answer\n    return active_return\n\n# Call the function and print the result\nprint(solution())\n```\nThe `solution` function calculates the portfolio return and the benchmark return respectively, then computes the active return by subtracting the benchmark return from the portfolio return. The active return is the value added by the Kurok Fund compared to its benchmark, the Olympia Index."
        ]
    },
    {
        "question_id": "validation-117",
        "question": "An MBS made up of four distinct mortgage pools: $1 million of mortgages maturing in 30 days, $2 million of mortgages maturing in 90 days, $3 million of mortgages maturing in 180 days, and $4 million of mortgages maturing in 360 days, is owned by XYZ Inc. Could you calculate the weighted average maturity (WAM) for this MBS?",
        "tables": [],
        "python_solution": "def solution():\n    maturity_values = [30, 90, 180, 360] # in days\n    weights = [1, 2, 3, 4] # in million dollars\n    total_maturity = sum([maturity_values[i] * weights[i] for i in range(len(maturity_values))])\n    total_weight = sum(weights)\n    return total_maturity / total_weight",
        "ground_truth": 219.0,
        "topic": "Risk Management",
        "output": [
            "Here's the Python program to calculate the Weighted Average Maturity (WAM) of the MBS:\n\n```python\ndef solution():\n    # Define variables name and value\n    # Amount of mortgages and corresponding days to maturity\n    mortgages = {\n        '30_days': 1_000_000,\n        '90_days': 2_000_000,\n        '180_days': 3_000_000,\n        '360_days': 4_000_000\n    }\n    \n    # Total MBS value\n    total_mbs_value = sum(mortgages.values())\n    \n    # Calculate WAM\n    wam = sum(days * amount for days, amount in zip([30, 90, 180, 360], mortgages.values())) / total_mbs_value\n    \n    # return answer\n    return wam\n\n# You can also run the function and print the result to verify:\n# print(solution())\n```\nThis function will calculate the Weighted Average Maturity (WAM) for the MBS owned by XYZ Inc. by taking into account the different maturity terms and their respective mortgage amounts."
        ]
    },
    {
        "question_id": "validation-118",
        "question": "What is the value of the Paasche index for the consumption basket shown in Exhibit 1 for December?",
        "tables": [
            "| Date         |November 2010   |         | December 2010  |         |\n| -------------|:--------------:| -------:|:--------------:| -------:|\n| Goods        |Quantity        |Price    |Quantity        |Price    |\n| Sugar        |70kg            |C0.90/kg |120kg           |£1.00/kg |\n| Cotton       |60kg            |E0.60/kg |50kg            |€0.80/kg |"
        ],
        "python_solution": "def solution():\n    numerator = (120 * 1) + (50 * 0.8)\n    denominator = (120 * 0.9) + (50 * 0.6)\n    paasche_index = (numerator/denominator) * 100\n    return paasche_index",
        "ground_truth": 115.942,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # November 2010 (base period)\n    quantity_nov_sugar = 70\n    price_nov_sugar = 0.90\n    quantity_nov_cotton = 60\n    price_nov_cotton = 0.60\n    \n    # December 2010 (current period)\n    quantity_dec_sugar = 120\n    price_dec_sugar = 1.00\n    quantity_dec_cotton = 50\n    price_dec_cotton = 0.80\n    \n    # Calculate the total cost for the goods in the base period (November 2010)\n    total_cost_nov = (quantity_nov_sugar * price_nov_sugar) + (quantity_nov_cotton * price_nov_cotton)\n    \n    # Calculate the total cost for the goods in the current period using current period prices (December 2010)\n    total_cost_dec = (quantity_dec_sugar * price_dec_sugar) + (quantity_dec_cotton * price_dec_cotton)\n    \n    # Calculate the total cost for the goods in the current period using base period quantities (November 2010) and current period prices (December 2010)\n    total_cost_dec_with_base_qty = (quantity_nov_sugar * price_dec_sugar) + (quantity_nov_cotton * price_dec_cotton)\n    \n    # Calculate the Paasche index\n    # Paasche Price Index = (Σ(Current Period Price * Base Period Quantity) / Σ(Base Period Price * Base Period Quantity)) * 100\n    paasche_index = (total_cost_dec_with_base_qty / total_cost_nov) * 100\n    \n    # return answer\n    return paasche_index\n\n# Call the solution function to print the Paasche index value\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-119",
        "question": "Smith is a tax consultant who offers tax education advice to individual clients. One of Smith's clients is Sarah. Sarah wants Smith to examine Mutual Fund X, which has an embedded gain of 10% of the closing portfolio value. Sarah requests Smith to compute a post-liquidation return for the last three-year period. Mutual Fund X showed after-tax returns of 9.0% in the first year, 5% in the second year, and 8% in the third year, and capital gains are taxed at a 25% rate. What is the annualized after-tax post-liquidation return worked out by Smith?",
        "tables": [],
        "python_solution": "def solution():\n    # Given\n    returns = [0.09, 0.05, 0.08] # After-tax returns for the three years\n    tax_rate = 0.25 # Capital gains tax rate\n    embedded_gain = 0.10 # Embedded gain of the portfolio\n\n    # Calculate the final after-tax portfolio value\n    portfolio_value = 1\n    for r in returns:\n        portfolio_value *= (1 + r)\n\n    # Account for the unrealized capital gains\n    portfolio_value *= (1 - embedded_gain * tax_rate)\n\n    # Annualize the after-tax post-liquidation return\n    annualized_return = (portfolio_value ** (1 / len(returns))) - 1\n\n    return annualized_return*100 # Converting decimal return to percentage",
        "ground_truth": 6.418,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # The formula to calculate the compounded annual growth rate:\n    # CAGR = (EV / BV)^(1/n) - 1\n    # where:\n    # EV = ending value\n    # BV = beginning value\n    # n = number of periods\n\n    # Define the after-tax return for each year\n    after_tax_returns = [0.09, 0.05, 0.08]\n\n    # Define the embedded gain and the capital gains tax rate\n    embedded_gain_percent = 0.10\n    capital_gains_tax_rate = 0.25\n\n    # Calculate the after tax capital gains from the embedded gain\n    after_tax_embedded_gain = embedded_gain_percent * (1 - capital_gains_tax_rate)\n\n    # Calculate the compounded ending value (EV), starting with a base value (BV) of 1.0\n    compounded_value = 1.0\n    for annual_return in after_tax_returns:\n        # Adjust each year's return for the tax effects of the embedded gain\n        # Since the embedded gain is realized at liquidation, it affects all returns alike\n        adjusted_return = annual_return - (embedded_gain_percent * capital_gains_tax_rate)\n        compounded_value *= (1 + adjusted_return)\n\n    # Compounded value after liquidation\n    compounded_value *= (1 + after_tax_embedded_gain)\n\n    # Calculate the annualized post-liquidation return using the CAGR formula\n    years = 3\n    annualized_return = (compounded_value ** (1/years)) - 1\n\n    # Return the answer rounded to four decimal places to represent a percentage return\n    return round(annualized_return, 4)\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe `solution` function performs the necessary calculations to determine the compounded annual growth rate (CAGR) of the Mutual Fund X after adjusting for the tax effects of the capital gain. It applies the CAGR formula to the after-tax returns, taking into account the embedded gain that is taxed upon liquidation. The `for` loop accumulates the compounded value year over year, and the final return value is scaled back down to a rate of return in percentage form, rounded to four decimal places for accuracy."
        ]
    },
    {
        "question_id": "validation-120",
        "question": "Assuming the going rate for the base asset at present is $50, with the risk-free rate being 4%, and the contract ends in three months. If the current value of the advantages is $5, and the current value of the disadvantages is $6. What would be the forward price?",
        "tables": [],
        "python_solution": "def solution():\n    T = 3 / 12\n    s0 = 50\n    r = 0.04\n    q1 = 5\n    q2 = 6\n    \n    forward_price = s0 * ((1+r)**T) - ((q1 - q2) * ((1+r)**T))\n    \n    return forward_price",
        "ground_truth": 51.503,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value:\n    S0 = 50         # The current price of the asset\n    r = 0.04        # The risk-free rate (annualized)\n    T = 3 / 12      # The time to maturity of the forward contract in years\n    advantages = 5  # The present value of the advantages of holding the asset\n    disadvantages = 6  # The present value of the disadvantages of holding the asset\n    \n    # Calculate the forward price using the formula:\n    # Forward Price = (Spot Price + PV(Advantages) - PV(Disadvantages)) * e^(risk-free rate * time)\n    e_to_rt = (1 + r)**T  # It can also be done using the exp function from the math package for continuous compounding\n    F0 = (S0 + advantages - disadvantages) * e_to_rt\n    \n    # return answer\n    return F0\n\n# If you want to print the result you can call the solution function and print its result\nprint(solution())\n```\n\nThis code calculates the forward price by taking into account the spot price of the asset, the present values of the advantages and disadvantages of holding the asset, and adjusting for the risk-free interest rate over the time to maturity."
        ]
    },
    {
        "question_id": "validation-121",
        "question": "Currently, the Chinese Yuan is valued at 1.1757 in terms of the Hong Kong Dollar, and the Australian Dollar is valued at 5.0765 in terms of the Chinese Yuan. What is the cross rate for the Hong Kong Dollar to the Australian Dollar?",
        "tables": [],
        "python_solution": "def solution():\n    HKD_CNY = 1.1757\n    CNY_AUD = 5.0765\n    HKD_AUD = HKD_CNY * CNY_AUD\n    return HKD_AUD",
        "ground_truth": 5.968,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    yuan_to_hkd = 1.1757\n    aud_to_yuan = 5.0765\n    \n    # Do math calculation to get the answer\n    # To get the cross rate for the Hong Kong Dollar to the Australian Dollar, divide the HKD to Yuan rate by the AUD to Yuan rate\n    hkd_to_aud = yuan_to_hkd / aud_to_yuan\n    \n    # return answer\n    return hkd_to_aud\n\n# This will output the cross rate for the Hong Kong Dollar to the Australian Dollar\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-122",
        "question": "What's the cost of the annuity that has a YTM of 5.5% and pays out $100,000 annually for 40 years?",
        "tables": [],
        "python_solution": "def solution():\n    N = 40\n    PMT = 100000\n    I_Y = 5.5 / 100\n    \n    PV = PMT * ((1 - (1 + I_Y) ** -N) / I_Y)\n    \n    return PV",
        "ground_truth": 1604612.469,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport numpy_financial as npf\n\ndef solution():\n    # Define variables name and value\n    annual_payout = 100000\n    years = 40\n    ytm = 0.055  # YTM is given in percentage (5.5%)\n    \n    # Calculate the present value of the annuity\n    cost_of_annuity = npf.pv(rate=ytm, nper=years, pmt=-annual_payout, fv=0)\n    \n    # return answer\n    return cost_of_annuity\n\n# Note: You need numpy_financial package to run this program. Install it via pip if necessary.\n```\nThis program uses the numpy_financial module to calculate the cost of the annuity with the given Yield to Maturity (YTM) and annual payouts. The present value (pv) function computes the present value of a series of equal payments at regular intervals (annuity) given the interest rate (YTM in this case), number of periods (years), and future value (which is zero for this type of annuity). Note that the annual payout is negated in the `pmt` parameter because in financial calculations, cash outflows are typically represented as negative numbers."
        ]
    },
    {
        "question_id": "validation-123",
        "question": "What is the anticipated standard deviation for the following portfolio, assuming a correlation of 0.25 between the two securities?",
        "tables": [
            "| Security | Security Weight(%) | Expected Standard Deviation(%) |\n|----------|-------------------|--------------------------------|\n| 1        | 40                | 30                             |\n| 2        | 60                | 15                             |"
        ],
        "python_solution": "def solution():\n    w1 = 0.4\n    w2 = 0.6\n    sigma1 = 0.3\n    sigma2 = 0.15\n    rho = 0.25\n    sigma_port = ((w1**2 * sigma1**2) + (w2**2 * sigma2**2) + (2*w1*w2*sigma1*sigma2*rho))**0.5\n    return sigma_port*100",
        "ground_truth": 16.703,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "To calculate the anticipated standard deviation for the portfolio, we need to use the portfolio standard deviation formula, which is:\n\n\\[\n\\text{Portfolio Standard Deviation} = \\sqrt{(w_1 \\cdot \\sigma_1)^2 + (w_2 \\cdot \\sigma_2)^2 + 2 \\cdot w_1 \\cdot w_2 \\cdot \\sigma_1 \\cdot \\sigma_2 \\cdot \\rho}\n\\]\n\nWhere:\n- \\( w_1 \\) and \\( w_2 \\) are the weights of security 1 and security 2.\n- \\( \\sigma_1 \\) and \\( \\sigma_2 \\) are the standard deviations of security 1 and security 2.\n- \\( \\rho \\) is the correlation between the two securities.\n\nNow we can define the Python function and calculate the answer:\n```python\n# Import package if needs\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight1 = 0.40\n    weight2 = 0.60\n    std_dev1 = 0.30\n    std_dev2 = 0.15\n    correlation = 0.25\n    \n    # Do math calculation to get the answer\n    # Calculate each part of the equation\n    part1 = (weight1 * std_dev1) ** 2\n    part2 = (weight2 * std_dev2) ** 2\n    part3 = 2 * weight1 * weight2 * std_dev1 * std_dev2 * correlation\n    \n    # Calculate the portfolio standard deviation\n    portfolio_std_dev = math.sqrt(part1 + part2 + part3)\n    \n    # return answer\n    return portfolio_std_dev\n    \n# Test\nprint(solution())\n```\n\nLet's define the function without the test print statement:\n```python\n# Import package if needed\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight1 = 0.40\n    weight2 = 0.60\n    std_dev1 = 0.30\n    std_dev2 = 0.15\n    correlation = 0.25\n    \n    # Do math calculation to get the answer\n    # Calculate each part of the equation\n    part1 = (weight1 * std_dev1) ** 2\n    part2 = (weight2 * std_dev2) ** 2\n    part3 = 2 * weight1 * weight2 * std_dev1 * std_dev2 * correlation\n    \n    # Calculate the portfolio standard deviation\n    portfolio_std_dev = math.sqrt(part1 + part2 + part3)\n    \n    # return answer\n    return portfolio_std_dev\n```"
        ]
    },
    {
        "question_id": "validation-124",
        "question": "Given that an artwork was created and sold in 2015 for $1000, and the creation process cost $300. When computing GDP using the sum-of-value-added approach, what is the value of the final step in creating the artwork?",
        "tables": [],
        "python_solution": "def solution():\n    cost_of_artwork = 1000\n    cost_of_creation = 300\n    final_value = cost_of_artwork - cost_of_creation\n    return final_value",
        "ground_truth": 700.0,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    sale_price = 1000\n    creation_cost = 300\n    \n    # Do math calculation to get the answer\n    value_added_final_step = sale_price - creation_cost\n    \n    # return answer\n    return value_added_final_step\n    \n# The program can be tested by calling the solution function\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-125",
        "question": "What is the effective annual rate if the yearly rate for the stock market is 14.31% and it's compounded quarterly?",
        "tables": [],
        "python_solution": "def solution():\n    annual_rate = 0.1431\n    compounding_frequency = 4\n\n    ear = (1 + (annual_rate / compounding_frequency))**compounding_frequency - 1\n\n    return ear*100.0",
        "ground_truth": 15.096,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Import package if needed\nimport math\n\ndef solution():\n    # Define variables name and value\n    nominal_rate = 0.1431\n    compounded_times_per_year = 4\n    \n    # Do math calculation to get the answer\n    effective_annual_rate = (1 + nominal_rate / compounded_times_per_year)**compounded_times_per_year - 1\n    answer = effective_annual_rate\n    \n    # return answer\n    return answer\n\n# Note that it might be necessary to format the answer to a certain number of decimal places\n# depending on the context, for example, round(answer, 4) if 4 decimal places are required.\n```\nThis function will calculate the effective annual rate based on the nominal annual rate and the number of times the interest is compounded per year."
        ]
    },
    {
        "question_id": "validation-126",
        "question": "An investor from Australia currently manages an equity portfolio valued at A$240 million. He is contemplating adjusting the portfolio based on an evaluation of the risk and return possibilities confronting the Australian economy. The table below contains data pertaining to the Australian investment markets and the economic situation: Using the data in the table, determine the anticipated annual equity return using the Grinold–Kroner model (the number of outstanding shares is presumed to remain unchanged).",
        "tables": [
            "| 10-Year Historical | Current | Capital Market Expectations |\n|---|---|---|\n| Average government bond yield: 2.8% | 10-year government bond yield:2.3% | |\n| Average annual equity return: 4.6% | Year-over-year equity return:-9.4% | |\n| Average annual inflation rate: 2.3% | Year-over-year inflation rate:2.1% | Expected annual inflation: 2.3% |\n| Equity market P/E (beginning of period): 15x | Current equity market P/E: 14.5x | Expected equity market P/E: 14.0x |\n| Average annual dividend income return: 2.6% | | Expected annual income return: 2.4% |\n| Average annual real earnings growth: 6.0% | | Expected annual real earnings growth: 5.0% |"
        ],
        "python_solution": "def solution():\n    annual_income_return = 2.4 / 100\n    expected_annual_real_earning_growth = 5.0 / 100\n    expected_inflation_rate = 2.3 / 100\n    expected_nominal_earning_growth_return = expected_annual_real_earning_growth + expected_inflation_rate\n    expected_repricing_return = (14 - 14.5) / 14.5 \n    return annual_income_return + expected_nominal_earning_growth_return + expected_repricing_return",
        "ground_truth": 0.063,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # The Grinold–Kroner model: 'E(r) = D/P + i + g - ΔS + (ΔP/E)'\n    # where 'E(r)' is the expected return, 'D/P' is the dividend yield,\n    # 'i' is the expected inflation, 'g' is the real earnings growth,\n    # 'ΔS' is the change in shares outstanding (assumed to be zero),\n    # and 'ΔP/E' is the change in the P/E ratio.\n    \n    # Given values\n    dividend_yield = 2.4 / 100 # Convert percentage to a decimal\n    expected_inflation = 2.3 / 100 # Convert percentage to a decimal\n    real_earnings_growth = 5.0 / 100 # Convert percentage to a decimal\n    change_in_shares_outstanding = 0 # Delta S (Given that shares remain unchanged)\n    current_pe = 14.5\n    expected_pe = 14.0\n    change_in_pe = (expected_pe - current_pe) / current_pe # Delta P/E\n    \n    # Calculate the expected annual equity return using the Grinold–Kroner model\n    expected_annual_equity_return = dividend_yield + expected_inflation + real_earnings_growth - change_in_shares_outstanding + change_in_pe\n    \n    # return answer (convert it back to percentage)\n    return expected_annual_equity_return * 100 # Convert decimal to percentage\n\n# Call the function and print the result\nprint(f\"Expected annual equity return: {solution():.2f}%\")\n```\n\nThe above Python program defines the variables according to the Grinold–Kroner model and uses the current and expected figures to calculate the expected annual equity return. It then multiplies by 100 to convert the decimal representation to a percentage, consistent with how financial returns are typically expressed."
        ]
    },
    {
        "question_id": "validation-127",
        "question": "The variances of shares X and shares Y are 0.25 and 0.64 respectively, and the correlation between these two securities is 0.09. What is the covariance of the returns?",
        "tables": [],
        "python_solution": "def solution():\n    variance_X = 0.25\n    variance_Y = 0.64\n    correlation = 0.09\n    \n    covariance = correlation * (variance_X**0.5) * (variance_Y**0.5)\n    return covariance",
        "ground_truth": 0.036,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    variance_X = 0.25\n    variance_Y = 0.64\n    correlation_XY = 0.09\n    \n    # Do math calculation to get the covariance\n    standard_deviation_X = variance_X ** 0.5\n    standard_deviation_Y = variance_Y ** 0.5\n    covariance_XY = correlation_XY * standard_deviation_X * standard_deviation_Y\n    \n    # return answer\n    return covariance_XY\n\n# You can uncomment the following line to test the function:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-128",
        "question": "The effective annual return on an investment is 9%. What would be the return on a bond-equivalent basis?",
        "tables": [],
        "python_solution": "def solution():\n    EAR = 0.09\n    BEY = (pow((1 + EAR), 0.5) - 1) * 2\n    return BEY",
        "ground_truth": 0.088,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "The bond equivalent yield (BEY) for an investment is a method of converting the annual yield into a semi-annual bond yield. It assumes that the interest is compounded twice a year and calculates the equivalent yield given this assumption.\n\nIf an investment has an effective annual return (EAR) of 9%, the formula to calculate the bond equivalent yield is:\n\n\\[ \\text{BEY} = \\left(\\left(1 + \\text{EAR}\\right)^{1/2} - 1\\right) \\times 2 \\]\n\nGiven this information, let's write a Python program to calculate the bond equivalent yield for a 9% effective annual return.\n\n```python\ndef solution():\n    # Define variables name and value\n    effective_annual_return = 0.09\n    \n    # Do math calculation to get the answer\n    bond_equivalent_yield = ((1 + effective_annual_return)**0.5 - 1) * 2\n    \n    # return answer\n    return bond_equivalent_yield\n\n# Print the result for confirmation\nprint(f\"The bond equivalent yield is: {solution()}\")\n```\n\nRunning this program would calculate the bond equivalent yield for an effective annual return of 9%."
        ]
    },
    {
        "question_id": "validation-129",
        "question": "In 2016, Emily purchased a machine for $50,000 and its useful life is ten years. It has a residual value of $5,000. What is the depreciation of this machine in 2016 using the double-declining balance method?",
        "tables": [],
        "python_solution": "def solution():\n    cost_of_machine = 50000\n    useful_life = 10\n    residual_value = 5000\n    depreciation = cost_of_machine * (2/useful_life)\n    return depreciation",
        "ground_truth": 10000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cost = 50000  # Initial cost of the machine\n    residual_value = 5000  # Residual value of the machine\n    useful_life = 10  # Useful life of the machine in years\n    \n    # Calculate the depreciation rate using straight line method\n    straight_line_rate = 1 / useful_life\n    \n    # Double-declining balance rate is twice the straight-line rate\n    double_declining_rate = 2 * straight_line_rate\n\n    # Calculate depreciation for the first year\n    # Since it's the first year, we apply it on the full cost\n    first_year_depreciation = double_declining_rate * cost\n    \n    # return answer\n    return first_year_depreciation\n\n# Call the function and print the result\nprint(solution())\n```\nThe above program will calculate and print the depreciation of the machine in 2016 using the double-declining balance method."
        ]
    },
    {
        "question_id": "validation-130",
        "question": "If the exchange rate for the Euro (EUR) in London stands at GBP/EUR 0.8878, what would probably be the exchange rate for the British pound (GBP) in Frankfurt (EUR/GBP)?",
        "tables": [],
        "python_solution": "def solution():\n    gbp_eur = 0.8878\n    eur_gbp = 1 / gbp_eur\n    return eur_gbp",
        "ground_truth": 1.126,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    gbp_to_eur_rate = 0.8878\n\n    # Do math calculation to get the answer\n    # To convert the rate from GBP/EUR to EUR/GBP, we take the reciprocal (1 divided by the rate)\n    eur_to_gbp_rate = 1 / gbp_to_eur_rate\n    \n    # return answer\n    return eur_to_gbp_rate\n```"
        ]
    },
    {
        "question_id": "validation-131",
        "question": "If we assume an existing market risk-free rate of 4% annually, and the yield on the Corporation B bond is 6% annually, what is the inferred probability of default based on the current bond interest rate, presuming the market is fairly priced, and the recovery rate on the corporation's bonds is 70%?",
        "tables": [],
        "python_solution": "def solution():\n    risk_free_rate = 0.04\n    yield_corp_B_bond = 0.06\n    recovery_rate = 0.7\n\n    credit_spread = yield_corp_B_bond - risk_free_rate\n    LGD = 1 - recovery_rate\n    default_probability = credit_spread / LGD\n\n    return default_probability * 100",
        "ground_truth": 6.667,
        "topic": "Risk Management",
        "output": [
            "Here is a Python program that calculates the inferred probability of default as per the given scenario:\n\n```python\ndef solution():\n    # Define variables name and value\n    risk_free_rate = 0.04\n    corporate_bond_yield = 0.06\n    recovery_rate = 0.70\n    \n    # Do math calculation to get the inferred probability of default\n    # The formula used is: Probability of Default = (Yield - Risk-free rate) / (1 - Recovery rate)\n    probability_of_default = (corporate_bond_yield - risk_free_rate) / (1 - recovery_rate)\n\n    # return answer\n    return probability_of_default\n\n# Example usage\n# print(solution())\n```\n\nRunning `solution()` would give the inferred probability of default based on the current bond interest rate."
        ]
    },
    {
        "question_id": "validation-132",
        "question": "Analyst Johnson is determining the RAROC of a commercial loan portfolio for Company P. He has gathered the following details: The primary borrowing is $1.3 billion. The predicted pre-tax profit from the loan portfolio is 7%. The estimated direct annual operation cost is around $6 million. The loan portfolio is backed by $1.3 billion of consumer deposits and the interest rate is at 5%. Johnson is also predicting that the expected yearly loss on the portfolio is 0.3% of the principal. On top of this, Johnson estimates the unexpected loss on the principal amount could be as high as 8%. Further, Johnson takes into consideration that the risk-free rate is 1.5% and the effective tax rate is 25%. Finally, Johnson presumes there will not be any transfer pricing issues. Based off the definition of RAROC, what would Johnson's prediction about RAROC be?",
        "tables": [],
        "python_solution": "def solution():\n    principal = 1300000000\n    predicted_pre_tax_profit_rate = 7/100\n    operation_cost = 6000000\n    interest_rate = 5/100\n    expected_loss_rate = 0.3/100\n    unexpected_loss_rate = 8/100\n    risk_free_rate = 1.5/100\n    tax_rate = 25/100\n    \n    unexpected_loss = principal * unexpected_loss_rate\n    economic_capital = unexpected_loss\n    return_on_economic_capital = economic_capital * risk_free_rate\n    \n    expected_revenue = principal * predicted_pre_tax_profit_rate\n    interest_expense = principal * interest_rate\n    expected_loss = principal * expected_loss_rate\n    \n    RAROC = ((expected_revenue - operation_cost - expected_loss - interest_expense + return_on_economic_capital ) * (1-tax_rate)) / economic_capital\n    \n    return RAROC * 100",
        "ground_truth": 12.736,
        "topic": "Risk Management",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    principal_amount = 1300000000 # $1.3 billion\n    pre_tax_profit_percent = 7 # 7%\n    annual_op_cost = 6000000 # $6 million\n    deposit_interest_rate = 5 # 5%\n    expected_annual_loss_percent = 0.3 # 0.3%\n    unexpected_loss_percent = 8 # 8%\n    risk_free_rate_percent = 1.5 # 1.5%\n    effective_tax_rate_percent = 25 # 25%\n    \n    # Calculate the pre-tax profit\n    pre_tax_profit = principal_amount * (pre_tax_profit_percent / 100)\n    \n    # Calculate the interest expense on the deposits\n    interest_expense = principal_amount * (deposit_interest_rate / 100)\n    \n    # Calculate the expected loss\n    expected_loss = principal_amount * (expected_annual_loss_percent / 100)\n    \n    # Calculate the unexpected loss (capital at risk)\n    unexpected_loss = principal_amount * (unexpected_loss_percent / 100)\n    \n    # Calculate the tax on the pre-tax profit\n    tax = pre_tax_profit * (effective_tax_rate_percent / 100)\n    \n    # Calculate the after-tax risk-adjusted profit\n    after_tax_profit = pre_tax_profit - tax - annual_op_cost - interest_expense - expected_loss\n    \n    # Calculate the RAROC\n    raroc = (after_tax_profit / unexpected_loss) * 100\n    \n    # return RAROC\n    return raroc\n\n# Execute the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-133",
        "question": "An insurance firm projects that next year, 40% of clients with only a car insurance plan will renew it, and 70% of clients with only a house insurance plan will do the same. The firm also projects that 80% of clients with both a car and a house insurance plan will renew at least one of these plans next year. According to the firm's records, 70% of clients have a car insurance plan, 50% have a house insurance plan, and 20% have both types of plans. Based on these estimates by the firm, what is the percentage of clients that will renew at least one plan next year?",
        "tables": [],
        "python_solution": "def solution():\n    PAH = 0.20\n    PAHc = 0.70 - PAH\n    AcH = 0.50 - PAH\n    res = 0.40 * PAHc + 0.70 * AcH + 0.80 * PAH\n    return res * 100",
        "ground_truth": 57.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    prob_car_only_renew = 0.4\n    prob_house_only_renew = 0.7\n    prob_both_renew_at_least_one = 0.8\n    \n    prob_car_insurance = 0.7\n    prob_house_insurance = 0.5\n    prob_both_insurance = 0.2\n    \n    # Calculate the probabilities for each insurance category\n    prob_car_only = prob_car_insurance - prob_both_insurance\n    prob_house_only = prob_house_insurance - prob_both_insurance\n    \n    # Use the law of total probability to calculate the percentage of clients that will renew at least one plan\n    prob_renew_at_least_one = (prob_car_only * prob_car_only_renew + \n                               prob_house_only * prob_house_only_renew +\n                               prob_both_insurance * prob_both_renew_at_least_one)\n    \n    # Multiply by 100 to get the percentage\n    answer = prob_renew_at_least_one * 100\n    \n    # return answer\n    return round(answer, 2)\n\n# This is to call the function and print the output\npercentage_renewal = solution()\nprint(f\"The percentage of clients that will renew at least one plan next year is: {percentage_renewal}%\")\n```\n\nRemember that this code should be run in a Python environment to get the result. When run, it will calculate the percentage of clients that will renew at least one insurance plan next year, based on the information provided."
        ]
    },
    {
        "question_id": "validation-134",
        "question": "The following spot and forward rates are provided: Present 1-year spot rate is 6%. The one-year forward rate one year from now is 8%. The one-year forward rate two years from now is 10%. What is the worth of a 3-year, 10% annually paid, bond with a par value of $1000?",
        "tables": [],
        "python_solution": "def solution():\n    bond_value = 100 / (1.06) + 100 / ((1.06) * (1.08)) + 1100 / ((1.06) * (1.08) * (1.1))\n    return int(bond_value)",
        "ground_truth": 1055.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Given values\n    spot_rate_year_1 = 0.06\n    forward_rate_year_2 = 0.08\n    forward_rate_year_3 = 0.10\n    coupon_rate = 0.10\n    par_value = 1000\n\n    # Present value of coupon payments and par value\n    # Coupon Payments\n    coupon_payment = coupon_rate * par_value  # Coupon payment each year\n    pv_coupon_year_1 = coupon_payment / (1 + spot_rate_year_1)\n    pv_coupon_year_2 = coupon_payment / ((1 + spot_rate_year_1) * (1 + forward_rate_year_2))\n    pv_coupon_year_3 = coupon_payment / ((1 + spot_rate_year_1) * (1 + forward_rate_year_2) * (1 + forward_rate_year_3))\n\n    # Par Value\n    pv_par_value = par_value / ((1 + spot_rate_year_1) * (1 + forward_rate_year_2) * (1 + forward_rate_year_3))\n\n    # Sum of present value of coupons and par value\n    bond_value = pv_coupon_year_1 + pv_coupon_year_2 + pv_coupon_year_3 + pv_par_value\n    \n    # return answer\n    return bond_value\n\n# Call the function and print the result\nprint(f\"The worth of the bond is: ${solution():.2f}\")\n```\n\nThis Python program calculates the present value of each coupon payment and the par value discounted back to the present at the spot and forward rates given. Then it sums these values to get the worth of the bond."
        ]
    },
    {
        "question_id": "validation-135",
        "question": "If Allison, a CFA, was revising her company's estimates for US equity returns and thought that over time the growth of the US labor input would be 0.9% per year and labor productivity would increase by 1.5%, inflation would stand at 2.1%, the dividend yield would be 2.25%, and the P/E growth would be nonexistent, what was probably her benchmark forecast for continuously compounded long-term US equity returns?",
        "tables": [],
        "python_solution": "def solution():\n    growth_of_labor_input = 0.9\n    labor_productivity_increase = 1.5\n    inflation = 2.1\n    dividend_yield = 2.25\n    \n    baseline_projection = growth_of_labor_input + labor_productivity_increase + inflation + dividend_yield\n\n    return baseline_projection/100",
        "ground_truth": 0.068,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\n# No additional package needed for this calculation\ndef solution():\n    # Define variables based on given information\n    growth_labor_input = 0.009\n    growth_labor_productivity = 0.015\n    inflation = 0.021\n    dividend_yield = 0.0225\n    pe_growth = 0.0  # nonexistent P/E growth\n    \n    # Gordon Equation indicates that equity returns = dividend yield + dividend growth rate.\n    # Given that growth in dividends is likely to follow growth in earnings,\n    # we can estimate dividend growth rate as the sum of labor input and labor productivity growth rates.\n    \n    # To find the real return we subtract inflation from nominal return\n    real_growth_rate = growth_labor_input + growth_labor_productivity\n    \n    # The nominal return will be real growth rate plus inflation\n    nominal_return = real_growth_rate + inflation\n    \n    # The total nominal return including dividends will then be the sum of the nominal return and the dividend yield.\n    total_nominal_return = nominal_return + dividend_yield\n    \n    # Because the forecast is for a continuously compounded return, we can use the natural logarithm\n    # `ln` to find the answer. Given that the natural logarithm of the growth component (1 + nominal return)\n    # is approximately equal to the nominal return when the rates are small, we can simplify the calculation.\n    \n    # The continuously compounded return is approximately the total_nominal_return\n    continuously_compounded_return = total_nominal_return\n    \n    # return answer\n    return continuously_compounded_return\n\n# Call the solution function and print out the answer\nprint(solution())\n```\n\nThis program defines the given variables such as growth of the US labor input, labor productivity, inflation, dividend yield, and P/E growth (which is non-existent). It uses the Gordon Equation to calculate the expected equity returns by adding the growth rates (labor input growth and labor productivity growth) and the dividend yield. Since the return is supposed to be continuously compounded, it assumes that the natural log of 1 plus the nominal return is approximately equal to the return rate itself when the rates are small, so it simplifies the calculation by treating the total nominal return as the continuously compounded return."
        ]
    },
    {
        "question_id": "validation-136",
        "question": "If an $100 million retirement fund has 80% in equity with a beta of 1.2, how many stock index futures would need to be purchased to change the allocation to 60% in equity? This assumes a stock index value of 1,200, a multiplier of $250, and a beta of 0.95.",
        "tables": [],
        "python_solution": "def solution():\n    target_equity = 0.60\n    initial_equity = 0.80\n    portfolio_value = 100000000\n    futures_value = 1200 * 250\n    beta_stock = 1.2\n    beta_future = 0.95\n    delta_equity = (target_equity - initial_equity) * portfolio_value\n    delta_beta = (0 - beta_stock)/beta_future\n    futures_contracts = delta_beta * (delta_equity/futures_value)\n    return int(futures_contracts)",
        "ground_truth": 84.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is the Python program to calculate the number of stock index futures contracts needed:\n\n```python\ndef solution():\n    # Define variables name and value\n    retirement_fund = 100e6  # $100 million\n    current_equity_percentage = 0.80  # 80%\n    target_equity_percentage = 0.60  # 60%\n    current_equity_beta = 1.2\n    equity_value_to_reduce = retirement_fund * (current_equity_percentage - target_equity_percentage)\n    \n    index_value = 1200  # stock index value\n    multiplier = 250  # multiplier for index futures\n    future_beta = 0.95  # beta of stock index futures\n    \n    # Calculate the number of futures contracts required\n    # First, calculate the portfolio beta adjustment required\n    portfolio_delta_beta = equity_value_to_reduce * current_equity_beta - equity_value_to_reduce * future_beta\n    # Then calculate the number of futures contracts needed\n    num_futures_contracts = portfolio_delta_beta / (index_value * multiplier * future_beta)\n    \n    # Round up to the nearest whole contract as you can't trade fractions of contracts\n    num_futures_contracts = round(num_futures_contracts)\n    \n    # return answer\n    return num_futures_contracts\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nThis program defines variables for the current size of the retirement fund, the target equity allocation, and various properties of the stock index futures. Then it uses these variables to calculate the number of futures contracts needed to adjust the equity allocation and rounds to the nearest whole number because you cannot purchase a fraction of a futures contract."
        ]
    },
    {
        "question_id": "validation-137",
        "question": "According to the analyst's data within the context of the capital asset pricing model, if the anticipated return for Share B is 11.4% and the risk-free rate is 3%, what is the projected return for the market?",
        "tables": [
            "| Security | Expected Standard Deviation(%) | Beta |\n|----------|-------------------------------|------|\n| Security 1 | 25 | 1.50 |\n| Security 2 | 15 | 1.40 |\n| Security 3 | 20 | 1.60 |"
        ],
        "python_solution": "def solution():\n    risk_free_rate = 3.0\n    expected_return_share_b = 11.4\n    beta = 1.4\n    market_risk_premium = (expected_return_share_b - risk_free_rate) / beta\n    return risk_free_rate + market_risk_premium",
        "ground_truth": 9.0,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    security_return = 0.114  # Expected return of Security B (11.4%)\n    beta_security = 1.40     # Beta of Security B\n    risk_free_rate = 0.03    # Risk-free rate (3%)\n    \n    # Calculate the expected market return using CAPM\n    # CAPM formula: security_return = risk_free_rate + beta_security * (market_return - risk_free_rate)\n    # Rearrange to solve for market_return: market_return = (security_return - risk_free_rate) / beta_security + risk_free_rate\n    market_return = (security_return - risk_free_rate) / beta_security + risk_free_rate\n    \n    # return answer\n    return market_return\n\n# Perform the function and print the result for demonstration purposes\nresult = solution()\nprint(f\"The projected market return is: {result:.4f} or {result*100:.2f}%\")\n```\n\nThis code defines function `solution()` which calculates the projected return of the market based on the Capital Asset Pricing Model (CAPM). The expected return of Security B (11.4%), its beta value (1.40), and the risk-free rate (3%) are the inputs. The function performs the calculation required to determine the market return and then returns the result. \n\nIn the final lines, the function is called and the result is printed, formatted as a float and as a percentage for readability."
        ]
    },
    {
        "question_id": "validation-138",
        "question": "What should be the total cost reported on the balance sheet for the scientific equipment that Corporation BMT bought for its product development?",
        "tables": [
            "| Purchase price | $32,500 |\n| -------------- | ------- |\n| Freight and insurance | $2,100 |\n| Installation  | $800 |\n| Testing | $500 |\n| Training staff on maintaining machine | $1000 |"
        ],
        "python_solution": "def solution():\n    equipment_cost = 32500\n    delivery_cost = 2100 \n    installation_cost = 800\n    testing_cost = 500\n    total_cost = equipment_cost + delivery_cost + installation_cost + testing_cost\n    return total_cost",
        "ground_truth": 35900.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    purchase_price = 32500\n    freight_and_insurance = 2100\n    installation = 800\n    testing = 500\n    training_staff = 1000\n    \n    # Do math calculation to get the total cost\n    total_cost = purchase_price + freight_and_insurance + installation + testing + training_staff\n    \n    # return answer\n    return total_cost\n\n# The code is ready to be executed, and when called, it will return the total cost.\n```"
        ]
    },
    {
        "question_id": "validation-139",
        "question": "According to the financial information of a PE fund named XZY Corporation with a carried interest rate of 20%, and which has a total pledged capital of $100 million. At the end of the last year, the total paid-in capital was $90 million while $30 million was the total distributions given to LPs. The value of year-end NAV, both before and after distributions, stood at $160 million and $130 million respectively. Their projected NAV before any distributions for the next year is $250 million. What is their forecasted carried interest for the next year?",
        "tables": [],
        "python_solution": "def solution():\n    committed_capital = 100\n    nav_before_distribution = 250\n    nav_before_distribution_prev = 160\n    carried_interest_rate = 20 / 100\n    if nav_before_distribution > committed_capital:\n        carried_interest = (nav_before_distribution - nav_before_distribution_prev) * carried_interest_rate\n        return carried_interest\n    else:\n        return 0",
        "ground_truth": 18.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    carried_interest_rate = 0.20\n    projected_year_end_NAV = 250000000  # $250 million\n    initial_commitment = 100000000  # $100 million\n    year_end_NAV_after_distributions = 130000000  # $130 million\n    total_paid_in_capital = 90000000  # $90 million\n\n    # Calculate hurdle rate (typically the initial commitment)\n    hurdle_rate = initial_commitment\n    \n    # Calculate profit (projected NAV before distributions - initial commitment)\n    profit = projected_year_end_NAV - total_paid_in_capital\n    \n    # Calculate carried interest if profit exceeds hurdle rate\n    if profit > hurdle_rate:\n        carried_interest = (profit - hurdle_rate) * carried_interest_rate\n    else:\n        carried_interest = 0\n\n    # return answer\n    return carried_interest\n\n# Call the function and print the result\nprint(solution())\n```\n\nThe provided program defines the required variables and follows the steps to calculate the forecasted carried interest for the next year. It ensures that carried interest is only paid on the profit exceeding the paid-in capital which acts as a hurdle. If the profit exceeds this hurdle, the carried interest is calculated as 20% of the profit above the total paid-in capital."
        ]
    },
    {
        "question_id": "validation-140",
        "question": "What will be the worth of $75,000 invested now for six years at an annual interest rate of 7% compounded quarterly?",
        "tables": [],
        "python_solution": "def solution():\n    PV = 75000\n    r = 0.07\n    N = 6\n    m = 4\n\n    FV = PV * (1 + r/m)**(m*N)\n    \n    return int(FV) # rounding down intentionally as per the requirements.",
        "ground_truth": 113733.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# Import package if needed\ndef solution():\n    # Define variables name and value\n    principal = 75000\n    annual_interest_rate = 0.07\n    times_compounded_per_year = 4\n    years = 6\n    \n    # Calculate the future value with the compound interest formula\n    future_value = principal * ((1 + (annual_interest_rate / times_compounded_per_year)) ** (times_compounded_per_year * years))\n    \n    # return answer\n    return future_value\n\n# Note: The returned value will be the future value of the investment.\n```"
        ]
    },
    {
        "question_id": "validation-141",
        "question": "Based on the information given in the chart, what is the deferred tax liability (in millions) at the end of 2014 for a firm that has newly appraised a depreciable asset, predicting its remaining lifespan will be an additional 20 years? The tax rate for all the years is 30% and note that tax laws do not recognize the asset's revaluation.",
        "tables": [
            "| Original Values and Estimates (millions) | Accounting Purposes | Tax Purposes |\n| ---------------------------------------- | ------------------- | ------------ |\n| Acquisition cost in 2011                | £8,000              | £8,000       |\n| Depreciation, straight line              | 20 years            | 8 years      |\n| Accumulated depreciation, end of 2013   | £1,200              | £3,000       |\n| Net balance, end of 2013                | £6,800              | £5,000       |\n| **Re-estimated Values and Estimates, Start of 2014** |               |              |\n| Revaluation balance, start of 2014      | £10,000             | Not applicable |\n| New estimated life                      | 20 years            |              |"
        ],
        "python_solution": "def solution():\n    tax_rate = 0.30\n    tax_base = 4000\n    carrying_amount = 6300\n    deferred_tax_liability = tax_rate * (carrying_amount - tax_base)\n    return deferred_tax_liability",
        "ground_truth": 690.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    tax_rate = 0.30\n    revaluation_balance_start_2014 = 10000\n    net_balance_end_2013_accounting = 6800\n    net_balance_end_2013_tax = 5000\n    \n    # Accounting purpose depreciation for 2014\n    new_estimated_life = 20\n    annual_depreciation_accounting = revaluation_balance_start_2014 / new_estimated_life\n    \n    # Accumulated depreciation at the end of 2014 for accounting\n    accumulated_depreciation_end_2014_accounting = net_balance_end_2013_accounting - (revaluation_balance_start_2014 - annual_depreciation_accounting)\n    \n    # Accumulated depreciation for tax purpose\n    annual_depreciation_tax = 8000 / 8\n    accumulated_depreciation_end_2014_tax = 3000 + annual_depreciation_tax\n    \n    # Net balance at end of 2014 for accounting and tax purpose\n    net_balance_end_2014_accounting = revaluation_balance_start_2014 - accumulated_depreciation_end_2014_accounting\n    net_balance_end_2014_tax = 8000 - accumulated_depreciation_end_2014_tax\n    \n    # Calculate temporary difference\n    temporary_difference = net_balance_end_2014_accounting - net_balance_end_2014_tax\n    \n    # Calculate deferred tax liability\n    deferred_tax_liability = temporary_difference * tax_rate\n    \n    # return answer\n    return deferred_tax_liability\n\n# Call the function and print the returned value\nprint(solution())\n```\n\nThe above program will calculate the deferred tax liability using the information provided in the table."
        ]
    },
    {
        "question_id": "validation-142",
        "question": "What is the standard deviation of sales for an organization, given its probability distribution?",
        "tables": [
            "| Probability | Sales ($ millions) |\n|-------------|--------------------|\n| 0.05        | 70                 |\n| 0.70        | 40                 |\n| 0.25        | 25                 |"
        ],
        "python_solution": "def solution():\n    # defining probabilities and sales\n    prob = [0.05, 0.70, 0.25]\n    sales = [70, 40, 25]\n\n    # calculating expected sales\n    expected_sales = sum(p*s for p, s in zip(prob, sales))\n\n    # calculating variance\n    variance = sum(p*((s - expected_sales) ** 2) for p, s in zip(prob, sales))\n\n    # computing the standard deviation\n    std_dev = variance ** 0.5\n\n    return std_dev",
        "ground_truth": 9.808,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    probabilities = [0.05, 0.70, 0.25]\n    sales = [70, 40, 25]  # Multiply by a million not necessary for standard deviation calculation\n    \n    # Calculate expected value (mean)\n    expected_value = sum(p * s for p, s in zip(probabilities, sales))\n    \n    # Calculate the variance\n    variance = sum(p * ((s - expected_value) ** 2) for p, s in zip(probabilities, sales))\n    \n    # Calculate the standard deviation\n    std_deviation = math.sqrt(variance)\n    \n    # return answer\n    return std_deviation\n\n# Call the function and print the answer\nprint(solution())\n```\nThis program calculates the standard deviation of sales for an organization given its probability distribution. The standard deviation is a measure of the amount of variation or dispersion of a set of values. The expected value (mean) of the sales is calculated first, followed by the variance and then taking the square root of the variance to get the standard deviation."
        ]
    },
    {
        "question_id": "validation-143",
        "question": "XYZ SF, a home decor retailing corporation, provides its workers with a defined benefit retirement plan. The company's contributions stand at 1,200. The PBO at the start of the year was 45,000 and by the end of the year, it was 43,500. The plan's assets were valued at 40,800 at the start and 39,650 at the end of the year. Can you compute the overall recurring pension cost utilizing this provided data?",
        "tables": [],
        "python_solution": "def solution():\n    ending_funded_status = 39650 - 43500\n    beginning_funded_status = 40800 - 45000\n    company_contribution = 1200\n    tppc = ending_funded_status - beginning_funded_status - company_contribution\n    return abs(tppc)",
        "ground_truth": 850.0,
        "topic": "Accounting",
        "output": [
            "Certainly! The formula to calculate the overall recurring pension cost (service cost) is:\n\nPension Expense = Contributions - (End of year PBO - Start of year PBO) - (End of year Plan Assets - Start of year Plan Assets)\n\nwhere PBO stands for Projected Benefit Obligation.\n\nHere is the Python program to calculate the overall recurring pension cost using the data provided:\n\n```python\ndef solution():\n    # Define variables name and value\n    contributions = 1200\n    start_year_pbo = 45000\n    end_year_pbo = 43500\n    start_year_plan_assets = 40800\n    end_year_plan_assets = 39650\n    \n    # Do math calculation to get the answer\n    pension_expense = contributions - ((end_year_pbo - start_year_pbo) + (start_year_plan_assets - end_year_plan_assets))\n    \n    # return answer\n    return pension_expense\n\n# Uncomment the following line to test the function\n# print(solution())\n```\n\nThis program calculates the pension expense based on the contribution to the plan and the changes in the PBO and plan assets over the year."
        ]
    },
    {
        "question_id": "validation-144",
        "question": "John oversees a fund, with the returns for the first three years displayed below: What will be the holding period return?",
        "tables": [
            "| Year | Investment | Return |\n|------|------------|--------|\n| 1    | $500       | 12%    |\n| 2    | $600       | 5%     |\n| 3    | $1000      | 1%     |"
        ],
        "python_solution": "def solution():\n    HPR = (1.12 * 1.05 * 1.01) - 1\n    return HPR * 100",
        "ground_truth": 18.776,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    original_investment = 500\n    additional_investments = [600, 1000]\n    returns_percentage = [0.12, 0.05, 0.01]\n\n    # Calculate total investment\n    total_investment = original_investment + sum(additional_investments)\n    \n    # Calculate investment return for each year and total return\n    investment_return_first_year = original_investment * returns_percentage[0]\n    investment_return_second_year = additional_investments[0] * returns_percentage[1]\n    investment_return_third_year = additional_investments[1] * returns_percentage[2]\n    total_return = investment_return_first_year + investment_return_second_year + investment_return_third_year\n\n    # Calculate holding period return\n    holding_period_return = total_return / total_investment\n    \n    # return answer\n    return holding_period_return\n\n# Run the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-145",
        "question": "Taking into account the provided data, what number of shares should be applied when figuring out the business' diluted EPS? The business had 60,000 common shares out in the open all through the year and also had 5,000 outstanding warrants throughout the entire year, each can be converted into share at $25 per share. The stock's price at the end of year was $30, and the average stock price for the year of the business was $20.",
        "tables": [],
        "python_solution": "def solution():\n    common_shares = 60000\n    warrants = 5000\n    exercise_price = 25\n    avg_price = 20\n\n    if avg_price < exercise_price:\n        return common_shares\n    else:\n        return common_shares + warrants\n    return common_shares",
        "ground_truth": 60000.0,
        "topic": "Accounting",
        "output": [
            "To calculate the number of shares to be applied when figuring out the business's diluted earnings per share (EPS), we need to use the treasury stock method for the warrants. Here's how we can do this:\n\n1. Calculate the funds that the company would receive if all the warrants were exercised. This is done by multiplying the number of warrants by the exercise price per share.\n2. Determine the number of shares that could be repurchased with these funds at the average market price. We find this by dividing the total funds received by the average stock price for the year.\n3. The incremental number of shares is the difference between the number of shares that would be issued if the warrants were exercised and the number of shares that could be repurchased.\n\nFinally, we add the incremental number of shares to the common shares for the diluted EPS calculation.\n\nHere's the corresponding Python program:\n\n```python\ndef solution():\n    # Define variables\n    common_shares_outstanding = 60000\n    outstanding_warrants = 5000\n    exercise_price_per_warrant = 25\n    average_stock_price = 20\n    \n    # Calculate funds company would receive if all warrants were exercised\n    funds_from_warrant_exercise = outstanding_warrants * exercise_price_per_warrant\n    \n    # Calculate the number of shares that could be repurchased\n    shares_repurchased = funds_from_warrant_exercise / average_stock_price\n    \n    # Calculate the incremental number of shares for diluted EPS\n    incremental_shares = outstanding_warrants - shares_repurchased\n    \n    # Calculate total shares for diluted EPS\n    shares_for_diluted_EPS = common_shares_outstanding + incremental_shares\n    \n    # Return the number of shares for diluted EPS\n    return shares_for_diluted_EPS\n\n# Feel free to test the function or adjust as needed\nanswer = solution()\nprint(f\"The number of shares to be used in the diluted EPS calculation: {answer}\")\n```\nPlease test the function to ensure it meets your requirements."
        ]
    },
    {
        "question_id": "validation-146",
        "question": "Louis is working on the valuation for XY Corporation, a producer and supplier of red wine that recently purchased a large bottling firm to expand its product range. This purchase will greatly influence XY's future outcomes. Knowing that XY projected EPS and Current share price are $2 and $40 respectively, what would be the most suitable price-to-earnings ratio to apply in the valuation of XY?",
        "tables": [],
        "python_solution": "def solution():\n    current_price = 40\n    projected_EPS = 2\n    PE_ratio = current_price / projected_EPS\n    return PE_ratio",
        "ground_truth": 20.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is the Python program to calculate the price-to-earnings ratio for XY Corporation:\n\n```python\ndef solution():\n    # Define variables name and value\n    projected_EPS = 2\n    current_share_price = 40\n    \n    # Calculate the Price-to-Earnings (P/E) Ratio\n    pe_ratio = current_share_price / projected_EPS\n    \n    # Return the P/E ratio\n    return pe_ratio\n\n# You can call the function and print the returned value to check the result\n# print(solution())\n```\nThis program calculates the P/E ratio by dividing the current share price by the projected earnings per share (EPS). The resultant value is the price-to-earnings ratio."
        ]
    },
    {
        "question_id": "validation-147",
        "question": "Given the following performance figures for a substitute investment. Presume the highest drawdown risk remains consistent at 10.2% per time period. Also assume the mean drawdown risk remains constant at 6.8% per time period. Based on this information, can you work out the Calmar ratio using the conventional method? What does the Calmar ratio turn out to be?",
        "tables": [
            "| 1 Year | 3 Years | 5 Years | Since Inception |\n|--------|---------|---------|-----------------|\n| 5.3%   | 6.2%    | 4.7%    | 4.4%            |"
        ],
        "python_solution": "def solution():\n    average_compounded_return = 6.2\n    maximum_drawdown = 10.2\n    calmar_ratio = average_compounded_return / maximum_drawdown\n    return calmar_ratio",
        "ground_truth": 0.608,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly! Given that the Calmar ratio is typically calculated by dividing the annual rate of return by the maximum drawdown, here's how you could create a python program to calculate the Calmar ratio based on the provided performance figures and assuming that the \"Since Inception\" rate is an annual rate:\n\n```python\ndef solution():\n    # Define variables name and value\n    annual_rate_of_return = 4.4  # Since Inception annual rate in percent\n    max_drawdown = 10.2  # Maximum drawdown risk in percent\n    \n    # Do math calculation to get the Calmar ratio\n    calmar_ratio = annual_rate_of_return / max_drawdown\n    \n    # return answer\n    return calmar_ratio\n\n# Example usage:\ncalmar_ratio_result = solution()\nprint(\"The Calmar ratio is {:.2f}\".format(calmar_ratio_result))\n```\n\nThis program will calculate the Calmar ratio using the \"Since Inception\" performance figure as the annual rate of return and 10.2% as the maximum drawdown risk. The `.2f` in the format string will round the result to two decimal places when printing it out."
        ]
    },
    {
        "question_id": "validation-148",
        "question": "Bloomfield informs Smith that he observed 500 shares of BYYP stock being traded every 20 minutes for a duration of an hour. He also tells Smith that he saw a similar trading pattern in the stock during the previous trading day. Bloomfield instructs Smith to place an order to buy BYYP stock, assuming that a trader is looking for liquidity and is executing a large purchase order by dividing it into smaller parts. Based on Exhibit 1, what is the average effective spread of the BYYP transactions?",
        "tables": [
            "| Trade | Trade Price | Prevailing Bid | Prevailing Offer |\n|-------|-------------|----------------|------------------|\n| 1     | 41.50       | 41.45          | 41.50            |\n| 2     | 41.75       | 41.73          | 41.75            |"
        ],
        "python_solution": "def solution():\n    trade1_price = 41.50\n    trade1_midpoint = 41.475\n    trade2_price = 41.75\n    trade2_midpoint = 41.74\n    \n    effective_spread_trade1 = 2 * (trade1_price - trade1_midpoint)\n    effective_spread_trade2 = 2 * (trade2_price - trade2_midpoint)\n    \n    average_effective_spread = (effective_spread_trade1 + effective_spread_trade2) / 2\n    \n    return average_effective_spread",
        "ground_truth": 0.035,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Here's the program that calculates the average effective spread of the BYYP transactions:\n\n```python\ndef solution():\n    # Define variables name and value\n    # Trade prices and prevailing bids and offers from the table\n    trades = [\n        {'trade_price': 41.50, 'prevailing_bid': 41.45, 'prevailing_offer': 41.50},\n        {'trade_price': 41.75, 'prevailing_bid': 41.73, 'prevailing_offer': 41.75},\n    ]\n    \n    # Initialize total effective spread\n    total_effective_spread = 0.0\n    \n    # Do math calculation to get the total effective spread\n    for trade in trades:\n        # midpoint for each trade\n        midpoint = (trade['prevailing_bid'] + trade['prevailing_offer']) / 2\n        # effective spread for each trade (difference between trade price and midpoint) multiplied by 2\n        effective_spread = abs(trade['trade_price'] - midpoint) * 2\n        # add to total effective spread\n        total_effective_spread += effective_spread\n        \n    # calculate the average effective spread by dividing by the number of trades\n    average_effective_spread = total_effective_spread / len(trades)\n    \n    # return answer\n    return average_effective_spread\n\n# Call the function and print the answer\nprint(solution())\n```\n\nThis program will calculate the average effective spread for the trades listed in the table by first computing the midpoint of the bid and offer prices for each trade, then the effective spread for each trade, summing these spreads, and finally dividing by the number of trades to get the average."
        ]
    },
    {
        "question_id": "validation-149",
        "question": "If a never-ending preferred share starts its initial three-monthly payout of $2.00 in five quarters, and the annual rate of yield needed is 6% compounding every quarter, what is the current value of the share?",
        "tables": [],
        "python_solution": "def solution():\n    A = 2.0\n    r = 0.06 / 4\n    N = 4\n    FV = A / r\n    PV = FV / ((1 + r) ** N)\n    return int(PV)",
        "ground_truth": 125.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\n# We do not need any external packages for this calculation\ndef solution():\n    # Define variables name and value\n    dividend_per_period = 2.00  # The three-monthly (quarterly) payout\n    required_rate_of_return = 0.06  # The annual rate of yield (compounded quarterly)\n    periods_per_year = 4  # Number of quarters in a year\n    \n    # Calculate the quarterly rate of return\n    quarterly_rate_of_return = (1 + required_rate_of_return)**(1/periods_per_year) - 1\n    \n    # Calculate the current value, using the formula for a perpetuity: PV = C / r\n    # Since the payouts start in five quarters, we need to discount it back to the present value\n    present_value_perpetuity = dividend_per_period / quarterly_rate_of_return\n    present_value = present_value_perpetuity / ((1 + quarterly_rate_of_return)**5)\n    \n    # return answer\n    return present_value\n\n# Example usage:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-150",
        "question": "If Corporation B purchases a license for $6,500, intending to utilize it for four years but expecting to gain benefits from it for only three years and applying the straight-line amortization method, what would be the accumulated amortization at the conclusion of Year 2?",
        "tables": [],
        "python_solution": "def solution():\n    license_cost = 6500\n    useful_years = 3\n    year = 2\n    annual_amortization = license_cost / useful_years\n    accumulated_amortization = annual_amortization * year\n    return accumulated_amortization",
        "ground_truth": 4333.333,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    license_cost = 6500\n    useful_life = 3 # years\n\n    # Do math calculation to get the answer\n    annual_amortization_expense = license_cost / useful_life\n    accumulated_amortization_end_year_2 = annual_amortization_expense * 2  # At the end of the second year\n\n    # return answer\n    return accumulated_amortization_end_year_2\n\n# You can call the function to get the result\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-151",
        "question": "A buyer is thinking about acquiring a common share that comes with a $2.00 yearly dividend. The dividend is predicted to increase at a pace of 4 percent every year. If the buyer’s necessary return rate is 7 percent, what would be the inherent worth of the share?",
        "tables": [],
        "python_solution": "def solution():\n    D0 = 2.00\n    g = 0.04\n    r = 0.07\n    D1 = D0 * (1 + g)\n    V0 = D1 / (r - g)\n    return V0",
        "ground_truth": 69.333,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    dividend = 2.00\n    growth_rate = 0.04\n    required_return_rate = 0.07\n    \n    # Do math calculation to get the answer\n    # Using the Gordon Growth Model formula\n    intrinsic_value = dividend / (required_return_rate - growth_rate)\n    \n    # return answer\n    return intrinsic_value\n\n# Function call to validate the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-152",
        "question": "In the previous quarter, we noted the market share data of various businesses as follows: Based on this information, what is the concentration ratio of the four firms?",
        "tables": [
            "| Company   | Sales(in millions of€) |\n|-----------|-----------------------|\n| Ajiwo     | 500                   |\n| Bdfhyj    | 350                   |\n| Cegfd     | 270                   |\n| Ddgh      | 200                   |\n| Ebned     | 150                   |\n| All others| 40                    |"
        ],
        "python_solution": "def solution():\n    total_market_share = 500 + 350 + 270 + 200 + 150 + 40\n    top_4_firms_share = 500 + 350 + 270 + 200\n    concentration_ratio = top_4_firms_share / total_market_share\n    return concentration_ratio * 100",
        "ground_truth": 87.417,
        "topic": "Market Analysis & Economics",
        "output": [
            "To calculate the concentration ratio of the four firms, we need the sales of the top four firms and sum them up. The concentration ratio is then this sum divided by the total market sales. The concentration ratio is simply the percentage of the market controlled by the top X firms, in this case, four.\n\nHere is the Python program that calculates the concentration ratio of the four firms:\n\n```python\ndef solution():\n    # Define variables name and value\n    sales = {\n        'Ajiwo': 500,\n        'Bdfhyj': 350,\n        'Cegfd': 270,\n        'Ddgh': 200,\n        'Ebned': 150,\n        'All_others': 40\n    }\n    \n    # Get the sales of the top four firms\n    top_four_firms_sales = sorted(sales.values(), reverse=True)[:4]\n    \n    # Calculate total market sales\n    total_market_sales = sum(sales.values())\n    \n    # Calculate concentration ratio\n    concentration_ratio = sum(top_four_firms_sales) / total_market_sales\n    \n    # return answer\n    return concentration_ratio\n\n# You can call the function and print the result to check\nprint(solution())\n```\n\nThis program defines the sales values, calculates the sum of the top four firms' sales, calculates the total market sales, and finally, calculates the concentration ratio. The result should be a decimal value which, when converted to a percentage, represents the market share of the top four firms."
        ]
    },
    {
        "question_id": "validation-153",
        "question": "The KY corporation is a company based in the US with US GAAP. It also has two subsidiaries in Europe: ZX financial service and CO financial consultant. Simon, CFA, has put together a forecast for KY's 2018 financial statement: Simon predicts that ZX financial service will have 3,500 in sales and 1,500 in cost of sales in 2018. If KY decides to employ the current rate method to translate the results of subsidiary ZX into US dollars, could you calculate the gross profit margin for 2018?",
        "tables": [
            "|   | Forecasted Balance Sheet Data for Ll at 31 December 2018 |\n|---|--------------------------------------------------------|\n| Cash | 120 |\n| Accounts receivable | 30 |\n| Inventory | 450 |\n| Fixed assets | 800 |\n| Total assets | 1,400 |\n| Liabilities | 320 |\n| Common stock | 780 |\n| Retained earning | 300 |",
            "|                               | Exchange rates ($/€) |\n|-------------------------------|----------------------|\n| when fixed assets were acquired | 1.55                 |\n| 31 December 2018               | 1.77                 |\n| 2018 average                    | 1.68                 |"
        ],
        "python_solution": "def solution():\n    sales = 3500\n    cost_of_sales = 1500\n\n    gross_profit = sales - cost_of_sales\n    gross_profit_margin = gross_profit / sales\n    \n    return gross_profit_margin",
        "ground_truth": 0.571,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and values\n    sales = 3500\n    cost_of_sales = 1500\n    exchange_rate = 1.77  # The current rate method uses the year-end exchange rate\n\n    # Translate the results of subsidiary ZX into US dollars using the current rate method\n    sales_usd = sales * exchange_rate\n    cost_of_sales_usd = cost_of_sales * exchange_rate\n\n    # Calculate gross profit in US dollars\n    gross_profit_usd = sales_usd - cost_of_sales_usd\n\n    # Calculate gross profit margin\n    gross_profit_margin = gross_profit_usd / sales_usd\n\n    # return answer\n    return gross_profit_margin\n    \n# Call the function to check the result\nprint(\"The Gross Profit Margin for 2018 is:\", solution())\n```\n\nThis program calculates the gross profit margin for ZX financial service for 2018, translating the sales and cost of sales into US dollars using the current rate method, and then computes the gross profit margin based on those values."
        ]
    },
    {
        "question_id": "validation-154",
        "question": "Considering the events recorded in 2014, what was the net cash flow from investing activities for the firm, as shown on the 2014 cash flow statement (in thousands)?",
        "tables": [
            "|             | $ thousands |\n|-------------|-------------|\n| Purchase of securities for trading purposes | 240 |\n| Proceeds from the sale of trading securities | 300 |\n| Proceeds from issuance of bonds | 500 |\n| Purchase of 30% of the shares of an affiliated company | 275 |"
        ],
        "python_solution": "def solution():\n    purchase_affiliated_company = -275000\n    net_cash_flow = purchase_affiliated_company\n    return net_cash_flow/1000",
        "ground_truth": -275.0,
        "topic": "Accounting",
        "output": [
            "Here is the Python program that calculates the net cash flow from investing activities for the firm:\n\n```python\ndef solution():\n    # Define variables name and value\n    purchase_of_securities = -240  # negative because it's an outflow\n    proceeds_from_sale_of_securities = 300  # positive because it's an inflow\n    proceeds_from_issuance_of_bonds = 0  # not an investing activity\n    purchase_of_shares_of_affiliated_company = -275  # negative because it's an outflow\n    \n    # Do math calculation to get the answer\n    # Net cash flow from investing activities is the sum of all investing cash flows\n    net_cash_flow_investing = (purchase_of_securities + \n                               proceeds_from_sale_of_securities + \n                               purchase_of_shares_of_affiliated_company)\n    \n    # return answer\n    return net_cash_flow_investing\n\n# Call the function and print the result\nprint(solution())\n```\n\nRunning this program will compute and provide the net cash flow from investing activities, which includes the purchase of securities and shares of an affiliated company as cash outflows, and the sale of trading securities as a cash inflow. The proceeds from the issuance of bonds are excluded as they are a financing activity, not an investing one."
        ]
    },
    {
        "question_id": "validation-155",
        "question": "Given the details about stock market fluctuations, with a 38% chance of it going up, a 46% chance of it staying the same, and a 16% chance of it falling, what is the likelihood that the stock's value will be at $45?",
        "tables": [
            "\n|              | Market continues to rise |      |      | Market unchanges |      |      | Market continues to decline |      |      |\n|--------------|--------------------------|------|------|------------------|------|------|------------------------------|------|------|\n| stock price  | $25                      | $45  | $60  | $25              | $45  | $60  | $25                          | $45  | $60  |\n| probability  | 5%                       | 65%  | 30%  | 35%              | 55%  | 9%   | 62%                          | 38%  | 0%   |\n"
        ],
        "python_solution": "def solution():\n    probability_up = 0.38 * 0.65\n    probability_same = 0.46 * 0.56\n    probability_down = 0.16 * 0.38\n    total_probability = probability_up + probability_same + probability_down\n    return total_probability * 100",
        "ground_truth": 56.54,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Probabilities of market condition\n    p_rise = 0.38\n    p_unchanged = 0.46\n    p_decline = 0.16\n    \n    # Probabilities of stock price given the market condition\n    p_45_given_rise = 0.65\n    p_45_given_unchanged = 0.55\n    p_45_given_decline = 0.38\n    \n    # Do math calculation to get the answer\n    # Applying total probability theorem\n    p_45 = (p_45_given_rise * p_rise) + (p_45_given_unchanged * p_unchanged) + (p_45_given_decline * p_decline)\n    \n    # Return answer\n    return p_45\n\n# Call the function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-156",
        "question": "In a repurchase agreement, Company X sells a bond with a face value of $10 million to Company Y on August 1, with an invoice price of $11 million for a 20-day period. Concurrently, Company X consents to reacquire the $10 million worth bond at a price equal to the initial invoice price plus an interest calculated at a repo rate of 20%. Based on the provided details, what is the repurchase cost?",
        "tables": [],
        "python_solution": "def solution():\n    face_value = 10  # face value of the bond in million\n    invoice_price = 11  # invoice price of the bond in million\n    repo_rate = 20 / 100  # repo rate\n    time_period = 20  # time period in days\n\n    repurchase_cost = invoice_price * (1 + repo_rate * time_period / 360)  # calculation of repurchase cost\n    return repurchase_cost  # return repurchase cost",
        "ground_truth": 11.122,
        "topic": "Risk Management",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_invoice_price = 11000000  # $11 million\n    face_value_of_bond = 10000000     # $10 million\n    repo_rate = 0.20                  # 20% annual interest rate\n    repo_period_days = 20             # 20-day period\n    \n    # Calculate the interest for the repo period\n    # Interest = Principal * Rate * Time (in years)\n    interest_for_period = initial_invoice_price * repo_rate * (repo_period_days / 365)\n    \n    # Calculate the repurchase cost: initial invoice price + interest\n    repurchase_cost = initial_invoice_price + interest_for_period\n    \n    # return answer\n    return repurchase_cost\n    \n# To get the result, you can call the solution function\nprint(solution())\n```\n\nWhen executed, this Python program will calculate the repurchase cost for Company X based on the details supplied."
        ]
    },
    {
        "question_id": "validation-157",
        "question": "Business B announced and distributed cash dividends worth $8 million and an impairment expense of $12 million in 2017. They categorized the dividend payment as a financing activity. What is the value of Business B's operating cash flow for 2017 (in $ millions)?",
        "tables": [
            "| Balances as of Year Ended 31 December | 2016 | 2017 |\n| --- | --- | --- |\n| Retained earnings | 110 | 125 |\n| Accounts receivable | 45 | 48 |\n| Inventory | 24 | 20 |\n| Accounts payable | 30 | 33 |"
        ],
        "python_solution": "def solution():\n    REB = 0\n    NI = 23\n    Div = 0\n    REE = 0\n    impairment = 12\n    AR_change = (48-45)\n    Inv_change = (20-24)\n    AP_change = (33-30)\n    CFO = NI + impairment - AR_change - Inv_change + AP_change\n    return CFO",
        "ground_truth": 39.0,
        "topic": "Accounting",
        "output": [
            "To calculate the operating cash flow for Business B for the year 2017, we can utilize the indirect method of cash flow calculation, which begins with net income and adjusts for changes in balance sheet items.\n\nGiven:\n- Dividends are categorized as a financing activity, so they don't affect operating cash flow.\n- An impairment expense of $12 million is a non-cash charge and needs to be added back to net income.\n\nThe increase in retained earnings (from $110 million to $125 million) is the net income for 2017, but we need to adjust this for the dividends paid and impairment expense. Then we would adjust for changes in working capital (accounts receivable, inventory, and accounts payable).\n\n```python\ndef solution():\n    # Provided data\n    beginning_retained_earnings = 110\n    ending_retained_earnings = 125\n    dividends_paid = 8\n    impairment_expense = 12\n    \n    # Changes in working capital accounts\n    beginning_accounts_receivable = 45\n    ending_accounts_receivable = 48\n    beginning_inventory = 24\n    ending_inventory = 20\n    beginning_accounts_payable = 30\n    ending_accounts_payable = 33\n    \n    # Calculation\n    # Compute net income by adding dividends and impairment expense back to ending retained earnings,\n    # and then subtracting the beginning retained earnings\n    net_income = (ending_retained_earnings + dividends_paid + impairment_expense) - beginning_retained_earnings\n    \n    # Adjustments for changes in working capital\n    change_in_receivables = beginning_accounts_receivable - ending_accounts_receivable\n    change_in_inventory = beginning_inventory - ending_inventory\n    change_in_payables = ending_accounts_payable - beginning_accounts_payable\n    \n    # Calculate the operating cash flow\n    operating_cash_flow = net_income + change_in_receivables + change_in_inventory + change_in_payables\n    \n    # Return the value of Business B's operating cash flow for 2017 in millions\n    return operating_cash_flow\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program will calculate the operating cash flow for Business B for the year 2017 by applying changes in retained earnings, dividends, impairment expense, and changes in working capital."
        ]
    },
    {
        "question_id": "validation-158",
        "question": "Suppose the number of defective vehicles adheres to the Possion distribution. Also, suppose that 5% of the vehicles arriving at the production line are defective. Then, if you randomly pick 5 vehicles on the production line, what's the likelihood that one is defective?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    n = 5\n    p = 0.05\n    lambda_ = n * p\n    k = 1\n    probability = ((lambda_ ** k) * math.exp(-lambda_)) / math.factorial(k)\n    return probability",
        "ground_truth": 0.195,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom scipy.stats import poisson\n\ndef solution():\n    # Define variables\n    defect_rate = 0.05  # 5% defect rate\n    vehicles_picked = 5  # total number of vehicles picked\n    \n    # The expected number of defective vehicles when picking 5 is 5 * 5% = 0.25\n    # We want the probability of getting exactly one defective vehicle\n    probability_one_defective = poisson.pmf(1, vehicles_picked * defect_rate)\n    \n    # return answer\n    return probability_one_defective\n    \n# Test the function\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-159",
        "question": "What is the projected price value of a basis point for a bond that provides a 3% coupon rate with yearly coupons, has nine years until maturity, a yield-to-maturity of 5%, and is valued at 85.784357 per 100 of par value?",
        "tables": [],
        "python_solution": "def solution():\n    coupon_rate = 3\n    maturity_years = 9\n    yield_to_maturity = 5\n    bond_value = 85.784357\n\n    PV_minus = sum([coupon_rate/(1 + (yield_to_maturity - 0.01)/100)**i for i in range(1, maturity_years+1)])\n    PV_minus += 100/(1 + (yield_to_maturity - 0.01)/100)**maturity_years\n\n    PV_plus = sum([coupon_rate/(1 + (yield_to_maturity + 0.01)/100)**i for i in range(1, maturity_years+1)])\n    PV_plus += 100/(1 + (yield_to_maturity + 0.01)/100)**maturity_years\n\n    PVBP = (PV_minus - PV_plus) / 2\n\n    return PVBP",
        "ground_truth": 0.065,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Certainly, to calculate the projected price value of a basis point (PVBP) for a bond, one can use the following approach:\n\n1. Determine the current price of the bond.\n2. Calculate the price if the yield were one basis point (0.01%) higher.\n3. The difference between the two prices is the price value of a basis point (PVBP).\n\nHere's the Python code to implement this:\n\n```python\nimport numpy as np\n\ndef solution():\n    # Define variables name and value\n    face_value = 100  # par value of a bond\n    coupon_rate = 0.03  # 3% coupon rate\n    coupons_per_year = 1  # yearly coupons\n    years_to_maturity = 9\n    current_yield = 0.05  # 5% yield-to-maturity\n    price_per_100 = 85.784357\n    basis_point = 0.0001  # one basis point\n\n    # Calculate the current price in terms of the bond's face value\n    current_price = face_value * price_per_100 / 100\n\n    # Calculate the bond's cash flows (coupon payments and par value at maturity)\n    cash_flows = np.full((years_to_maturity * coupons_per_year,), coupon_rate * face_value)\n    cash_flows[-1] += face_value  # Add the par value to the last cash flow\n\n    # Calculate the bond price for a yield one basis point higher\n    yield_higher = current_yield + basis_point\n    discount_factors_higher_yield = [(1 / (1 + yield_higher / coupons_per_year)) ** (i+1) for i in range(years_to_maturity * coupons_per_year)]\n    price_higher_yield = sum(cash_flows * discount_factors_higher_yield)\n\n    # Calculate the projected price value of a basis point (PVBP)\n    pvbp = current_price - price_higher_yield\n\n    # return answer\n    return pvbp\n\n# Call the function and print the answer\nprint(solution())\n```\n\nThis code uses NumPy for array operations and to create an array of uniform coupon payments. It calculates the current price of the bond, the price if the yield-to-maturity were one basis point higher, and then takes the difference to find the PVBP. Note that PVBP is also known as DV01 (Dollar Value of One Basis Point) or BPV (Basis Point Value) in financial terms."
        ]
    },
    {
        "question_id": "validation-160",
        "question": "Suppose a community has an established average of 1,000. Imagine that 1,600 samples are randomly selected (with replacement) from this community. The average of these observed samples turns out to be 998.7, and their standard deviation is 100. What is the standard error of the sample mean?",
        "tables": [],
        "python_solution": "def solution():\n    sample_std_dev = 100\n    n = 1600\n    std_error = sample_std_dev / (n ** 0.5)\n    return std_error",
        "ground_truth": 2.5,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    standard_deviation = 100\n    sample_size = 1600\n    \n    # Do math calculation to get the standard error of the sample mean\n    standard_error = standard_deviation / math.sqrt(sample_size)\n    \n    # return answer\n    return standard_error\n\n```"
        ]
    },
    {
        "question_id": "validation-161",
        "question": "The Smith family has an investment portfolio that is comprised of $500,000 in stocks and $330,000 in fixed income products. The Smiths also own a house valued at $350,000, with $175,000 still owed on the mortgage. The total present value of their earnings before they retire is estimated to be $980,000, and the future expected consumption is projected to be worth $870,000 at present. The Smiths have plans to cover their children's college tuition costs amounting to $150,000 at present value. They also wish to establish a family foundation in 25 years, projected to be worth $600,000 at present. Using the information provided, prepare an economic balance sheet for the Smith family. Determine their economic net worth.",
        "tables": [],
        "python_solution": "def solution():\n    equity = 500000\n    fixed_income = 330000\n    residence = 350000\n    pre_retirement_earnings = 980000\n\n    mortgage_debt = 175000\n    consumption = 870000\n    tuition_fee = 150000\n    foundation = 600000\n\n    total_economic_assets = equity + fixed_income + residence + pre_retirement_earnings\n    total_economic_liabilities = mortgage_debt + consumption + tuition_fee + foundation\n    economic_net_worth = total_economic_assets - total_economic_liabilities\n    return economic_net_worth",
        "ground_truth": 365000.0,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    stock_value = 500000\n    fixed_income_value = 330000\n    house_value = 350000\n    mortgage_debt = 175000\n    present_value_of_earnings = 980000\n    present_value_of_consumption = 870000\n    college_tuition = 150000\n    foundation_value = 600000\n    \n    # Assets calculation\n    total_assets = stock_value + fixed_income_value + house_value + present_value_of_earnings\n    \n    # Liabilities calculation\n    total_liabilities = mortgage_debt + present_value_of_consumption + college_tuition + foundation_value\n    \n    # Net Worth calculation\n    net_worth = total_assets - total_liabilities\n    \n    # return the net worth\n    return net_worth\n\n# Execute the function and print the Economic Net Worth\nprint(f\"The Smith family's economic net worth is: ${solution()}\")\n```\n\nYou can run this Python program to determine the Smith family's economic net worth based on the provided economic balance sheet items."
        ]
    },
    {
        "question_id": "validation-162",
        "question": "The products were sold to clients by XYZ Corporation on 30 June 2006 for an overall cost of €10,000. The sale conditions stipulate that the payment must be finalized within 30 days. The goods had a cost value of €8,000. What is the probable net shift in XYZ Corporation's total assets on 30 June 2006 due to this sale?",
        "tables": [],
        "python_solution": "def solution():\n    sales_price = 10000\n    cost_price = 8000\n    net_increase_assets = sales_price - cost_price\n    return net_increase_assets",
        "ground_truth": 2000.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    sales_value = 10000\n    cost_of_goods_sold = 8000\n    \n    # Do math calculation to get the answer\n    # On the day of the sale (30 June 2006), XYZ Corporation's accounts receivable will increase by the sales amount\n    # But the inventory will decrease by the cost of the goods sold\n    # The net shift in total assets is the increase in accounts receivable minus the decrease in inventory (cost of goods sold)\n    net_shift = sales_value - cost_of_goods_sold\n    \n    # return answer\n    return net_shift\n    \n# Call the function and print the answer\nprint(solution())\n```\n\nThis program calculates the probable net shift in XYZ Corporation's total assets on 30 June 2006 due to the sale. It assumes that there are no other transactions affecting total assets on that day. The increase in accounts receivable is offset by the decrease in inventory, and the difference between the sales value and the cost of goods sold will be the net shift."
        ]
    },
    {
        "question_id": "validation-163",
        "question": "Assuming a tax rate of 35%, if a business is 60% financed by debt and has an equity beta of 1.4, what would be the asset beta of that business?",
        "tables": [],
        "python_solution": "def solution():\n    tax_rate = 0.35\n    debt_ratio = 0.60\n    equity_beta = 1.4\n    debt_to_equity_ratio = debt_ratio/(1 - debt_ratio)\n    asset_beta = equity_beta / (1 + ((1 - tax_rate)*debt_to_equity_ratio))\n    return asset_beta",
        "ground_truth": 0.709,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "Here is the Python program to calculate the asset beta:\n\n```python\ndef solution():\n    # Define variables\n    tax_rate = 0.35\n    debt_ratio = 0.60\n    equity_beta = 1.4\n    equity_ratio = 1 - debt_ratio  # Since the financing is either debt or equity\n\n    # Calculate the unlevered beta (asset beta)\n    asset_beta = equity_beta / (equity_ratio + (debt_ratio * (1 - tax_rate)))\n\n    # Return the asset beta\n    return asset_beta\n\n# You can call the function and print the result if you want to test the output\n# print(solution())\n```\n\nThis script defines the tax rate, debt-to-equity financing ratio, and equity beta. It then calculates the equity ratio (which is the remainder of 100% minus the debt ratio). Finally, it computes the asset beta using the formula for unlevering a company's beta. The asset beta is also known as the unlevered beta, which reflects the risk of the business's assets without the impact of its capital structure."
        ]
    },
    {
        "question_id": "validation-164",
        "question": "A retirement fund worth $100 million currently consists of 80% shares and 20% bonds. The beta of the shares section is 1.2, with the term of the bonds part being 5.0. How many stock index futures need to be purchased in order to shift the distribution to 60% shares and 40% bonds? Refer to the additional data: The value of the stock index stands at 1,200, the multiplier is $250, and the beta equals 0.95. The cost of a bond futures agreement is $105,300, which carries an underlying adjusted duration of 6.5.",
        "tables": [],
        "python_solution": "def solution():\n    current_value = 100000000\n    current_shares_value = 0.8 * current_value\n    target_shares_value = 0.6 * current_value\n    shares_value_to_be_shifted = current_shares_value - target_shares_value\n    beta_shares = 1.2\n    beta_stock_index = 0.95\n    stock_index_value = 1200\n    contract_price = 250\n    number_of_contracts = (0-beta_shares/beta_stock_index)*(shares_value_to_be_shifted/(stock_index_value * contract_price))\n    return int(number_of_contracts)",
        "ground_truth": -84.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here's a Python program that calculates how many stock index futures need to be purchased:\n\n```python\ndef solution():\n    # Define variables name and value\n    total_fund = 100000000\n    current_shares_percent = 0.80\n    target_shares_percent = 0.60\n    current_shares_value = total_fund * current_shares_percent\n    target_shares_value = total_fund * target_shares_percent\n    index_value = 1200\n    multiplier = 250\n    beta_shares = 1.2\n    beta_futures = 0.95\n\n    # Calculate the difference in the equity position\n    equity_position_change = target_shares_value - current_shares_value\n\n    # Compute the adjusted beta to desired beta\n    adjusted_beta = beta_shares - (target_shares_percent / current_shares_percent) * beta_futures\n\n    # Calculate the number of futures required\n    number_of_futures = equity_position_change / (index_value * multiplier) * beta_shares / adjusted_beta\n\n    # Return answer\n    return round(number_of_futures)\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis program calculates the amount that needs to be adjusted in the shares portfolio and the number of index futures contracts that need to be purchased to achieve the desired beta and portfolio composition. It accounts for the difference in beta between the existing equity position and the beta of the futures contracts. At the end, the program returns the rounded result since you cannot buy a fraction of a futures contract."
        ]
    },
    {
        "question_id": "validation-165",
        "question": "Assuming a 30% marginal tax rate and an additional 5% risk premium for shares as opposed to bonds, what is the cost of equity using the bond-yield-plus-risk-premium method for a 20-year, $1,000 non-callable bond with 8% annual coupons that is presently valued at $1,105.94?",
        "tables": [],
        "python_solution": "def solution():\n    # Define constants\n    risk_premium = 5\n    yield_to_maturity = 7\n\n    # Calculate cost of equity\n    cost_of_equity = yield_to_maturity + risk_premium\n    return cost_of_equity",
        "ground_truth": 12.0,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "Here is a Python program that calculates the cost of equity using the bond-yield-plus-risk-premium method:\n\n```python\ndef solution():\n    # Given values\n    tax_rate = 0.30\n    risk_premium = 0.05\n    bond_price = 1105.94\n    face_value = 1000\n    coupon_rate = 0.08\n    years_to_maturity = 20\n    \n    # Calculate the annual coupon payment\n    annual_coupon_payment = face_value * coupon_rate\n    \n    # Calculate yield to maturity (YTM) using the approximation formula\n    # The formula for YTM is complex and requires iterative methods to solve. However,\n    # an approximate method is to take the average of the current yield and the yield\n    # to maturity at par, assuming coupon payments are reinvested at the YTM.\n    # This approximation should be sufficient for the purpose of this program,\n    # where a precise value isn't needed for the cost of equity calculation.\n    current_yield = annual_coupon_payment / bond_price\n    yield_to_maturity_at_par = coupon_rate + (face_value - bond_price) / years_to_maturity / ((face_value + bond_price) / 2)\n    approximate_yield_to_maturity = (current_yield + yield_to_maturity_at_par) / 2\n    \n    # Calculate the after-tax yield to maturity (assuming the bond interest is tax deductible)\n    after_tax_yield = approximate_yield_to_maturity * (1 - tax_rate)\n    \n    # Calculate the cost of equity\n    cost_of_equity = after_tax_yield + risk_premium\n    \n    # Return the result\n    return cost_of_equity\n\n# Call the function and print the result if needed\n# print(solution())\n```\n\nYou can run the function to get the calculated cost of equity using the bond-yield-plus-risk-premium method. Note that this program uses an approximation for the yield to maturity since the exact calculation would require a more complex iterative approach."
        ]
    },
    {
        "question_id": "validation-166",
        "question": "Compute the equal-weighted index value for these three shares, assuming the starting index value is 121.",
        "tables": [
            "|          | March 31, 20X7 Share Price | March 31, 20X7 Number of Shares Outstanding (thousands) | April 30, 20X7 Share Price | April 30, 20X7 Number of Shares Outstanding (thousands) |\n|----------|---------------------------|-----------------------------------------------------|----------------------------|--------------------------------------------------------|\n| Stock X  | $15                       | 100                                                 | $20                        | 100                                                    |\n| Stock Y  | $20                       | 1,000                                               | $30                        | 1,000                                                  |\n| Stock Z  | $30                       | 2,000                                               | $25                        | 2,000                                                  |"
        ],
        "python_solution": "def solution():\n    starting_index = 121\n    shares = [(20/15-1), (30/20-1), (25/30-1)]\n    average_share = sum(shares) / len(shares)\n    new_index = starting_index * (1 + average_share)\n    return new_index",
        "ground_truth": 147.889,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    # Share Prices and Outstanding Shares for March 31\n    march_prices = [15, 20, 30]\n    march_shares_outstanding = [100, 1000, 2000]\n    \n    # Share Prices and Outstanding Shares for April 30\n    april_prices = [20, 30, 25]\n    april_shares_outstanding = [100, 1000, 2000]\n    \n    # Starting index value\n    index_start = 121\n    \n    # Do math calculation to get the answer\n    # Calculate total market cap for March and April\n    march_market_cap = sum([price * shares for price, shares in zip(march_prices, march_shares_outstanding)])\n    april_market_cap = sum([price * shares for price, shares in zip(april_prices, april_shares_outstanding)])\n    \n    # Calculate the unweighted index for both March and April\n    march_unweighted_index = march_market_cap / 3\n    april_unweighted_index = april_market_cap / 3\n    \n    # Calculate the growth factor\n    growth_factor = april_unweighted_index / march_unweighted_index\n    \n    # Adjust the starting index value by the growth factor to get the new index value\n    index_value = index_start * growth_factor\n    \n    # return answer\n    return index_value\n\n# We can call the solution function to get the result\nindex_value = solution()\nindex_value\n```"
        ]
    },
    {
        "question_id": "validation-167",
        "question": "Lillian, who is the portfolio manager for BC pension, has recently been considering the inclusion of QX Corp. (New York Stock Exchange:  QX) to her portfolio. After a thorough analysis of the company and its competitors, she is of the opinion that the company will witness exceptional growth for the next 4 years followed by normal growth. Therefore, she concludes that a two-stage DDM is the most suitable for assessing the stock's value. In 2017, the total dividends QX Corp. paid was $0.22. She anticipates a growth rate of 12 percent for the upcoming 4 years and 6 percent thereafter. The required return is projected to be 9 percent. What would be the terminal value of the stock according to this method?",
        "tables": [],
        "python_solution": "def solution():\n    D_0 = 0.22\n    g_short_term = 0.12\n    g_long_term = 0.06\n    r = 0.09\n    n = 4\n\n    D_n = D_0 * ((1 + g_short_term) ** n)\n    P_n = D_n * (1 + g_long_term) / (r - g_long_term)\n    \n    return P_n",
        "ground_truth": 12.231,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here's a Python program to calculate the terminal value of the stock according to the two-stage dividend discount model (DDM) based on the provided assumptions:\n\n```python\ndef solution():\n    # Define variables name and value\n    D0 = 0.22  # Dividend for 2017\n    g1 = 0.12  # Exceptional growth rate for the next 4 years\n    g2 = 0.06  # Normal growth rate after the initial growth period\n    r = 0.09   # Required return\n    \n    # Calculate the dividend for year 4, which is the last year of exceptional growth\n    D4 = D0 * (1 + g1) ** 4\n    \n    # Calculate the terminal value at the end of year 4 using the Gordon Growth Model\n    # Terminal Value = Dividend at year 5 / (required return - normal growth rate)\n    D5 = D4 * (1 + g2)\n    terminal_value = D5 / (r - g2)\n    \n    # return answer\n    return terminal_value\n\n# Invoke the function and print the answer\nprint(solution())\n```\n\nThe `terminal_value` here represents the present value at the end of year 4. To find the stock's value today, this value would have to be discounted back to the present value using the required rate of return. The above program, however, calculates the terminal value only as indicated in the question."
        ]
    },
    {
        "question_id": "validation-168",
        "question": "A bond is presently priced at 98.722 for every 100 of face value. If the yield-to-maturity (YTM) of this bond increases by 10 basis points, the complete price of the bond is forecasted to descend to 98.669. If the bond's YTM diminishes by 10 basis points, the total price of the bond is projected to ascend to 98.782. Can you determine the approximate convexity of this bond?",
        "tables": [],
        "python_solution": "def solution():\n    PV_minus = 98.782\n    PV_plus = 98.669\n    PV_0 = 98.722\n    delta_yield = 0.001\n    approx_convexity = (PV_minus + PV_plus - 2*PV_0) / (delta_yield**2 * PV_0)\n    return approx_convexity",
        "ground_truth": 70.906,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To approximate the convexity of a bond, we can use the following formula:\n\nConvexity ≈ (P(+) + P(-) - 2*P(0)) / (2 * P(0) * Δy²)\n\nWhere\n- P(+) is the bond price if the yield to maturity decreases by some amount (Δy)\n- P(-) is the bond price if the yield to maturity increases by the same amount (Δy)\n- P(0) is the bond price at the current yield to maturity\n- Δy is the change in the yield to maturity (in decimal form)\n\nIn this case, we are given that when the yield-to-maturity changes by 10 basis points (0.1%) in either direction, the bond prices change accordingly. We need to convert the 10 basis points to a decimal, which is 0.001 (since 1 basis point is 0.01%).\n\nHere's how to structure the Python program to make these calculations:\n\n```python\ndef solution():\n    # Given variables\n    P0 = 98.722  # Current bond price\n    P_plus = 98.782  # Bond price if YTM decreases by 10 basis points\n    P_minus = 98.669  # Bond price if YTM increases by 10 basis points\n    delta_y = 0.001  # YTM change in decimals (10 basis points)\n    \n    # Calculate the approximate convexity using the formula\n    convexity = (P_plus + P_minus - 2 * P0) / (2 * P0 * delta_y**2)\n    \n    # return answer\n    return convexity\n\n# This line is used to check the output of the solution function\nprint(solution())\n```\nThis Python program captures the inputs, calculates the convexity using the provided formula, and would then print the output of the function `solution()`."
        ]
    },
    {
        "question_id": "validation-169",
        "question": "In light of the recent economic slump that negatively impacted the cyclical petrochemical industry, what would be the most fitting price-to-sales ratio for PetroChem Co, a publicly listed European petrochemical engineering company that Jacques is analyzing, if their net sales per share and current share price are $35 and $56 respectively?",
        "tables": [],
        "python_solution": "def solution():\n    net_sales_per_share = 35\n    current_share_price = 56\n    price_to_sales_ratio = current_share_price / net_sales_per_share\n    return price_to_sales_ratio",
        "ground_truth": 1.6,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Here is a Python program that calculates the price-to-sales (P/S) ratio for PetroChem Co:\n\n```python\ndef solution():\n    # Define variables name and value\n    sales_per_share = 35\n    share_price = 56\n    \n    # Calculate the Price-to-Sales (P/S) ratio\n    ps_ratio = share_price / sales_per_share\n    \n    # Return the result\n    return ps_ratio\n\n# To call the function and print the result, uncomment the line below:\n# print(solution())\n```\n\nWhen you call `solution()`, this program will return the Price-to-Sales ratio based on the net sales per share and the company's current share price."
        ]
    },
    {
        "question_id": "validation-170",
        "question": "Given the same data for a different business and assuming a 365-day year, what is the corporation's days of payables for the current year?",
        "tables": [
            "|                   | Current Year | Previous Year |\n|-------------------|--------------|---------------|\n| Sales             | $12,000      | $10,000       |\n| Cost of goods sold| $9,000       | $7,500        |\n| Inventory         | $1,200       | $1,000        |\n| Accounts payable  | $600         | $600          |"
        ],
        "python_solution": "def solution():\n    total_payables = 1000000  # assume\n    cost_of_goods_sold = 15324675  # assume\n\n    days_of_payables = (total_payables / cost_of_goods_sold) * 365\n    return days_of_payables",
        "ground_truth": 23.818,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cost_of_goods_sold_current_year = 9000\n    average_inventory = (1200 + 1000) / 2\n    accounts_payable_current_year = 600\n    \n    # Calculate Inventory Turnover and Days of Payables using the formula\n    inventory_turnover = cost_of_goods_sold_current_year / average_inventory\n    days_of_payables = accounts_payable_current_year / (cost_of_goods_sold_current_year / 365)\n    \n    # return answer\n    return days_of_payables\n\n# You can test the function by calling it\n# print(solution())\n```\n\nThe above program calculates the days of payables for the current year using the provided financial data. The days of payables reflect how long it takes the company to pay its suppliers. In this case, it is calculated by dividing the accounts payable by the daily cost of goods sold (which is derived from the annual cost of goods sold divided by 365 days)."
        ]
    },
    {
        "question_id": "validation-171",
        "question": "What is the percent of contribution to VaR from Asset A in a portfolio, that comprises of two assets: A and B, where Asset A's value is $5,000,000 with a marginal VaR of 0.0452 and Asset B's value is $3,000,000 with a marginal VaR of 0.0332?",
        "tables": [],
        "python_solution": "def solution():\n    asset_A_value = 5000000\n    asset_B_value = 3000000\n    asset_A_MVaR = 0.0452\n    asset_B_MVaR = 0.0332\n    component_VaR_A = asset_A_value * asset_A_MVaR\n    component_VaR_B = asset_B_value * asset_B_MVaR\n    portfolio_VaR = component_VaR_A + component_VaR_B\n    percent_of_contribution_to_VaR_A = component_VaR_A / portfolio_VaR\n    return percent_of_contribution_to_VaR_A * 100",
        "ground_truth": 69.41,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "\n```python\ndef solution():\n    # Define variables name and value\n    asset_A_value = 5000000\n    asset_B_value = 3000000\n    mVaR_A = 0.0452\n    mVaR_B = 0.0332\n    \n    # Calculate contribution to VaR for Asset A and B\n    contrib_A = asset_A_value * mVaR_A\n    contrib_B = asset_B_value * mVaR_B\n    \n    # Calculate total VaR\n    total_VaR = contrib_A + contrib_B\n    \n    # Calculate percent contribution of Asset A to total VaR\n    percent_contribution_A = (contrib_A / total_VaR) * 100\n    \n    # return answer\n    return percent_contribution_A\n    \n# This will print the answer\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-172",
        "question": "An investment manager has a collection of options on XYZ, a stock that doesn't pay dividends. The collection consists of 5,000 deep in-the-money call options on XYZ and 20,000 deep out-of-the-money call options on XYZ. The portfolio also holds 10,000 future contracts on XYZ. Currently, XYZ is trading at USD 52. Given that there are 252 trading days annually, the volatility of XYZ is 12% per year, and each of the option and future contracts represents one share of XYZ, what is the 1-day 99% VaR of the portfolio?",
        "tables": [],
        "python_solution": "def solution():\n    position_delta = 1*5000 + 0*20000 + 1*10000\n    price_per_share = 52\n    volatility = 0.12\n    confidence_level = 2.326\n    trading_days = 252\n\n    var = confidence_level * price_per_share * position_delta * volatility * (1/trading_days)**0.5\n\n    return var",
        "ground_truth": 13714.668,
        "topic": "Risk Management",
        "output": [
            "To calculate the 1-day 99% VaR (Value-at-Risk) of the whole portfolio, you would generally need to know the delta of the options, the current value of the positions, and how they change in response to the underlying asset's price movements. However, since the question doesn't provide deltas or explicit prices for the in-the-money and out-of-the-money call options, we must take a different approach.\n\nFor a stock that doesn't pay dividends, assuming log-normal distribution of stock returns, we can calculate the 1-day VaR for the stock and then apply it to the portfolio's position.\n\nHowever, to calculate this VaR, we need to know the position size (in terms of the current value of the stocks underlying the options and futures) and the delta of the options, which is not provided. The value and delta of deep in-the-money and out-of-the-money options are crucial to calculating the actual VaR, as they would significantly impact the sensitivity of the options to changes in the stock price.\n\nAs an approximation, assuming that the futures contracts have a delta of 1 and the options have a low delta (since deep out-of-the-money options have a delta approaching 0 and deep in-the-money options have a delta approaching 1), the largest exposure would come from the futures and the in-the-money options.\n\nHere's a simplified example of how we might calculate the VaR, assuming we only look at the delta of the futures (since the options' information is incomplete):\n\n```python\nimport scipy.stats as stats\n\ndef solution():\n    # Define variables name and value\n    current_price = 52\n    volatility = 0.12\n    number_of_days = 252\n    z_score = stats.norm.ppf(0.99)  # Z-score for 99% confidence\n    number_of_future_contracts = 10_000\n    \n    # Calculate the 1-day volatility\n    daily_volatility = volatility / (number_of_days ** 0.5)\n    \n    # 1-day VaR\n    # Assuming futures have a delta of 1 and ignoring the deltas of the options\n    value_of_future_contracts = number_of_future_contracts * current_price\n    var_1_day = value_of_future_contracts * daily_volatility * z_score\n\n    # return answer\n    return var_1_day\n\n# Because we have ignored the options due to insufficient information,\n# this is only a partial answer. Options should significantly affect the VaR estimation.\n```\n\nPlease note that this program provides a very rough estimation because it does not take into account the deltas and the total value of the options which significantly affects the VaR calculation. The actual VaR could be significantly different once the deltas and the exposure from the options are included. Normally, an accurate VaR calculation would require a much more detailed analysis of each component in the portfolio."
        ]
    },
    {
        "question_id": "validation-173",
        "question": "The defined contribution pension plan of Redwood Inc. has periodic contributions of $6 million, service costs of $0.8 million, and an actuarial gain of $2.5 million. What is the total of the pension expense?",
        "tables": [],
        "python_solution": "def solution():\n    contributions = 6\n    service_costs = 0.8\n    gain = 2.5\n    # In a defined contribution pension plan, the pension expense is equal to the contributions made by the company\n    pension_expense = contributions  \n    return pension_expense",
        "ground_truth": 6.0,
        "topic": "Accounting",
        "output": [
            "Here's a Python program to calculate the total pension expense for Redwood Inc.:\n\n```python\ndef solution():\n    # Define variables name and value\n    periodic_contributions = 6_000_000\n    service_costs = 800_000\n    actuarial_gain = 2_500_000\n    \n    # Do math calculation to get the answer\n    # Pension expense formula: Service Costs + (Actuarial Gains/Losses) - Periodic Contributions\n    pension_expense = service_costs - actuarial_gain - periodic_contributions\n    \n    # return answer\n    return pension_expense\n\n# Call the solution function and print the result\nprint(solution())\n```\n\nHowever, it should be noted that typically actuarial gains are not subtracted in the pension expense but instead recognized in other comprehensive income. Please confirm if this is the intended operation before using this solution."
        ]
    },
    {
        "question_id": "validation-174",
        "question": "In her role as an analyst for REDD, Xiaomei Zhu focuses on the consumer credit sector. Zhu and her team collected data in 2012 to ascertain the projected return for this sector, as depicted in Exhibit 1. After evaluating various strategies, Zhu and her team chose to apply the bond-yield-plus-risk-premium method. Considering the information in Exhibit 1 and the technique employed by Zhu's team, what was the predicted return for the consumer credit industry in 2012?",
        "tables": [
            "| Securities and Interest Rates | Expected Yield (%) |\n| --- | --- |\n| 10-yearUS Treasury securities | 3.8 |\n| Short-term real rate | 2 |\n| Long-term real rate | 2.3 |\n| 10-year AA corporate bond yield | 4.4 |\n\n| Type of Premium | Premium (%) |\n| --- | --- |\n| Inflation premium | 0.8 |\n| Illiquidity premium | 0.9 |\n| Equity risk premium | 8.4 |"
        ],
        "python_solution": "def solution():\n    government_bond_yield = 3.8\n    equity_risk_premium = 8.4\n    expected_return = government_bond_yield + equity_risk_premium\n    return expected_return",
        "ground_truth": 12.2,
        "topic": "Market Analysis & Economics",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    treasury_yield = 3.8\n    equity_risk_premium = 8.4\n    \n    # Do math calculation to get the answer\n    # The bond-yield-plus-risk-premium method adds the equity risk premium to the 10-year Treasury yield\n    predicted_return = treasury_yield + equity_risk_premium\n    \n    # return answer\n    return predicted_return\n\n# Sample invocation of the solution function\npredicted_return = solution()\nprint(f\"The predicted return for the consumer credit industry in 2012: {predicted_return}%\")\n```\n\nWhen you run this program, it will calculate the predicted return for the consumer credit industry in 2012 using the bond-yield-plus-risk-premium method, adding the equity risk premium to the 10-year Treasury yield."
        ]
    },
    {
        "question_id": "validation-175",
        "question": "The small securities company's research department director, Brian, is in charge of a team that includes 2 junior analysts using the relative value approach to determine a company's worth. Brian informed the 2 junior analysts that using the earnings from the latest 4 quarters may not accurately reflect cyclical companies' long-term earning potential. Therefore, they may find significantly different P/E ratios even though the company's business outlook remains the same. Brian suggested using normalized EPS to solve this issue. Having gathered information about the company throughout the most recent complete cycle, the 2 junior analysts found that the company's balance sheet reveals total assets worth 2100 million and total liabilities of 1200 million. The value of the preferred equity is $120 million, and there are 32 million common shares outstanding. Given this information, what is the company's normalized EPS?",
        "tables": [
            "| Year | ROE   |\n|------|-------|\n| 2013 | 12.00%|\n| 2014 | 13.10%|\n| 2015 | 10.55%|\n| 2016 | 11.20%|\n| 2017 | 12.05%|"
        ],
        "python_solution": "def solution():\n    total_assets = 2100\n    total_liabilities = 1200\n    preferred_equity = 120\n    common_shares = 32\n    roe_values = [12.00, 13.10, 10.55, 11.20, 12.05]\n\n    average_roe = sum(roe_values) / len(roe_values)\n    total_shareholder_equity = total_assets - total_liabilities\n    common_equity_value = total_shareholder_equity - preferred_equity\n    bvps = common_equity_value / common_shares\n    normalized_eps = (average_roe / 100) * bvps\n\n    return normalized_eps",
        "ground_truth": 2.871,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To calculate the company's normalized EPS (Earnings Per Share), we first need to find out the company's average Return on Equity (ROE) over a complete cycle. Based on that, we can estimate the company's normalized net income. ROE is given by the formula:\n\nROE = Net Income / Shareholders' Equity\n\nSince we are looking to find the normalized net income, we can rearrange the formula to:\n\nNormalized Net Income = Average ROE * Shareholders' Equity\n\nUsing the balance sheet values, we can calculate the shareholders' equity by subtracting total liabilities and the value of preferred equity from the total assets. Once we have the normalized net income, the normalized EPS is calculated by dividing the normalized net income by the number of common shares outstanding.\n\nLet's put this into a Python function:\n\n```python\ndef solution():\n    # Define variables\n    years = [2013, 2014, 2015, 2016, 2017]\n    roes = [0.12, 0.131, 0.1055, 0.112, 0.1205]  # Converted percentages to decimal\n    total_assets = 2100 * 10**6   # Convert to dollars\n    total_liabilities = 1200 * 10**6  # Convert to dollars\n    preferred_equity = 120 * 10**6  # Convert to dollars\n    common_shares_outstanding = 32 * 10**6\n    \n    # Calculate average ROE\n    average_roe = sum(roes) / len(roes)\n    \n    # Calculate shareholders' equity\n    shareholders_equity = total_assets - total_liabilities - preferred_equity\n    \n    # Calculate normalized net income\n    normalized_net_income = average_roe * shareholders_equity\n    \n    # Calculate normalized EPS\n    normalized_eps = normalized_net_income / common_shares_outstanding\n    \n    # return normalized EPS rounded to two decimal places\n    return round(normalized_eps, 2)\n\n# Call the solution function and print the result\nprint(solution())  # This line is just for demonstration purpose and can be removed.\n```\n\nHere's the complete function that calculates the company's normalized EPS. The print statement is optional and could be removed to meet the requirement of the solution's format."
        ]
    },
    {
        "question_id": "validation-176",
        "question": "Based on Exhibit 2, what is the average effective spread of the three trades when Smith talks about a market buy order for 5,000 shares of a thinly traded stock?",
        "tables": [
            "| Trade # | Time     | Trade Price | Trade Size | Bid Price | Ask Price |\n|---------|----------|-------------|------------|-----------|-----------|\n| 1       | 9.45 a.m.| $25.20      | 1,200      | $25.17    | $25.20    |\n| 2       | 9.55 a.m.| $25.22      | 1,300      | $25.19    | $25.22    |\n| 3       | 11.30 a.m.| $25.27     | 2,500      | $25.22    | $25.26    |"
        ],
        "python_solution": "def solution():\n    # trades prices\n    trade_prices = [25.20, 25.22, 25.27]\n    # bid and ask prices for each trade\n    bid_ask_prices = [(25.20, 25.17), (25.22, 25.19), (25.26, 25.22)]\n    \n    # calculate the effective spread for each trade\n    effective_spreads = [2 * (trade_price - ((ask + bid) / 2)) for trade_price, (ask, bid) in zip(trade_prices, bid_ask_prices)]\n    \n    # calculate the average effective spread\n    average_effective_spread = sum(effective_spreads) / len(effective_spreads)\n    \n    return average_effective_spread",
        "ground_truth": 0.04,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "In finance, the effective spread is calculated for each trade as two times the absolute difference between the trade price and the midpoint of the bid and ask prices at the time of the trade.\n\nGiven the table you've provided, we need to calculate the effective spread for each trade, and then we will find the average of these spreads. The midpoint for each trade can be calculated as the average between the bid and ask price. The effective spread is twice the deviation of the trade price from this midpoint.\n\nHere's the Python program that calculates the average effective spread based on the data you've provided:\n\n```python\ndef solution():\n    # Define variables from the table\n    trades = [\n        {'trade_price': 25.20, 'bid_price': 25.17, 'ask_price': 25.20},\n        {'trade_price': 25.22, 'bid_price': 25.19, 'ask_price': 25.22},\n        {'trade_price': 25.27, 'bid_price': 25.22, 'ask_price': 25.26},\n    ]\n    \n    # Initialize running total of effective spreads\n    total_effective_spread = 0\n    \n    # Calculate effective spread for each trade\n    for trade in trades:\n        midpoint = (trade['bid_price'] + trade['ask_price']) / 2\n        effective_spread = 2 * abs(trade['trade_price'] - midpoint)\n        total_effective_spread += effective_spread\n    \n    # Calculate average effective spread across all trades\n    average_effective_spread = total_effective_spread / len(trades)\n    \n    # Return the answer\n    return average_effective_spread\n\n# Call the function and print the result\nprint(\"The average effective spread is:\", solution())\n```\n\nRunning this program will give you the average effective spread of the three trades."
        ]
    },
    {
        "question_id": "validation-177",
        "question": "If a two-year fixed-for-floating MRR swap is at 1.00%, and the yield of the two-year US Treasury bond is 0.63%, what would be the swap spread?",
        "tables": [],
        "python_solution": "def solution():\n    mrr_swap = 1.00\n    treasury_yield = 0.63\n    swap_spread = mrr_swap - treasury_yield\n    return swap_spread",
        "ground_truth": 0.37,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    mrr_swap_rate = 1.00\n    treasury_yield = 0.63\n    \n    # Calculate the swap spread\n    swap_spread = mrr_swap_rate - treasury_yield\n    \n    # return answer\n    return swap_spread\n\n# You can call the function to test the result\nprint(solution())\n```\n\nThis Python program will calculate the swap spread by deducting the yield of the two-year US Treasury bond from the two-year fixed-for-floating MRR swap rate."
        ]
    },
    {
        "question_id": "validation-178",
        "question": "An expert has compiled the major forecasts and assumptions for a J REIT. What is the inherent worth of the J REIT per share utilizing the two-step dividend discount model?",
        "tables": [
            "| Current risk-free rate | 3.00% |\n|------------------------|-------|\n| Beta of the T REIT     | 1.1   |\n| Market risk premium    | 5.00% |\n| Expected dividend per share, 1 year from today | $1.13 |\n| Expected dividend per share, 2 years from today| $1.22 |\n| Long-term growth rate in dividends, starting in year 3 | 5.00% |"
        ],
        "python_solution": "def solution():\n    discount_rate = 0.085\n    dividend_y1 = 1.13\n    dividend_y2 = 1.22\n    growth_rate = 0.05\n\n    stock_price = (dividend_y1 / (1+discount_rate)) + (dividend_y2 / ((1+discount_rate)**2)) + ((dividend_y2*(1+growth_rate))/(discount_rate-growth_rate))/((1+discount_rate)**2)\n    return stock_price",
        "ground_truth": 33.168,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    rfr = 0.03 # risk-free rate\n    beta = 1.1 # beta of the T REIT\n    market_risk_premium = 0.05 # market risk premium\n    D1 = 1.13 # Expected dividend in one year\n    D2 = 1.22 # Expected dividend in two years\n    growth_rate = 0.05 # Long-term growth rate in dividends, starting year 3\n    \n    # Required return using CAPM\n    required_return = rfr + beta * market_risk_premium\n    \n    # Price at the end of year 2 (start of year 3) using Gordon growth model\n    P2 = D2 * (1 + growth_rate) / (required_return - growth_rate)\n    \n    # Present value of expected dividends and Price at the end of year 2\n    present_value_D1 = D1 / (1 + required_return)\n    present_value_D2 = D2 / ((1 + required_return) ** 2)\n    present_value_P2 = P2 / ((1 + required_return) ** 2)\n    \n    # Inherent worth is the sum of the present values\n    inherent_worth = present_value_D1 + present_value_D2 + present_value_P2\n    \n    # return answer\n    return round(inherent_worth, 2) # round to two decimal places for currency formatting\n\n# Call the function and print the result for demonstration.\nanswer = solution()\nprint(f\"The inherent worth of the J REIT per share: ${answer}\")\n```\n\nRunning this program provides you with the inherent worth of the J REIT per share calculated using the two-step dividend discount model. The `round` function is used to format the value to two decimal places."
        ]
    },
    {
        "question_id": "validation-179",
        "question": "Azarov has requested Bector to implement the ML model on the test dataset for Dataset XYZ, considering a threshold p-value of 0.65. Exhibit 2 includes a specimen of outcomes from the test dataset corpus. Given the data in Exhibit 2, what is the accuracy computation for the test set sample of Dataset XYZ?",
        "tables": [
            "| Sentence # | Actual Sentiment | Target p-Value |\n|------------|------------------|----------------|\n| 1          | 1                | 0.75           |\n| 2          | 0                | 0.45           |\n| 3          | 1                | 0.64           |\n| 4          | 1                | 0.81           |\n| 5          | 0                | 0.43           |\n| 6          | 1                | 0.78           |\n| 7          | 0                | 0.59           |\n| 8          | 1                | 0.60           |\n| 9          | 0                | 0.67           |\n| 10         | 0                | 0.54           |"
        ],
        "python_solution": "def solution():\n    TP = 3\n    TN = 4\n    FP = 1\n    FN = 2\n    accuracy = (TP + TN)/(TP + FP + TN + FN)\n    return accuracy",
        "ground_truth": 0.7,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define the data provided in the table\n    data = [\n        {'Actual Sentiment': 1, 'Target p-Value': 0.75},\n        {'Actual Sentiment': 0, 'Target p-Value': 0.45},\n        {'Actual Sentiment': 1, 'Target p-Value': 0.64},\n        {'Actual Sentiment': 1, 'Target p-Value': 0.81},\n        {'Actual Sentiment': 0, 'Target p-Value': 0.43},\n        {'Actual Sentiment': 1, 'Target p-Value': 0.78},\n        {'Actual Sentiment': 0, 'Target p-Value': 0.59},\n        {'Actual Sentiment': 1, 'Target p-Value': 0.60},\n        {'Actual Sentiment': 0, 'Target p-Value': 0.67},\n        {'Actual Sentiment': 0, 'Target p-Value': 0.54}\n    ]\n    \n    # Define the p-value threshold\n    threshold_p_value = 0.65\n    correct_predictions = 0\n    \n    # Calculate the number of correct predictions\n    for entry in data:\n        # Predicted sentiment is 1 if Target p-Value >= threshold, else 0\n        predicted_sentiment = 1 if entry['Target p-Value'] >= threshold_p_value else 0\n        \n        # Check if the prediction matches the actual sentiment\n        if predicted_sentiment == entry['Actual Sentiment']:\n            correct_predictions += 1\n    \n    # Calculate the accuracy\n    accuracy = correct_predictions / len(data)\n    \n    # Return accuracy\n    return accuracy\n```"
        ]
    },
    {
        "question_id": "validation-180",
        "question": "The collection of investments includes two zero-coupon bonds, each priced at $10. The initial bond possesses a modified duration of a year, while the second bond carries a modified duration of nine years. With an even yield curve and a consistent yield of 5%, all alterations of the yield curve result in equal shifts. Given that the daily instability of the yield equals 1%, can you best estimate the daily value at risk (VAR) for the collection of investments at the 95% certainty level?",
        "tables": [],
        "python_solution": "def solution():\n    dollar_duration = 1*10 + 9*10\n    daily_var = dollar_duration * 0.01 * 1.65\n    return daily_var",
        "ground_truth": 1.65,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    principal_value = 20  # Combined principal value of both bonds (10 * 2)\n    modified_duration_bond1 = 1\n    modified_duration_bond2 = 9\n    daily_yield_volatility = 0.01\n    yield_change = norm.ppf(0.95) * daily_yield_volatility\n    \n    # The weighted average modified duration of the portfolio\n    average_modified_duration = (modified_duration_bond1 + modified_duration_bond2) / 2\n    \n    # Daily value at risk calculation\n    daily_var = principal_value * average_modified_duration * yield_change\n    \n    # Return answer\n    return daily_var\n    \n# Example of calling the function\nprint(solution())\n```\n\nThe above program calculates the daily value at risk for a portfolio consisting of two zero-coupon bonds influenced by yield changes. It uses the norm.ppf function from the scipy.stats package to determine the critical value corresponding to the 95% confidence level for a standard normal distribution. Then, it computes the daily VaR by multiplying the combined principal amount by the weighted average modified duration of both bonds and the yield change."
        ]
    },
    {
        "question_id": "validation-181",
        "question": "For an investment of USD100 that produces after-tax cash flows of USD40 in the first year, USD80 in the second year, and USD120 in the third year, given a required rate of return of 20%, what would be the Net Present Value?",
        "tables": [],
        "python_solution": "def solution():\n    cash_flows = [-100, 40, 80, 120]\n    rate_of_return = 0.20\n    NPV = 0\n    for t in range(len(cash_flows)):\n        NPV += cash_flows[t] / ((1+rate_of_return) ** t)\n    return NPV",
        "ground_truth": 58.333,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    investment = 100\n    cash_flows = [40, 80, 120]\n    rate_of_return = 0.20\n    \n    # Do math calculation to get the answer\n    NPV = sum(cf / (1 + rate_of_return)**i for i, cf in enumerate(cash_flows, start=1)) - investment\n    \n    # return answer\n    return NPV\n\n# Note: If needed, the solution can be tested by calling the function and printing the result as follows:\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-182",
        "question": "If a corporation issues a bond with specific features on January 1, 2014, and the market interest rate for its bonds stands at 5%, what would be its interest cost ( in millions) for the year 2014 under International Financial Reporting Standards (IFRS)?",
        "tables": [
            "| | |\n|---|---|\n|Face value|£50 million|\n|Coupon rate, paid annually|4%|\n|Time to maturity|10 years (31 December 2033)|\n|Issue price (per £100)|£92.28|"
        ],
        "python_solution": "def solution():\n    liability_value = 0.9228 * 50\n    market_rate = 0.05\n    interest_expense = liability_value * market_rate\n    return interest_expense",
        "ground_truth": 2.307,
        "topic": "Accounting",
        "output": [
            "To compute the interest cost for the year 2014 under International Financial Reporting Standards (IFRS), we need to consider the effective interest method for the accounting of bonds. The effective interest rate would be the market interest rate at the time of issuance, which is given as 5%. The bond's carrying amount at the beginning of the year would be the issue price.\n\nHere is the Python program that will calculate the interest cost for the year 2014:\n\n```python\ndef solution():\n    # Define variables name and value\n    face_value = 50e6  # Face value of the bond in millions (£50 million)\n    coupon_rate = 0.04  # Annual coupon rate (4%)\n    issue_price_per_100 = 92.28  # Issue price per £100\n    market_interest_rate = 0.05  # Market interest rate (5%)\n    \n    # Calculate initial carrying value\n    issue_price = issue_price_per_100 / 100 * face_value  # Total issue price\n    annual_coupon_payment = face_value * coupon_rate  # Annual coupon payment\n    \n    # Calculate interest cost using the effective interest method\n    interest_cost = issue_price * market_interest_rate  # Effective interest expense\n    \n    # Convert interest cost to millions for consistency with the face value\n    interest_cost_millions = interest_cost / 1e6\n    \n    # return answer\n    return interest_cost_millions\n\n# Call the function and print the result\nprint(solution())\n```\n\nWhen you run this program, it will calculate and print the interest cost for the year 2014 based on the given bond details and under IFRS."
        ]
    },
    {
        "question_id": "validation-183",
        "question": "At present, James has $750,000 in cash and short-term investment. He then consults with his portfolio manager Simmons regarding his investment holdings. As per the assessment, James' human capital is estimated at $1.2 million, out of which 30% appears to be similar to equity. Simmons concludes that a total target allocation of 45% equity is suitable for James. To reach the desired equity allocation for total economic wealth, what should be the financial capital equity allocation for James?",
        "tables": [],
        "python_solution": "def solution():\n    human_capital = 1200000\n    financial_capital = 750000\n    target_equity_allocation = 0.45\n\n    total_economic_wealth = human_capital + financial_capital\n    target_equity_allocation_value = total_economic_wealth * target_equity_allocation\n    human_capital_equity_allocation = human_capital * 0.30\n    financial_capital_equity_allocation = target_equity_allocation_value - human_capital_equity_allocation\n    financial_capital_equity_allocation_percentage = financial_capital_equity_allocation / financial_capital\n    \n    return financial_capital_equity_allocation_percentage * 100",
        "ground_truth": 69.0,
        "topic": "Accounting",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    cash_and_investments = 750000  # Financial capital\n    human_capital = 1200000  # Human capital\n    human_capital_equity = 0.30 * human_capital  # 30% equity like in human capital\n    total_equity_target = 0.45  # Desired total equity allocation\n\n    # Total desired equity allocation in terms of economic wealth\n    total_economic_wealth = cash_and_investments + human_capital\n    desired_equity_allocation = total_economic_wealth * total_equity_target\n\n    # Financial capital equity allocation required\n    financial_capital_equity_allocation = desired_equity_allocation - human_capital_equity\n\n    # Percentage of financial capital to be allocated to equity\n    financial_capital_equity_percentage = financial_capital_equity_allocation / cash_and_investments\n\n    # return answer\n    return financial_capital_equity_percentage\n\n# Call the solution function and print the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-184",
        "question": "Because of considerable growth prospects, Firm B has put a halt to its dividends for the earliest four years. The executives assert that during the fifth year, they will distribute a dividend of $2.5 for each share. After that, the dividend is predicted to expand at a 5% annual rate indefinitely. A 12% return rate is needed. What is the intrinsic value of Firm B's stock?",
        "tables": [],
        "python_solution": "def solution():\n    D5 = 2.5\n    r = 0.12\n    g = 0.05\n\n    P4 = D5 / (r - g)\n    V0 = P4 / (1 + r)**4\n\n    return V0",
        "ground_truth": 22.697,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    dividend_in_5th_year = 2.5     # Dividend in the fifth year (D5)\n    growth_rate = 0.05             # Growth rate of dividends\n    required_return = 0.12         # Required rate of return (k)\n    \n    # Calculate the present value of the dividend received in the 5th year\n    present_value_D5 = dividend_in_5th_year / ((1 + required_return) ** 5)\n    \n    # Calculate the value of the stock at the end of 4th year as a perpetuity\n    # Using the formula: P4 = D5 / (k - g)\n    P4 = dividend_in_5th_year / (required_return - growth_rate)\n    \n    # Present value of P4 (stock price at the end of the 4th year)\n    present_value_P4 = P4 / ((1 + required_return) ** 4)\n    \n    # The intrinsic value of the stock today is the present value of P4\n    intrinsic_value = present_value_P4\n    \n    # return answer\n    return intrinsic_value\n\n# Running the solution function to print out the result\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-185",
        "question": "If ABC Corporation releases three-year bonds dated 1 January 2015 that have a face value of $5,000,000, how are they most likely reported as bonds payable when issued, considering the market interest rate for bonds of similar risk and term is 3% and the bonds yield an annual rate of 2.5% on 31 December?",
        "tables": [],
        "python_solution": "def solution():\n    FV = 5000000 # Face Value of Bond\n    I_M = 0.03 # Market Interest Rate\n    I_B = 0.025 # Bond Yield Rate\n    N = 3 # Period of Bond in Years\n    PMT = FV * I_B # Annual Payments\n    PV = 0 # Present Value of Bond\n    \n    # Compute for Present value\n    for i in range(1, N+1):\n        PV += PMT/(1+I_M)**i # Compute Present Value based on Discount Factor Formula\n    PV += FV/(1+I_M)**N # Add the Face Value discounted back to today at Market Rate\n    \n    return PV",
        "ground_truth": 4929284.716,
        "topic": "Accounting",
        "output": [
            "To determine how the bonds payable are reported when issued, we need to compute the present value of the bonds. Since bonds are typically issued at either a discount or premium based on the difference between the market rate and the stated rate (coupon rate), we will calculate the present value based on the market rate because this indicates the rate of interest that investors demand for the bond's risk and term.\n\nGiven:\n- Face value of the bonds: $5,000,000\n- Market interest rate: 3%\n- Stated annual rate (bond yield/coupon rate): 2.5%\n- Bonds are dated: 1 January 2015\n\nTo simplify this calculation, we will assume that the bonds pay interest annually.\n\nHere's the Python program to calculate the present value of the bonds:\n\n```python\ndef solution():\n    # Define variables name and value\n    face_value = 5000000\n    market_rate = 0.03\n    coupon_rate = 0.025\n    num_years = 3 \n    \n    # Calculate the Present Value of the bond's Face Value\n    pv_face_value = face_value / ((1 + market_rate) ** num_years)\n    \n    # Calculate the Present Value of the bond's annual coupon payments\n    annual_coupon_payment = face_value * coupon_rate\n    pv_annual_coupons = sum([annual_coupon_payment / ((1 + market_rate) ** i) for i in range(1, num_years + 1)])\n    \n    # The value of bonds payable when issued is the sum of the present value of the face value and the present value of the coupon payments\n    bonds_payable_value = pv_face_value + pv_annual_coupons\n    \n    # return answer\n    return round(bonds_payable_value, 2)\n\n# Run the function and print the answer\nprint(solution())\n```\n\nRunning the `solution()` function will calculate the present value of the bonds and print the amount for which the bonds payable would be reported when issued on 31 December.\n\nPlease note that this calculation is a simplistic interpretation and does not take into account other factors that might be present in an actual bond issuance, such as semi-annual payments, day count conventions, and other intricacies of bond pricing."
        ]
    },
    {
        "question_id": "validation-186",
        "question": "A financial expert is requested to calculate the VaR for a stake in Mega Healthcare Solutions Ltd. The firm's shares go for USD 26.00, with a daily volatility standing at 1.5%. Utilizing the delta-normal approach, what is the VaR at the 95% confidence level for a long position in an at-the-money put on this share with a delta of -0.5 spanning a 1-day holding period?",
        "tables": [],
        "python_solution": "def solution():\n    delta = 0.5\n    z_score = 1.645\n    volatility = 0.015\n    share_price = 26.0\n\n    Var = abs(delta) * z_score * volatility * share_price\n    return Var",
        "ground_truth": 0.321,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "The Value at Risk (VaR) is a common measure to assess the risk of loss on a specific portfolio of financial assets. For a given portfolio, VaR is defined as the threshold loss value with a given confidence interval over a given time period.\n\nUsing the delta-normal method, we estimate what the worst expected loss over a specific time frame (e.g., one day) at a certain confidence level (e.g., 95%) would be, assuming normal market conditions and no trading in the portfolio.\n\nFor a stock with daily volatility and a delta of the at-the-money (ATM) put, we can calculate the VaR with this information.\n\nGiven:\n- Stock price (\\( S \\)) = $26.00\n- Daily volatility (\\( \\sigma \\)) = 1.5%\n- Delta (\\( \\delta \\)) of an ATM put = -0.5\n- Confidence level = 95% (for which the z-score is approximately 1.645 for a one-tailed test from the standard normal distribution)\n- Holding period = 1 day\n\nVaR for the put option can be calculated as:\n\n\\[ \\text{VaR} = \\delta \\times S \\times \\sigma \\times Z \\]\n\nwhere \\( Z \\) is the z-score corresponding to the desired confidence level.\n\nWe can now create the program to calculate this:\n\n```python\nfrom scipy.stats import norm\n\ndef solution():\n    # Define variables name and value\n    stock_price = 26.00  # Stock price (S)\n    daily_volatility = 0.015  # Daily volatility (σ)\n    delta = -0.5  # Delta (δ) of an ATM put\n    confidence_level = 0.95  # Confidence level\n    \n    # Calculate the z-score for the given confidence level\n    z_score = norm.ppf(confidence_level)\n    \n    # Calculate the VaR\n    var = delta * stock_price * daily_volatility * z_score\n    \n    # Return the absolute value of VaR as we are interested in the magnitude of risk\n    return abs(var)\n\n# You can now call the solution function and print the result, if you want to check the answer.\n#print(solution())\n```\n\nSince the delta is negative, this implies that the option price increases as the stock price decreases, hence the VaR should be a positive value representing a potential loss. In this context, we are interested in the absolute value of the calculated VaR, which is why we return `abs(var)`."
        ]
    },
    {
        "question_id": "validation-187",
        "question": "What is the yearly geometric mean return of this investment over a three-year period?",
        "tables": [
            "| Year | Return(%) |\n|------|----------|\n| 2009 | 20       |\n| 2010 | -30      |\n| 2011 | 15       |"
        ],
        "python_solution": "def solution():\n    return ((1 + 0.2) * (1 - 0.3) * (1 + 0.15))**(1/3) - 1",
        "ground_truth": -0.011,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\n# Import package if needs\nimport math\n\ndef solution():\n    # Define variables name and value\n    returns = [20, -30, 15]\n    \n    # Process each return as a multiplier factor (e.g., a 20% return translates to a factor of 1.20)\n    # For negative returns, a -30% return translates to a factor of 0.70 \n    factors = [(1 + r / 100) for r in returns]\n    \n    # Calculate the product of all factors using math.prod if available, otherwise compute manually\n    product_of_factors = math.prod(factors)\n    \n    # Calculate the geometric mean as the nth root of the product of factors where n is the number of years\n    geometric_mean = (product_of_factors ** (1/len(returns))) - 1\n    \n    # Convert back to percentage\n    geometric_mean_return = geometric_mean * 100\n    \n    # return answer\n    return geometric_mean_return\n\n# Call the function and print the result for checking\nprint(solution())\n```"
        ]
    },
    {
        "question_id": "validation-188",
        "question": "Can you determine the expected return on a stock using the Capital Asset Pricing Model, with a beta value of 0.6, given a risk-free rate of 8%, and a market return of 15%?",
        "tables": [],
        "python_solution": "def solution():\n    Rf = 8\n    Beta = 0.6\n    Market_return = 15\n    expected_return = Rf + Beta * (Market_return - Rf)\n    return expected_return",
        "ground_truth": 12.2,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Certainly! The Capital Asset Pricing Model (CAPM) can calculate the expected return on a stock and is given by the formula:\n\nE(Ri) = Rf + βi * (Rm - Rf)\n\nwhere:\nE(Ri) = Expected return on the stock\nRf = Risk-free rate\nβi = Beta of the stock (measure of the stock's volatility in relation to the market)\nRm = Return of the market\n\nHere's the Python program to calculate the expected return using the CAPM:\n\n```python\ndef solution():\n    # Define variables name and value\n    beta = 0.6\n    risk_free_rate = 0.08\n    market_return = 0.15\n    \n    # Do math calculation to get the answer\n    expected_return = risk_free_rate + beta * (market_return - risk_free_rate)\n    \n    # return the answer\n    return expected_return\n\n# You can call the function and print the result if you want\n# print(solution())\n```\n\nWhen you run this program, it will calculate the expected return on the stock using the CAPM formula."
        ]
    },
    {
        "question_id": "validation-189",
        "question": "Assuming the neutral real policy rate is set at 2.25%, the desired inflation rate is 2%, and projected growth is approximately 2.5%. If growth is predicted to be 3.5% and inflation is anticipated to reach 3%, what would be the nominal policy rate based on the Taylor rule?",
        "tables": [],
        "python_solution": "def solution():\n    neutral_real_policy_rate = 2.25\n    desired_inflation_rate = 2\n    projected_growth = 2.5\n    predicted_growth = 3.5\n    anticipated_inflation = 3\n\n    nominal_policy_rate = neutral_real_policy_rate + anticipated_inflation + 0.5 * (predicted_growth - projected_growth) + 0.5 * (anticipated_inflation - desired_inflation_rate)\n\n    return nominal_policy_rate",
        "ground_truth": 6.25,
        "topic": "Market Analysis & Economics",
        "output": [
            "Certainly! The Taylor rule is a monetary-policy rule that stipulates how much the central bank should change the nominal interest rate in response to changes in inflation, output, or other economic conditions. In its simplest form, the Taylor rule suggests that the nominal interest rate should be adjusted based on the following:\n1. The equilibrium (or neutral) real interest rate.\n2. The rate of inflation relative to the target inflation rate.\n3. The level of economic activity relative to the potential output.\n\nFor this particular question, the Taylor rule can be represented as follows:\n   \nNominal Policy Rate = Neutral Real Policy Rate + Current Inflation + 0.5 * (Inflation Gap) + 0.5 * (Output Gap)\n\nWhere:\n- Neutral Real Policy Rate is given as 2.25%.\n- Desired Inflation Rate is 2%\n- Inflation Gap is the difference between the current inflation rate and the desired inflation rate.\n- Output Gap is the difference between the projected growth rate and the long-term growth rate.\n\nGiven these parameters, we can create a Python program to calculate the Nominal Policy Rate based on the Taylor rule:\n```python\ndef solution():\n    # Define variables name and value\n    neutral_real_policy_rate = 2.25\n    desired_inflation_rate = 2\n    long_term_growth_rate = 2.5\n    current_inflation = 3\n    projected_growth = 3.5\n    \n    # Calculate the inflation gap and the output gap\n    inflation_gap = current_inflation - desired_inflation_rate\n    output_gap = projected_growth - long_term_growth_rate\n    \n    # Calculate the nominal policy rate using the Taylor rule\n    nominal_policy_rate = (neutral_real_policy_rate + current_inflation +\n                           0.5 * inflation_gap + 0.5 * output_gap)\n    \n    # return answer\n    return nominal_policy_rate\n    \n# Example usage\nprint(solution())\n```\n\nThe function `solution()` calculates the nominal policy rate based on the provided parameters and the Taylor rule formula, and then returns the result."
        ]
    },
    {
        "question_id": "validation-190",
        "question": "What is the forecaster's projected forward-looking ERP for a market using the Grinold-Kroner model based on the same details?",
        "tables": [
            "| Expected inflation | 1.9% |\n|---|---|\n| Expected growth in the P/E | -1.2% |\n| Expected income component | 1.8% |\n| Expected growth in real earnings per share | 2.7% |\n| Expected change in shares outstanding | 0.0% |\n| Current three-month government bond yield | 0.96% |\n| Long-term geometric average return of market equity index | 9.96% |\n| Long-term geometric average return of short-term government bond | 3.15% |"
        ],
        "python_solution": "def solution():\n    ERP = (1.8 - 1.2 + (1.9 + 2.7 + 0.0)) - 0.96\n    ERP_percentage = ERP * 100\n    return ERP_percentage",
        "ground_truth": 424.0,
        "topic": "Corporate & Securities Issuance",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    expected_inflation = 1.9\n    expected_growth_PE = -1.2\n    expected_income_component = 1.8\n    expected_growth_real_EPS = 2.7\n    expected_change_shares_outstanding = 0.0\n    current_gov_bond_yield = 0.96\n    longterm_avg_market_return = 9.96\n    longterm_avg_gov_bond_return = 3.15\n    \n    # Do math calculation to get the answer\n    # The Grinold-Kroner model is given by\n    # ERP = (i + (g - ΔS) - ΔPE + Y) - B\n    # where i = expected inflation, g = expected growth in real earnings per share,\n    # ΔS = expected change in shares outstanding, ΔPE = expected growth in the P/E,\n    # Y = expected income component, B = current government bond yield\n    \n    ERP = (expected_inflation / 100\n           + (expected_growth_real_EPS - expected_change_shares_outstanding) / 100\n           - expected_growth_PE / 100\n           + expected_income_component / 100\n           ) - current_gov_bond_yield / 100\n    \n    # return answer\n    return ERP\n\n# Call the function and print the answer\nprint(solution())\n```\nThis Python function when executed will calculate the forecasted forward-looking Equity Risk Premium (ERP) for the market using the Grinold-Kroner model based on the given details."
        ]
    },
    {
        "question_id": "validation-191",
        "question": "Once happy with the ultimate set of attributes, Williams chooses and operates a model on the training set that categorizes the text as either having positive sentiment (Class “1” or negative sentiment (Class “0”). He then appraises its performance by implementing error analysis. Based on Exhibit 2, what is the accuracy metric of the model in the ensuing confusion matrix?",
        "tables": [
            "|        |             | Actual Training   |           |\n|--------|-------------|:-----------------:|----------:|\n|        |             | Results           |           |\n|        |             | Class \"1\"         | Class \"0\" |\n| Predicted Results | Class \"1\" | TP=182           | FP=52     |\n|                    | Class \"0\" | FN=31            | TN=96     |"
        ],
        "python_solution": "def solution():\n    TP = 182\n    TN = 96\n    FP = 52\n    FN = 31\n\n    Accuracy = (TP + TN) / (TP + FP + TN + FN)\n    return Accuracy * 100",
        "ground_truth": 77.008,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    TP = 182  # True Positives \n    FP = 52   # False Positives \n    FN = 31   # False Negatives\n    TN = 96   # True Negatives\n    \n    # Calculate the accuracy (the proportion of true results among the total number of cases)\n    accuracy = (TP + TN) / (TP + FP + FN + TN)\n    \n    # Return the calculated accuracy\n    return accuracy\n\n# You can test the function by calling it\n# print(solution())\n```"
        ]
    },
    {
        "question_id": "validation-192",
        "question": "In a sports competition involving 15 participants, prizes of $100, $50, and $10 will be given to the top performers. In how many different ways can this be done?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    return math.factorial(15)/(math.factorial(15-3))",
        "ground_truth": 2730.0,
        "topic": "Quantitative Analysis & Valuation",
        "output": [
            "To solve this, we can consider that there are 15 participants and 3 distinct prizes to be awarded. The total number of ways in which this can be done is by using the permutations of choosing 3 people from the group of 15 to assign the three prizes in order (since the prizes are distinct, order matters). This can be calculated using the formula for permutations:\n\n\\( P(n, k) = \\frac{n!}{(n-k)!} \\)\n\nIn this case, \\( n = 15 \\) and \\( k = 3 \\). Here is the Python function to calculate the answer:\n\n```python\nimport math\n\ndef solution():\n    # Number of participants\n    participants = 15\n    \n    # Number of prizes\n    prizes = 3\n    \n    # Calculate permutations\n    ways_to_award = math.perm(participants, prizes)\n    \n    # return answer\n    return ways_to_award\n\n# You can test the function with the following line:\n# print(solution())\n```\n\nThis program defines the number of participants and the number of prizes, then calculates the number of different ways to distribute the prizes by computing the permutations with the built-in `math.perm()` function from the math module. The answer is the number of permutations of 15 participants taken 3 at a time."
        ]
    },
    {
        "question_id": "validation-193",
        "question": "Assuming that a broker holds an option stance in crude oil exhibiting a delta of 100000 barrels and a gamma of -50000 barrels per dollar price shift, compute the VaR for this stance utilizing the delta-gamma approach, under the presumption that the maximum crude oil price shift is $2.00 per barrel.",
        "tables": [],
        "python_solution": "def solution():\n    Delta = 100000\n    Gamma = -50000\n    VAR_ds = 2\n\n    VAR_df = Delta * -VAR_ds + (1 / 2) * Gamma * VAR_ds ** 2\n    return VAR_df",
        "ground_truth": -300000.0,
        "topic": "Risk Management",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    delta = 100000  # Position's delta\n    gamma = -50000  # Position's gamma\n    price_shift = 2.00  # Maximum price shift in dollars per barrel\n    \n    # Do math calculation to get the answer\n    VaR = -(delta * price_shift + 0.5 * gamma * price_shift**2)\n    \n    # return answer\n    return VaR\n\n# The result is the Value at Risk (VaR) for the crude oil position using the delta-gamma approach.\n```"
        ]
    },
    {
        "question_id": "validation-194",
        "question": "If a stock's present cost is $25 each, you plan to invest your $10,000 and also loan an additional $10,000 from your financial adviser to put $20,000 in the shares. If the preservation margin is 30 percent, what would be the initial price that will trigger a margin call?",
        "tables": [],
        "python_solution": "def solution():\n    initial_stock_price = 25\n    initial_equity = initial_stock_price * 0.5\n    preservation_margin = 0.30\n    P = initial_equity / (1 - preservation_margin)\n    return P",
        "ground_truth": 17.857,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "Below is the Python program to calculate the initial stock price that will trigger a margin call.\n\n```python\ndef solution():\n    # Define variables name and value\n    own_capital = 10000\n    borrowed_capital = 10000\n    initial_stock_price = 25\n    maintenance_margin = 0.3\n    \n    # Calculate total amount of investment\n    total_investment = own_capital + borrowed_capital\n    \n    # Calculate the number of shares purchased\n    number_of_shares = total_investment / initial_stock_price\n    \n    # Calculate the own capital percentage of the total investment\n    own_capital_percentage = own_capital / total_investment\n    \n    # Calculate the price of the stock that will trigger a margin call\n    # Using the formula: (borrowed capital / number of shares) / (1 - maintenance_margin)\n    # Or equivalently: initial_stock_price * (1 - own_capital_percentage) / (1 - maintenance_margin)\n    trigger_price = initial_stock_price * (1 - own_capital_percentage) / (1 - maintenance_margin)\n    \n    # return answer\n    return trigger_price\n\n# You can call the function to see the result\ntrigger_price = solution()\nprint(trigger_price)\n```\n\nGiven that you're borrowing an amount equal to your own investment ($10,000), the own capital percentage is 50%. We can use this information to compute the price at which your equity would fall below the maintenance margin, which would trigger a margin call."
        ]
    },
    {
        "question_id": "validation-195",
        "question": "What is the overall fee that Circle has garnered in the current year, considering $288 million in assets under management (AUM) from the end of the previous year, a 2% management fee (based on year-end AUM), a 20% incentive fee calculated after subtracting the management fee using a 5% soft hurdle rate and a high-water mark of $357 million, and the fund yield for the current year being 25%?",
        "tables": [],
        "python_solution": "def solution():\n    prior_year_end_AUM = 288\n    fund_return = 0.25\n    management_fee_percentage = 2/100\n    \n    end_of_year_AUM = prior_year_end_AUM * (1 + fund_return)\n    management_fee = end_of_year_AUM * management_fee_percentage\n    \n    return management_fee",
        "ground_truth": 7.2,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    previous_aum = 288000000  # $288 million\n    management_fee_rate = 0.02  # 2% management fee\n    incentive_fee_rate = 0.20  # 20% incentive fee\n    soft_hurdle_rate = 0.05  # 5% soft hurdle\n    high_water_mark = 357000000  # $357 million\n    fund_yield = 0.25  # 25%\n\n    # Calculate the management fee\n    management_fee = previous_aum * management_fee_rate\n\n    # Calculate the performance of the fund\n    fund_performance = previous_aum * fund_yield\n\n    # Check if the performance is above the high-water mark\n    if previous_aum + fund_performance > high_water_mark:\n        # Calculate how much the performance exceeds the high-water mark\n        performance_above_hwm = previous_aum + fund_performance - high_water_mark\n        \n        # Calculate how much the performance is above the soft hurdle\n        performance_above_hurdle = max(0, fund_performance - (previous_aum * soft_hurdle_rate))\n        \n        # Calculate the incentive fee based on the excess performance (above both high-water mark and soft hurdle rate)\n        incentive_fee = performance_above_hwm * incentive_fee_rate if performance_above_hwm > performance_above_hurdle else performance_above_hurdle * incentive_fee_rate\n    else:\n        # No incentive fee if the performance does not exceed the high-water mark\n        incentive_fee = 0\n    \n    # Calculate the overall fee\n    overall_fee = management_fee + incentive_fee\n    \n    # return answer\n    return overall_fee\n\n# Call the function and print the result\nprint(solution())\n```\n\nThis code defines a function `solution()` that computes the overall fee Circle garnered in the current year based on the provided investment parameters. It calculates the management fee, checks if the fund's yield surpassed the high-water mark and the soft hurdle, and if so, computes the incentive fee accordingly before summing them up to get the overall fee. If the performance does not exceed the high-water mark, no incentive fee is calculated."
        ]
    },
    {
        "question_id": "validation-196",
        "question": "Imagine a portfolio that contains two components. The first component, Component X, makes up 25% of the portfolio and possesses a standard deviation of 17.9%. The second component, Component Y, makes up the rest of the portfolio at 75% and has a standard deviation of 6.2%. If the correlation between these two components is 0.5, what would the portfolio's standard deviation be?",
        "tables": [],
        "python_solution": "def solution():\n    import math\n    weight_X = 0.25\n    weight_Y = 0.75\n    standard_deviation_X = 0.179\n    standard_deviation_Y = 0.062\n    correlation_XY = 0.5\n\n    portfolio_variance = (weight_X**2 * standard_deviation_X**2) + (weight_Y**2 * standard_deviation_Y**2) + (2 * weight_X * weight_Y * correlation_XY * standard_deviation_X * standard_deviation_Y)\n    portfolio_standard_deviation = math.sqrt(portfolio_variance)\n\n    return portfolio_standard_deviation*100",
        "ground_truth": 7.903,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "Here's the Python program that calculates the portfolio's standard deviation:\n\n```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight_X = 0.25\n    weight_Y = 0.75\n    std_dev_X = 0.179\n    std_dev_Y = 0.062\n    correlation_XY = 0.5\n    \n    # Do math calculation to get the answer\n    # Portfolio Variance = (weight_X * std_dev_X)^2 + (weight_Y * std_dev_Y)^2 + 2 * weight_X * weight_Y * correlation_XY * std_dev_X * std_dev_Y\n    portfolio_variance = (weight_X * std_dev_X)**2 + (weight_Y * std_dev_Y)**2 + 2 * weight_X * weight_Y * correlation_XY * std_dev_X * std_dev_Y\n    portfolio_std_dev = math.sqrt(portfolio_variance)\n    \n    # return answer\n    return portfolio_std_dev\n\n# For example usage\nprint(f\"The portfolio's standard deviation is: {solution()}\")\n```\n\nWhen you run this program, it will calculate and print out the portfolio's standard deviation."
        ]
    },
    {
        "question_id": "validation-197",
        "question": "If an investment company starts the year with a value of $160 million and follows a \"2 and 20\" fee scheme, the management fee depends on the end-of-year asset value. With a soft hurdle rate of 10% net of management fee for calculating the incentive fee, and a prior high-water mark of $198 million, how much is the total fees collected if the assets increase by 25% in the coming year?",
        "tables": [],
        "python_solution": "def solution():\n    initial_aum = 160\n    growth_rate = 0.25\n    management_fee_rate = 0.02\n    soft_hurdle_rate = 0.10\n    high_water_mark = 198\n    \n    end_year_aum = initial_aum * (1 + growth_rate)\n    \n    management_fee = end_year_aum * management_fee_rate\n    \n    net_year_end = end_year_aum - management_fee\n    \n    if net_year_end < high_water_mark:\n        total_fees = management_fee\n\n    return total_fees",
        "ground_truth": 4.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "```python\ndef solution():\n    # Define variables name and value\n    initial_value = 160e6  # Starting asset value in dollars\n    management_fee_rate = 0.02  # Management fee rate (2% or \"2 and 20\")\n    performance_fee_rate = 0.20  # Performance fee rate (20% or \"2 and 20\")\n    hurdle_rate = 0.10  # Soft hurdle rate (10%)\n    previous_high_water_mark = 198e6  # Previous high-water mark in dollars\n    growth_rate = 0.25  # Asset growth rate (25%)\n\n    # Calculate end-of-year asset value\n    end_of_year_value = initial_value * (1 + growth_rate)\n\n    # Calculate management fee\n    management_fee = end_of_year_value * management_fee_rate\n\n    # Determine if the performance fee should be calculated\n    performance_fee = 0\n    if end_of_year_value > previous_high_water_mark:\n        performance_fee_base = end_of_year_value - previous_high_water_mark\n        # Calculate net performance above hurdle rate (after management fee deduction)\n        net_performance = performance_fee_base - management_fee\n        if net_performance > (initial_value * hurdle_rate):\n            performance_fee = net_performance * performance_fee_rate\n\n    # Calculate total fees collected\n    total_fees = management_fee + performance_fee\n\n    # return answer\n    return total_fees\n\n# Run the solution function and print the result\nprint(\"${:,.2f}\".format(solution()))\n```\n\nThis program will calculate the total fees collected by the investment company based on an increase of 25% in their assets under management, using a \"2 and 20\" fee scheme and taking into account the previous high-water mark and a soft hurdle rate. The print statement at the end will format the result as a dollar amount with two decimal places and commas as thousand separators."
        ]
    },
    {
        "question_id": "validation-198",
        "question": "What is the growth rate of Real Estate #1, according to Exhibit 2?",
        "tables": [
            "|     | Year 1 | Year 2 | Year 3 | Year 4 | Year 5 | Year 6 |\n| --- | ---    | ---    | ---    | ---    | ---    | ---    |\n| NOI  | $2,775,840 | $2,859,119 | $2,944,889 | $3,033,235 | $3,124,232 | $3,217,959 |\n| DCF Assumptions |    |   |   |   |    |    |\n| Investment Hold Period |    |   | 5 years |   |    |    |\n| Going-in Cap Rate |     |   |  5.25% |   |    |    |\n| Terminal Cap Rate |    |   |  6.00% |   |    |    |\n| Discount Rate |     |   |  7.25% |   |    |    |\n| Income/Value Growth |    |   |  Constant |   |    |    |\n| Rate |     |   |   |   |    |    |"
        ],
        "python_solution": "def solution():\n    discount_rate = 7.25\n    going_in_cap_rate = 5.25\n    growth_rate = discount_rate - going_in_cap_rate\n    return growth_rate",
        "ground_truth": 2.0,
        "topic": "Asset Classes & Derivatives",
        "output": [
            "To find the growth rate of Real Estate #1 over the years provided in the exhibit, we can calculate the compounded annual growth rate (CAGR). The CAGR can be calculated using the following formula:\n\n\\[ CAGR = \\left( \\frac{{\\text{Ending Value}}}{{\\text{Beginning Value}}} \\right)^{\\frac{1}{{\\text{Number of Periods}}}} - 1 \\]\n\nIn this case, the beginning value will be the Net Operating Income (NOI) of Year 1 and the ending value will be the NOI of Year 6. The number of periods is 5 years (from Year 1 to Year 6).\n\nHere is the Python program to calculate the growth rate:\n\n```python\ndef solution():\n    # Define variables name and value\n    noi_year_1 = 2775840\n    noi_year_6 = 3217959\n    number_of_years = 5  # from Year 1 to Year 6\n    \n    # Calculate the Compounded Annual Growth Rate (CAGR)\n    cagr = ((noi_year_6 / noi_year_1) ** (1 / number_of_years)) - 1\n    \n    # Return the growth rate as a percentage\n    growth_rate = cagr * 100  # Convert to percentage format\n    \n    # return answer\n    return growth_rate\n\n# You can uncomment the following line to test the function\n# print(solution())\n```\n\nThis program will return the growth rate as a percentage."
        ]
    },
    {
        "question_id": "validation-199",
        "question": "Compute the standard deviation of the investment portfolio using the following figures: the percentage weight of asset X is 30%, the weight of asset Y is 70%, the standard deviation for asset X is 25%, that for asset Y is 10%, and their correlation coefficient is 0.8.",
        "tables": [],
        "python_solution": "def solution():\n    weight_X = 0.30\n    standard_deviation_X = 0.25\n    weight_Y = 0.70\n    standard_deviation_Y = 0.10\n    correlation_coefficient = 0.8\n\n    variance = weight_X**2 * standard_deviation_X**2 + weight_Y**2 * standard_deviation_Y**2 + 2 * weight_X * weight_Y * standard_deviation_X * standard_deviation_Y * correlation_coefficient\n\n    return variance**0.5",
        "ground_truth": 0.138,
        "topic": "Portfolio Management & Strategy",
        "output": [
            "```python\nimport math\n\ndef solution():\n    # Define variables name and value\n    weight_x = 0.30\n    weight_y = 0.70\n    std_dev_x = 0.25\n    std_dev_y = 0.10\n    cor_xy = 0.8\n\n    # Do math calculation to get the answer\n    # Compute the variance of the portfolio which includes the weights, standard deviations, and the correlation coefficient\n    portfolio_variance = ((weight_x * std_dev_x) ** 2 + \n                          (weight_y * std_dev_y) ** 2 +\n                          2 * weight_x * weight_y * std_dev_x * std_dev_y * cor_xy)\n\n    # Taking square root of the variance to get the standard deviation\n    portfolio_std_dev = math.sqrt(portfolio_variance)\n    \n    # return answer\n    return portfolio_std_dev\n\n# Example usage:\n# portfolio_std_dev = solution()\n# print(portfolio_std_dev)\n```"
        ]
    }
]